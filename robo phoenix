//+------------------------------------------------------------------+
//|                         Phoenix_Trader_v307_FIXED_CORRIGIDO.mq5  |
//|          CONTAGEM CORRIGIDA + DECAY FUNCIONAL + EXPLORA√á√ÉO LIMITADA |
//|                  COM SISTEMA DE MEM√ìRIA OTIMIZADA COMPLETA       |
//|                      SISTEMA DE BLOQUEIO UNIFICADO              |
//|                             ESTADOS VARIADOS v307F_ESTADOS       |
//|                + SISTEMA DE DECAY E RESET INTELIGENTE           |
//|                  + CORRE√á√ïES CR√çTICAS IMPLEMENTADAS             |
//|               + CORRE√á√ïES EXTREMAS PARA ESTADOS TRAVADOS        |
//+------------------------------------------------------------------+
#property copyright "Phoenix Trader"
#property link      ""
#property version   "3.07"

// ====
// Includes essenciais
// ====
#include <Trade/Trade.mqh>
#include <Trade/PositionInfo.mqh>
#include <Trade/OrderInfo.mqh>
#include <Trade/DealInfo.mqh>
#include <Trade/HistoryOrderInfo.mqh>

// ====
// ‚úÖ PASSO 1 ‚Äî CRIAR MEM√ìRIA PERSISTENTE (OBRIGAT√ìRIO)
// ====
#define STATE_FILE "state_memory.bin"

// ====
// Objetos utilit√°rios
// ====
CTrade          trade;
CPositionInfo   positionInfo;
COrderInfo      orderInfo;
CDealInfo       dealInfo;
CHistoryOrderInfo historyOrderInfo;

// ====
// ‚úÖ‚úÖ‚úÖ ATUALIZA√á√ÉO CR√çTICA: DISCRETIZA√á√ÉO DE ESTADO OTIMIZADA
// ============================================================
// Reduzindo para um n√∫mero gerenci√°vel de estados
#define BINS_MA_DIST   3      // Reduzido de 6 para 3
#define BINS_RSI       4      // Reduzido de 6 para 4  
#define BINS_ADX       2      // Mantido 2
#define BINS_BBPOS     3      // Reduzido de 6 para 3
#define BINS_VOLATILITY 2     // Mantido 2
#define BINS_VOLUME    2      // Reduzido de 3 para 2
#define BINS_TIME      2      // Reduzido de 4 para 2

// C√°lculo do n√∫mero total de estados - DEVE SER 576
#define NUM_STATES (BINS_MA_DIST * BINS_RSI * BINS_ADX * BINS_BBPOS * BINS_VOLATILITY * BINS_VOLUME * BINS_TIME)

#define NUM_ACTIONS 3  // 0:NOP, 1:Buy, 2:Sell

// ============================================================
// ‚úÖ CONSTANTES CR√çTICAS - APRENDIZADO CORRIGIDO
// ============================================================
const int MIN_VISITS_FOR_BLOCK = 30;

// Persist√™ncia
#define FILE_MAGIC   0x50484F45
#define FILE_VERSION 3073

#ifndef INT_MAX
  #define INT_MAX 2147483647
#endif
#ifndef DBL_MAX
  #define DBL_MAX 1.7e308
#endif

// ======================================================================
// Inputs ‚Äî organiza√ß√£o por grupos
// ======================================================================

input group "=== LIMITES DI√ÅRIOS ===";
input int    MaxTradesPerDay    = 30;
input int    ConsecutiveLossLimit    = 15;

// ======================================================================
// ‚úÖ APRENDIZADO CORRIGIDO
// ======================================================================
input group "=== APRENDIZADO CORRIGIDO ===";
input bool   UseSimpleRewardSystem   = true;
input double RewardWin     = 5.0;
input double RewardLoss    = -2.0;

input group "=== SISTEMA DE DECAY E RESET ===";
input bool   EnableMemoryDecay       = true;
input double DecayFactor            = 0.05;  // ‚ö†Ô∏è ALTERADO: 5% de esquecimento por ciclo (mais agressivo)
input bool   EnableIntelligentReset  = true;
input double BadStateLossThreshold   = 0.60;   // ‚ö†Ô∏è ALTERADO: 60% de perdas para reset
input int    BadStateMinVisits       = 3;      // ‚ö†Ô∏è ALTERADO: Apenas 3 visitas
input int    DecayCheckIntervalHours = 1;      // Verificar decay a cada hora
input bool   ExcludeNOPFromVisits    = true;   // NOP n√£o conta como visita

input group "=== INDICADORES ===";
input int    MAPeriod    = 200;
input ENUM_MA_METHOD  MAMethod    = MODE_EMA;
input int    RSIPeriod   = 20;
input int    BBPeriod    = 24;
input double BBDeviation = 2.2;
input int    ATRPeriod   = 18;

// ======================================================================
// ‚úÖ FILTRO DE VOLUME REAL CORRIGIDO
// ======================================================================
input group "=== FILTRO DE VOLUME REAL (NOVO) ===";
input bool   UseRealVolumeFilter     = true;
input int    VolumeMAPeriod          = 15;
input double MinVolumeMultiplier     = 0.5;

// ‚úÖ CONFIGURA√á√ïES DE INDICADORES
input group "=== CONFIGURA√á√ïES DE INDICADORES ===";
input bool   UseRSIValidation    = true;
input double RSI_Overbought      = 75.0;
input double RSI_Oversold        = 25.0;
input bool   UseBBValidation     = true;
input double BB_UpperThreshold   = 0.7;
input double BB_LowerThreshold   = 0.3;
input bool   UseADXValidation    = true;
input double MinADXStrength      = 20.0;
input bool   UseTrendValidation  = true;
input double MinDistanceFromMA   = 0.3;

input group "=== NEGOCIA√á√ÉO COM STOPS 100% POR PONTOS ===";
input double LotSize    = 0.01;
input int    MagicNumber    = 27101;

// ‚úÖ STOPS 100% POR PONTOS
input group "=== STOP LOSS 100% POR PONTOS ===";
input bool   UseFixedSL          = true;
input int    FixedSL_Points      = 35000;

input group "=== TAKE PROFIT COM TRAILING (APENAS TP SE MOVE) ===";
input bool   UseFixedTP          = true;
input int    FixedTP_Points      = 70000;

// ======================================================================
// ‚úÖ‚úÖ‚úÖ TRAILING STOP DIN√ÇMICO COMPLETO (CORRIGIDO)
// ======================================================================
input group "=== TRAILING STOP DIN√ÇMICO COMPLETO ===";
input bool   UseDynamicTrailingStop  = false;
input int    TrailingStopPoints      = 20000;
input int    TrailingStepPoints      = 5000;
input int    TrailingStartPoints     = 10000;
input bool   UseATRTrailing         = false;
input double ATRTrailingMultiplier  = 2.5;
input bool   UseBreakevenStop       = false;
input int    BreakevenTriggerPoints = 15000;
input bool   TrailBothSLandTP       = false;

// ======================================================================
// ‚úÖ BET SIZING CORRIGIDO
// ======================================================================
input group "=== BET SIZING (MAO PESADA) ===";
input bool   EnableSmartLot        = true;
input double HighQualityThreshold  = 0.3;
input double UltraQualityThreshold = 0.8;
input double SmartLotMultiplier    = 1.8;
input double UltraLotMultiplier    = 3.0;
input double MaxAllowedLot         = 1.0;

// ‚úÖ CONTROLE DE TEMPO ENTRE TRADES
input int    MinMinutesBetweenTrades = 3;

// ======================================================================
// ‚úÖ PIRAMIDA√á√ÉO CORRIGIDA
// ======================================================================
input group "=== PIRAMIDA√á√ÉO (SOMENTE MESMA DIRE√á√ÉO) ===";
input bool   EnablePyramiding = true;
input int    MaxPyramidPositions = 4;
input double PyramidingDistanceATR = 0.4;
input bool   ReduceLotOnPyramiding = false;
input double PyramidingLotMultiplier = 0.8;

// ======================================================================
// ‚úÖ DIRE√á√ÉO √öNICA POR CICLO
// ======================================================================
input group "=== CONTROLE DE DIRE√á√ÉO ===";
input bool   AllowOnlyOneDirection = true;
input bool   CloseOppositeOnNewSignal = false;
input bool   WaitForAllCloseBeforeNew = true;

// ======================================================================
// ‚úÖ CONTROLE DE ENTRADAS
// ======================================================================
input group "=== CONTROLE DE ENTRADAS ===";
input int    MaxTradesPerDirection = 4;
input int    MinBarsBetweenSameDirection = 2;
input bool   UseVolatilityFilter = true;
input double MaxATRMultiplier = 4.0;

// ======================================================================
// ‚úÖ APRENDIZADO (CONFIGURA√á√ïES OTIMIZADAS PARA PIRAMIDA√á√ÉO)
// ======================================================================
input group "=== APRENDIZADO OTIMIZADO PARA PIRAMIDA√á√ÉO ===";
double LearningRate    = 0.03;      // ‚ö†Ô∏è ALTERADO: REDUZIDO - Aprender mais devagar
input double InitialExplorationRate  = 0.40;  // ‚ö†Ô∏è ALTERADO: 40% inicial
input double MinExplorationRate    = 0.20;    // ‚ö†Ô∏è ALTERADO: M√≠nimo 20%
input double ExplorationDecay    = 0.995;     // ‚ö†Ô∏è ALTERADO: Decay mais r√°pido
input int    MinStateVisitsToTrade = 2;       // ‚ö†Ô∏è ALTERADO: Apenas 2 visitas

// ‚ö° SISTEMA H√çBRIDO OTIMIZADO PARA PIRAMIDA√á√ÉO
input group "=== SISTEMA H√çBRIDO OTIMIZADO PARA PIRAMIDA√á√ÉO ===";
input bool   EnablePyramidingLearning = true;
input int    PyramidLearningBonus     = 10;
input double PyramidBlockingMultiplier = 1.5;
input int    MinPyramidVisitsForBlock = 50;

// ======================================================================
// ‚ö° SISTEMA DE MEM√ìRIA OTIMIZADA (NOVO DO V30.7)
// ======================================================================
input group "=== SISTEMA DE MEM√ìRIA OTIMIZADA ===";
input bool   EnableMemoryOptimization = true;
input int    MaxMemoryStates = 1000;  // Ajustado para n√∫mero gerenci√°vel
input bool   CompressQValues = true;
input double QValuePrecision = 2;
input bool   AutoCleanMemory = true;
input int    CleanMemoryAfterTrades = 100;
input bool   UseIncrementalSave = true;

// ======================================================================
// ‚úÖ‚úÖ‚úÖ SISTEMA DE BLOQUEIO UNIFICADO (NOVA VERS√ÉO CORRIGIDA)
// ======================================================================
input group "=== SISTEMA DE BLOQUEIO UNIFICADO ===";
input bool   EnableUnifiedBlockingSystem = true;
input double BlockLossRateThreshold = 0.75;
input double UnblockWinRateThreshold = 0.55;
int MinVisitsForBlockDecision = 30;

// ======================================================================
// ‚úÖ CONFIGURA√á√ïES DE EXPORTA√á√ÉO DE MEM√ìRIA
// ======================================================================
input group "=== EXPORTA√á√ÉO DE MEM√ìRIA ===";
input bool   EnableMemoryExport   = true;
input int    AutoExportMinutes    = 30;
input bool   ExportOnDeinit       = true;
input bool   CreateBackupFiles    = true;
input int    MaxBackupFiles       = 5;
input bool   ExportMemoryToTextFile   = true;
input int    TextExportIntervalMinutes = 60;

// ======================================================================
// ‚úÖ EXPORTA√á√ÉO PARA TEXTO (COMPLEMENTAR AO BIN√ÅRIO)
// ======================================================================
input group "=== EXPORTA√á√ÉO PARA TEXTO ===";
input bool   EnableTextExport     = true;
input int    TextExportMinInterval   = 30;
input bool   ExportAllStates      = false;
input bool   IncludeQValues       = true;
input bool   IncludeStatistics    = true;
input int    MaxStatesToExport    = 500;

// ======================================================================
// ‚úÖ HUD LEVE - CONFIGURA√á√ïES OTIMIZADAS
// ======================================================================
input group "=== HUD LEVE ===";
input bool   ShowHUD              = true;
input int    HUD_X                = 10;
input int    HUD_Y                = 20;
input int    HUD_UpdateMS         = 500;
input color  HUD_TitleColor       = clrLime;
input color  HUD_TextColor        = clrWhite;
input color  HUD_WarningColor     = clrOrange;
input color  HUD_ErrorColor       = clrRed;
input color  HUD_SuccessColor     = clrCyan;
input bool   HUD_Minimal          = false;

// ======================================================================
// ‚úÖ‚úÖ‚úÖ VARI√ÅVEIS GLOBAIS ADICIONADAS
// ======================================================================
double g_volumeRatio = 1.0;
bool AllowBreakoutOverride = true;

// ======================================================================
// ‚úÖ‚úÖ‚úÖ ‚úÖ PASSO 1 ‚Äî CRIAR UM VETOR DE BLOQUEIO REAL (CORRE√á√ÉO DO HUD)
// ======================================================================
bool g_stateBlocked[];

// ======================================================================
// ‚úÖ‚úÖ‚úÖ NOVO: CONTADORES SEPARADOS PARA VIT√ìRIAS E PERDAS REAIS
// ======================================================================
int g_stateWins[];
bool g_lastTradeExecuted = false;
int g_lastTradeStateExecuted = -1;

// ======================================================================
// ‚úÖ‚úÖ‚úÖ ‚úÖ‚úÖ‚úÖ NOVO: SISTEMA DE COOLDOWN PARA BLOQUEIO
// ======================================================================
datetime g_stateLastBlockTime[];
datetime g_stateLastUnblockTime[];

// ======================================================================
// ‚úÖ‚úÖ‚úÖ SISTEMA DE MEM√ìRIA OTIMIZADA - VARI√ÅVEIS
// ======================================================================
double g_Q[];
int g_stateVisits[];
int g_stateLosses[];
int g_stateLastUpdate[];

// Cache para estados ativos (otimiza√ß√£o)
int g_activeStates[];
int g_activeStatesCount = 0;
bool g_memoryDirty = false;
int g_memorySaveCounter = 0;
int g_memoryCleanCounter = 0;

// ======================================================================
// ‚úÖ‚úÖ‚úÖ VARI√ÅVEIS PARA PROTE√á√ÉO CONTRA ESTADO CONGELADO
// ======================================================================
static int g_lastCalculatedState = -1;
static int g_sameStateCount = 0;
static datetime g_lastStateChangeTime = 0;

// ======================================================================
// ‚úÖ‚úÖ‚úÖ VARI√ÅVEIS PARA DECAY E RESET
// ======================================================================
datetime g_lastMaintenanceTime = 0;
int g_totalDecayCycles = 0;
int g_totalBadStateResets = 0;

// ======================================================================
// Vari√°veis do HUD OTIMIZADAS
// ======================================================================
string hudObjects[15];
int hudObjectCount = 0;
datetime hudLastUpdate = 0;
int cachedVisitedStates = -1;
int cachedBlockedStates = -1;
int cachedPositions = -1;
int cachedDirection = -1;
string cachedStatus = "";
double cachedVolume = -1;
int cachedTradesToday = -1;

// ====
// VARI√ÅVEIS GLOBAIS
// ============================================================
string g_currentSymbol;
int g_adxHandle = INVALID_HANDLE;
int g_maHandle  = INVALID_HANDLE;
int g_rsiHandle = INVALID_HANDLE;
int g_bbHandle  = INVALID_HANDLE;
int g_atrHandle = INVALID_HANDLE;

bool g_learningInitialized = false;
double g_currentExplorationRate = 0.0;

string g_memoryFileName = "";
bool g_memoryInitialized = false;
datetime g_lastSaveTime = 0;
int g_qUpdatesSinceSave = 0;

int g_lastTradeState = -1;
double g_lastTradeProfit = 0.0;
int g_lastTradeAction = 0;
double g_lastLotUsed = 0.0;
double g_lastSLPrice = 0.0;
double g_lastTPPrice = 0.0;

int g_tradesToday = 0;
datetime g_lastTradeDate = 0;
int g_consecutiveLosses = 0;
string g_statusMessage = "Inicializando...";
datetime g_lastResetDate = 0;

int g_totalTrades = 0;
int g_totalWins   = 0;
int g_totalLosses = 0;
double g_sumProfit = 0.0;

int g_currentDirection = 0;
int g_positionsCount = 0;
datetime g_directionStartTime = 0;

datetime g_lastExportTime = 0;
int g_exportCount = 0;

datetime g_lastEntryTime = 0;
datetime g_lastTradeTime = 0;
datetime g_lastBuyTime = 0;
datetime g_lastSellTime = 0;
bool g_lastSaveSuccess = false;
int g_lastBarProcessed = 0;

long g_currentVolume = 0;
long g_volumeAverage = 0;
double g_volumeMultiplier = 1.0;
double g_volumeStrength = 0.0;
datetime g_lastVolumeCheck = 0;

double g_recentProfits[];
int g_recentProfitsIndex = 0;

int g_totalStatesDiscovered = 0;
int g_totalQUpdates = 0;
double g_averageQValue = 0.0;
double g_maxQValue = 0.0;
double g_minQValue = 0.0;

datetime g_firstTradeDate = 0;
double g_highestProfit = 0.0;
double g_lowestProfit = 0.0;
int g_bestWinStreak = 0;
int g_worstLossStreak = 0;
int g_currentWinStreak = 0;
int g_currentLossStreak = 0;

int g_totalBuys = 0;
int g_totalSells = 0;
int g_buyWins = 0;
int g_sellWins = 0;
double g_buyProfit = 0.0;
double g_sellProfit = 0.0;

// Vari√°veis para DEBUG
int g_debugState = -1;
int g_debugVisitas = 0;
int g_debugPerdas = 0;

// ======================================================================
// ‚úÖ‚úÖ‚úÖ VARI√ÅVEIS DO SISTEMA DE APRENDIZADO INTELIGENTE
// ======================================================================
double g_stateWinRate[];
double g_stateAvgProfit[];
int g_stateResets = 0;
int g_stateDecays = 0;
static int g_lastDecayTradeCount = 0;

// ======================================================================
// ‚úÖ VARI√ÅVEIS PARA TRAILING STOP DIN√ÇMICO
// ======================================================================
ulong   g_trailingTickets[];
double  g_trailingBestPrices[];
double  g_trailingCurrentSL[];
double  g_trailingCurrentTP[];
datetime g_trailingLastTrailTimes[];
bool    g_trailingBreakevenActivated[];
int     g_trailingCount = 0;

// ======================================================================
// ‚úÖ‚úÖ‚úÖ VARI√ÅVEIS PARA EXPORTA√á√ÉO DE TEXTO
// ======================================================================
datetime g_lastTextExportTime = 0;
int g_textExportCount = 0;

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO SAFEDIVIDE - PROTE√á√ÉO CONTRA DIVIS√ÉO POR ZERO
// ======================================================================
//+------------------------------------------------------------------+
//| Fun√ß√£o SafeDivide - Realiza divis√£o segura evitando divis√£o por zero
//| Par√¢metros:
//|   numerator   - O numerador da divis√£o
//|   denominator - O denominador da divis√£o  
//|   defaultValue - Valor padr√£o a retornar se denominador for zero (padr√£o: 0.0)
//| Retorna:
//|   O resultado da divis√£o ou defaultValue se denominator == 0
//+------------------------------------------------------------------+
double SafeDivide(double numerator, double denominator, double defaultValue = 0.0)
{
   // Static epsilon for performance - only calculated once
   static const double EPSILON = MathMax(DBL_EPSILON * 1000, 1e-10);
   
   if(denominator == 0.0 || MathAbs(denominator) < EPSILON)
   {
      static datetime lastWarningTime = 0;
      datetime currentTime = TimeCurrent();
      
      // Log warning apenas uma vez por minuto para evitar spam
      if(currentTime - lastWarningTime > 60)
      {
         Print("‚ö†Ô∏è DIVIS√ÉO POR ZERO EVITADA | Numerador: ", DoubleToString(numerator, 8), 
               " | Denominador: ", DoubleToString(denominator, 8), 
               " | Retornando valor padr√£o: ", DoubleToString(defaultValue, 8));
         lastWarningTime = currentTime;
      }
      
      return defaultValue;
   }
   
   return numerator / denominator;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ CORRE√á√ïES AGUDAS PARA O PROBLEMA DE ESTADOS TRAVADOS
// ======================================================================

// ======================================================================
// ‚úÖ‚úÖ‚úÖ 1. FUN√á√ÉO: REMOVER LIMITE DE 10 VISITAS (CORRE√á√ÉO DEFINITIVA)
// ======================================================================
void FixStuckStatesProblem()
{
   Print("üî•üî•üî• CORRE√á√ÉO DE ESTADOS TRAVADOS EM 10 VISITAS");
   
   int fixedStates = 0;
   int problemStates = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         // ‚úÖ DETECTAR ESTADOS TRAVADOS EM M√öLTIPLOS DE 10
         if(g_stateVisits[state] == 10 || g_stateVisits[state] == 20 || g_stateVisits[state] == 30)
         {
            problemStates++;
            
            // ‚úÖ VERIFICAR SE √â UM LIMITE ARTIFICIAL
            double winRate = CalculateWinRate(state);
            bool hasRecentActivity = (g_totalTrades - g_stateLastUpdate[state]) < 100;
            
            // ‚úÖ REMOVER LIMITE SE FOR ARTIFICIAL
            if(g_stateVisits[state] == 10 && hasRecentActivity)
            {
               Print("‚ö†Ô∏è Estado ", state, " travado em 10 visitas - DESBLOQUEANDO...");
               
               // Desbloquear se estiver bloqueado erroneamente
               if(g_stateBlocked[state] && winRate >= 0.25)
               {
                  g_stateBlocked[state] = false;
                  Print("‚úÖ Estado ", state, " desbloqueado (win rate: ", DoubleToString(winRate*100,1), "%)");
               }
               
               // Permitir mais visitas
               g_stateVisits[state] = 9; // Resetar para permitir crescimento
               fixedStates++;
            }
         }
         
         // ‚úÖ CORRIGIR ESTADOS BLOQUEADOS ERRONEAMENTE
         if(g_stateBlocked[state] && g_stateVisits[state] >= 5)
         {
            double winRate = CalculateWinRate(state);
            
            // Estado com win rate boa n√£o deveria estar bloqueado
            if(winRate >= 0.35 && winRate > 0)
            {
               g_stateBlocked[state] = false;
               Print("‚úÖ‚úÖ‚úÖ CORRE√á√ÉO: Estado ", state, 
                     " desbloqueado - Win rate: ", DoubleToString(winRate*100,1), "%");
               fixedStates++;
            }
         }
      }
   }
   
   if(problemStates > 0 || fixedStates > 0)
   {
      Print("üìä RESUMO DA CORRE√á√ÉO:");
      Print("   Estados com problema (travados): ", problemStates);
      Print("   Estados corrigidos: ", fixedStates);
      Print("   Estados ativos totais: ", g_activeStatesCount);
      Print("   Estados bloqueados ap√≥s corre√ß√£o: ", CountBlockedStates());
      
      // For√ßar save
      g_memoryDirty = true;
      SaveState();
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ 2. FUN√á√ÉO: RESETAR SISTEMA DE BLOQUEIO (CORRE√á√ÉO RADICAL)
// ======================================================================
void ResetBlockingSystem()
{
   Print("üîÑ RESETANDO SISTEMA DE BLOQUEIO COMPLETAMENTE");
   
   int unblocked = 0;
   int resetVisits = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      // Desbloquear todos os estados
      if(g_stateBlocked[state])
      {
         g_stateBlocked[state] = false;
         unblocked++;
      }
      
      // Resetar estados com exatamente 10 visitas (poss√≠vel bug)
      if(g_stateVisits[state] == 10)
      {
         g_stateVisits[state] = 5; // Reduzir para valor mais realista
         resetVisits++;
      }
   }
   
   // Resetar contadores do sistema de bloqueio
   g_stateResets = 0;
   g_stateDecays = 0;
   g_totalBadStateResets = 0;
   
   Print("‚úÖ SISTEMA DE BLOQUEIO RESETADO:");
   Print("   Estados desbloqueados: ", unblocked);
   Print("   Estados com visitas resetadas: ", resetVisits);
   Print("   Contadores zerados: stateResets, stateDecays, totalBadStateResets");
   
   g_memoryDirty = true;
   SaveState();
   SaveBrain();
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ 4. FUN√á√ÉO: DEBUG MELHORADO PARA ESTADOS TRAVADOS
// ======================================================================
void DebugStuckStatesEnhanced()
{
   Print("=== DEBUG ESTADOS TRAVADOS (VERS√ÉO MELHORADA) ===");
   
   int stuckAt10 = 0;
   int stuckAt20 = 0;
   int stuckAt30 = 0;
   int wronglyBlocked = 0;
   int correctlyBlocked = 0;
   int totalBlocked = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         if(g_stateVisits[state] == 10) stuckAt10++;
         if(g_stateVisits[state] == 20) stuckAt20++;
         if(g_stateVisits[state] == 30) stuckAt30++;
         
         if(g_stateBlocked[state])
         {
            totalBlocked++;
            double winRate = CalculateWinRate(state);
            
            if(winRate >= 0.30 && g_stateVisits[state] >= 5)
            {
               wronglyBlocked++;
               Print("‚ùå‚ùå‚ùå ERRO CR√çTICO: Estado ", state, 
                     " bloqueado com win rate BOA: ", DoubleToString(winRate*100,1), "%",
                     " | Visitas: ", g_stateVisits[state]);
            }
            else if(winRate < 0.25 && g_stateVisits[state] >= 5)
            {
               correctlyBlocked++;
            }
         }
      }
   }
   
   Print("üìä ESTAT√çSTICAS DETALHADAS:");
   Print("   Estados travados em 10 visitas: ", stuckAt10);
   Print("   Estados travados em 20 visitas: ", stuckAt20);
   Print("   Estados travados em 30 visitas: ", stuckAt30);
   Print("   Estados bloqueados totais: ", totalBlocked);
   Print("   Estados bloqueados CORRETAMENTE: ", correctlyBlocked);
   Print("   Estados bloqueados ERRONEAMENTE: ", wronglyBlocked);
   Print("   Taxa de erro no bloqueio: ", totalBlocked > 0 ? 
         DoubleToString((double)wronglyBlocked/totalBlocked*100, 1) : "0.0", "%");
   
   // ‚úÖ CORRE√á√ÉO AUTOM√ÅTICA
   if(wronglyBlocked > 0)
   {
      Print("üî•üî•üî• APLICANDO CORRE√á√ÉO AUTOM√ÅTICA...");
      
      for(int state = 0; state < NUM_STATES; state++)
      {
         if(g_stateBlocked[state])
         {
            double winRate = CalculateWinRate(state);
            
            if(winRate >= 0.30 && g_stateVisits[state] >= 5)
            {
               g_stateBlocked[state] = false;
               Print("‚úÖ Estado ", state, " desbloqueado automaticamente");
            }
         }
      }
      
      Print("‚úÖ‚úÖ‚úÖ ", wronglyBlocked, " estados desbloqueados automaticamente");
   }
   
   Print("=== FIM DEBUG ===");
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ 5. FUN√á√ÉO: RESET SUAVE DE ESTADOS RUINS (VERS√ÉO MELHORADA)
// ======================================================================
void ResetBadStatesEnhanced()
{
   if(!EnableIntelligentReset) return;
   
   int statesReset = 0;
   int statesUnblocked = 0;
   
   Print("‚ôªÔ∏è RESET INTELIGENTE DE ESTADOS RUINS (VERS√ÉO MELHORADA)");
   
   for(int s = 0; s < NUM_STATES; s++)
   {
      if(g_stateVisits[s] >= 5) // M√≠nimo de 5 visitas
      {
         double winRate = CalculateWinRate(s);
         double lossRate = 1.0 - winRate;
         
         // ‚úÖ CRIT√âRIOS PARA RESET
         bool shouldReset = false;
         string reason = "";
         
         if(lossRate > 0.75 && g_stateVisits[s] >= 8)
         {
            shouldReset = true;
            reason = "Loss rate > 75%";
         }
         else if(winRate < 0.20 && g_stateVisits[s] >= 10)
         {
            shouldReset = true;
            reason = "Win rate < 20%";
         }
         else if(g_stateVisits[s] >= 15 && winRate == 0.0)
         {
            shouldReset = true;
            reason = "15+ visitas, 0 vit√≥rias";
         }
         
         if(shouldReset)
         {
            Print("üî• RESET Estado ", s, 
                  " | Motivo: ", reason,
                  " | Visitas: ", g_stateVisits[s],
                  " | Win Rate: ", DoubleToString(winRate*100,1), "%");
            
            // Reset parcial (mant√©m alguma mem√≥ria)
            g_stateVisits[s] = (int)(g_stateVisits[s] * 0.3);
            g_stateWins[s] = (int)(g_stateWins[s] * 0.3);
            g_stateLosses[s] = (int)(g_stateLosses[s] * 0.3);
            
            // Garantir m√≠nimo
            if(g_stateVisits[s] < 1) g_stateVisits[s] = 1;
            if(g_stateWins[s] < 0) g_stateWins[s] = 0;
            if(g_stateLosses[s] < 0) g_stateLosses[s] = 0;
            
            // Desbloquear
            g_stateBlocked[s] = false;
            
            // Reset parcial do Q
            for(int a = 0; a < NUM_ACTIONS; a++)
            {
               g_Q[s * NUM_ACTIONS + a] *= 0.5;
            }
            
            statesReset++;
            g_totalBadStateResets++;
         }
         
         // ‚úÖ DESBLOQUEAR ESTADOS BONS
         if(g_stateBlocked[s] && winRate >= 0.35 && g_stateVisits[s] >= 5)
         {
            g_stateBlocked[s] = false;
            statesUnblocked++;
            Print("‚úÖ DESBLOQUEIO Estado ", s,
                  " | Win Rate boa: ", DoubleToString(winRate*100,1), "%");
         }
      }
   }
   
   if(statesReset > 0 || statesUnblocked > 0)
   {
      Print("üìä RESUMO DO RESET:");
      Print("   Estados resetados: ", statesReset);
      Print("   Estados desbloqueados: ", statesUnblocked);
      Print("   Total resets acumulados: ", g_totalBadStateResets);
      
      g_memoryDirty = true;
      SaveState();
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ïES DE DECAY E RESET INTELIGENTE (NOVAS)
// ======================================================================

// ======================================================================
// ‚úÖ‚úÖ‚úÖ 1. FUN√á√ÉO DE DECAIMENTO SUAVE (OBRIGAT√ìRIA)
// ======================================================================
void ApplyStateDecay()
{
   if(!EnableMemoryDecay) return;
   
   const double DECAY_FACTOR = DecayFactor; // Configur√°vel pelo usu√°rio
   int statesDecayed = 0;
   double totalMemoryBefore = 0;
   double totalMemoryAfter = 0;

   for(int s = 0; s < NUM_STATES; s++)
   {
      if(g_stateVisits[s] > 0)
      {
         totalMemoryBefore += g_stateVisits[s];
         
         // Aplicar decay somente em estados com hist√≥rico significativo
         if(g_stateVisits[s] > 10)
         {
            g_stateVisits[s] = (int)(g_stateVisits[s] * DECAY_FACTOR);
            g_stateLosses[s] = (int)(g_stateLosses[s] * DECAY_FACTOR);
            g_stateWins[s] = (int)(g_stateWins[s] * DECAY_FACTOR);
            
            // Garantir valores m√≠nimos
            if(g_stateVisits[s] < 1 && g_stateVisits[s] > 0) g_stateVisits[s] = 1;
            if(g_stateLosses[s] < 0) g_stateLosses[s] = 0;
            if(g_stateWins[s] < 0) g_stateWins[s] = 0;
            
            statesDecayed++;
            
            // Atualizar Q-values gradualmente
            for(int a = 0; a < NUM_ACTIONS; a++)
            {
               int idx = s * NUM_ACTIONS + a;
               if(g_Q[idx] != 0.0)
               {
                  g_Q[idx] *= DECAY_FACTOR;
               }
            }
         }
         
         totalMemoryAfter += g_stateVisits[s];
      }
   }
   
   // Recalcular estados ativos
   g_activeStatesCount = 0;
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         if(g_activeStatesCount < MaxMemoryStates)
         {
            g_activeStates[g_activeStatesCount] = state;
            g_activeStatesCount++;
         }
      }
   }
   
   g_totalDecayCycles++;
   
   double memoryReduction = totalMemoryBefore > 0 ? 
                          (1.0 - SafeDivide(totalMemoryAfter, totalMemoryBefore, 1.0)) * 100 : 0;
   
   Print("üîÑ DECAY APLICADO: ", 
         "Estados ajustados: ", statesDecayed,
         " | Redu√ß√£o mem√≥ria: ", DoubleToString(memoryReduction, 1), "%",
         " | Estados ativos: ", g_activeStatesCount,
         " | Ciclos: ", g_totalDecayCycles);
   
   g_memoryDirty = true;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ 2. RESET INTELIGENTE DE ESTADOS RUINS (CORRIGIDA)
// ======================================================================
void ResetBadStates()
{
   if(!EnableIntelligentReset) return;
   
   int statesReset = 0;
   
   for(int s = 0; s < NUM_STATES; s++)
   {
      if(g_stateVisits[s] < BadStateMinVisits) continue; // Usar par√¢metro ajust√°vel
      
      double lossRate = SafeDivide((double)g_stateLosses[s], (double)g_stateVisits[s], 0.0);
      
      // ‚ö†Ô∏è MODIFICA√á√ÉO CR√çTICA: Condi√ß√£o mais agressiva
      if((lossRate > BadStateLossThreshold || (g_stateVisits[s] > 10 && g_stateWins[s] == 0)) 
         && g_stateVisits[s] > BadStateMinVisits)
      {
         // Salvar estat√≠sticas antes do reset
         int oldVisits = g_stateVisits[s];
         int oldLosses = g_stateLosses[s];
         int oldWins = g_stateWins[s];
         
         // Resetar contadores
         g_stateVisits[s] = 0;
         g_stateLosses[s] = 0;
         g_stateWins[s] = 0;
         g_stateBlocked[s] = false;
         g_stateLastBlockTime[s] = 0;
         g_stateLastUnblockTime[s] = 0;
         
         // Resetar Q-table do estado
         for(int a = 0; a < NUM_ACTIONS; a++)
         {
            g_Q[s * NUM_ACTIONS + a] = 0.0;
         }
         
         statesReset++;
         g_totalBadStateResets++;
         
         Print("‚ôªÔ∏è RESET DE ESTADO RUIM -> Estado: ", s,
               " | Visitas antigas: ", oldVisits,
               " | Perdas: ", oldLosses, " (", DoubleToString(lossRate*100, 1), "%)",
               " | Vit√≥rias: ", oldWins);
         
         g_memoryDirty = true;
      }
   }
   
   if(statesReset > 0)
   {
      // Recalcular estados ativos ap√≥s reset
      g_activeStatesCount = 0;
      for(int state = 0; state < NUM_STATES; state++)
      {
         if(g_stateVisits[state] > 0)
         {
            if(g_activeStatesCount < MaxMemoryStates)
            {
               g_activeStates[g_activeStatesCount] = state;
               g_activeStatesCount++;
            }
         }
      }
      
      Print("‚úÖ ", statesReset, " estados ruins resetados | Total resets: ", g_totalBadStateResets);
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ 3. MANUTEN√á√ÉO PERI√ìDICA DO SISTEMA
// ======================================================================
void PerformMemoryMaintenance()
{
   static datetime lastMaintenance = 0;
   
   if(TimeCurrent() - lastMaintenance < (DecayCheckIntervalHours * 3600))
      return;
   
   Print("üîß INICIANDO MANUTEN√á√ÉO PERI√ìDICA DO SISTEMA...");
   
   // 1. Aplicar decay suave
   if(EnableMemoryDecay)
   {
      ApplyStateDecay();
   }
   
   // 2. Resetar estados ruins
   if(EnableIntelligentReset)
   {
      ResetBadStates();
   }
   
   // 3. Limpar mem√≥ria se necess√°rio
   if(AutoCleanMemory)
   {
      CleanMemory();
   }
   
   // 4. Auto desbloquear estados bons
   if(EnableUnifiedBlockingSystem)
   {
      AutoUnblockGoodStates();
   }
   
   lastMaintenance = TimeCurrent();
   
   // Salvar ap√≥s manuten√ß√£o
   SaveBrain();
   SaveState();
   
   Print("‚úÖ MANUTEN√á√ÉO COMPLETA REALIZADA");
   Print("   ‚Ä¢ Decay aplicado: ", g_totalDecayCycles, " ciclos");
   Print("   ‚Ä¢ Estados resetados: ", g_totalBadStateResets);
   Print("   ‚Ä¢ Estados ativos: ", g_activeStatesCount);
   Print("   ‚Ä¢ Estados bloqueados: ", CountBlockedStates());
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ SISTEMA DE BLOQUEIO UNIFICADO CORRIGIDO
// ======================================================================

// ‚úÖ‚úÖ‚úÖ 1Ô∏è‚É£ FUN√á√ÉO UNIFICADA PARA BLOQUEAR ESTADO (CORRIGIDA)
void BlockState(int state)
{
    if(state < 0 || state >= NUM_STATES) return;

    if(g_stateLastBlockTime[state] > 0 && TimeCurrent() - g_stateLastBlockTime[state] < 3600)
    {
        Print("‚è≥ Cooldown ativo para estado ", state, " - aguardando 1h");
        return;
    }

    if(g_stateBlocked[state])
    {
        return;
    }

    int visits = g_stateVisits[state];
    int losses = g_stateLosses[state];
    
    if(visits < MinVisitsForBlockDecision)
    {
        Print("‚úÖ Estado ", state, " tem poucas visitas (", visits, ") - N√ÉO bloqueando");
        return;
    }
    
    double lossRate = SafeDivide((double)losses, (double)visits, 0.0);
    
    if(lossRate >= BlockLossRateThreshold)
    {
        g_stateBlocked[state] = true;
        g_stateLastBlockTime[state] = TimeCurrent();
        
        Print("‚õî ESTADO BLOQUEADO CORRETAMENTE: ", state, 
              " | Visitas REAIS: ", visits, 
              " | Perdas REAIS: ", losses, 
              " | Taxa de perda: ", DoubleToString(lossRate*100, 1), "%",
              " | M√≠nimo requerido: ", MinVisitsForBlockDecision, " visitas");
        
        g_memoryDirty = true;
    }
    else
    {
        Print("‚úÖ Estado ", state, " N√ÉO bloqueado - Taxa de perda: ", 
              DoubleToString(lossRate*100, 1), "% (limite: ", BlockLossRateThreshold*100, "%)");
    }
}

// ‚úÖ‚úÖ‚úÖ 2Ô∏è‚É£ FUN√á√ÉO UNIFICADA PARA DESBLOQUEAR ESTADO (CORRIGIDA)
void UnblockState(int state)
{
    if(state < 0 || state >= NUM_STATES) return;

    if(g_stateLastUnblockTime[state] > 0 && TimeCurrent() - g_stateLastUnblockTime[state] < 3600)
    {
        Print("‚è≥ Cooldown ativo para estado ", state, " - aguardando 1h");
        return;
    }

    if(g_stateBlocked[state])
    {
        g_stateBlocked[state] = false;
        g_stateLastUnblockTime[state] = TimeCurrent();
        
        Print("‚úÖ ESTADO DESBLOQUEADO: ", state, 
              " | Visitas: ", g_stateVisits[state], 
              " | Vit√≥rias: ", g_stateWins[state],
              " | Perdas: ", g_stateLosses[state],
              " | Win Rate: ", DoubleToString(CalculateWinRate(state)*100, 1), "%");
        
        g_memoryDirty = true;
    }
}

// ‚úÖ‚úÖ‚úÖ 3Ô∏è‚É£ FUN√á√ÉO PARA VERIFICAR SE UM ESTADO DEVE SER BLOQUEADO (CORRIGIDA)
bool ShouldBlockState(int state)
{
    if(state < 0 || state >= NUM_STATES) return false;
    
    int visits = g_stateVisits[state];
    int losses = g_stateLosses[state];
    
    if(visits < MinVisitsForBlockDecision) return false;
    
    double lossRate = SafeDivide((double)losses, (double)visits, 0.0);
    
    return (lossRate >= BlockLossRateThreshold);
}

// ‚úÖ‚úÖ‚úÖ 4Ô∏è‚É£ FUN√á√ÉO PARA VERIFICAR SE UM ESTADO DEVE SER DESBLOQUEADO (CORRIGIDA)
bool ShouldUnblockState(int state)
{
    if(state < 0 || state >= NUM_STATES) return false;
    
    if(!g_stateBlocked[state]) return false;
    
    int visits = g_stateVisits[state];
    
    if(visits < MinVisitsForBlockDecision) return false;
    
    double winRate = CalculateWinRate(state);
    
    return (winRate >= UnblockWinRateThreshold);
}

// ‚úÖ‚úÖ‚úÖ 5Ô∏è‚É£ FUN√á√ÉO PRINCIPAL DE VERIFICA√á√ÉO DE BLOQUEIO (SOMENTE LEITURA)
bool IsStateBlocked(int state)
{
    if(state < 0 || state >= NUM_STATES) return false;
    
    return g_stateBlocked[state];
}

// ‚úÖ‚úÖ‚úÖ 6Ô∏è‚É£ FUN√á√ÉO PARA AVALIAR E ATUALIZAR BLOQUEIO DE ESTADO (CORRIGIDA)
void EvaluateAndUpdateBlockState(int state)
{
    if(state < 0 || state >= NUM_STATES) return;
    
    static datetime lastBlockCheck = 0;
    if(TimeCurrent() - lastBlockCheck < 300)
        return;
    
    lastBlockCheck = TimeCurrent();
    
    bool shouldBeBlocked = ShouldBlockState(state);
    bool currentlyBlocked = g_stateBlocked[state];
    
    if(shouldBeBlocked && !currentlyBlocked)
    {
        BlockState(state);
    }
    else if(!shouldBeBlocked && currentlyBlocked)
    {
        if(ShouldUnblockState(state))
        {
            UnblockState(state);
        }
    }
}

// ‚úÖ‚úÖ‚úÖ 7Ô∏è‚É£ FUN√á√ÉO PARA AVALIAR TODOS OS ESTADOS ATIVOS (CORRIGIDA)
void EvaluateAllActiveStates()
{
    static datetime lastFullEvaluation = 0;
    
    if(TimeCurrent() - lastFullEvaluation < 300)
        return;
    
    lastFullEvaluation = TimeCurrent();
    
    int blocked = 0;
    int unblocked = 0;
    
    for(int i = 0; i < g_activeStatesCount; i++)
    {
        int state = g_activeStates[i];
        
        bool shouldBeBlocked = ShouldBlockState(state);
        bool currentlyBlocked = g_stateBlocked[state];
        
        if(shouldBeBlocked && !currentlyBlocked)
        {
            BlockState(state);
            blocked++;
        }
        else if(!shouldBeBlocked && currentlyBlocked)
        {
            if(ShouldUnblockState(state))
            {
                UnblockState(state);
                unblocked++;
            }
        }
    }
    
    if(blocked > 0 || unblocked > 0)
    {
      Print("üìä Avalia√ß√£o de estados (c/ cooldown): ", blocked, " bloqueados, ", unblocked, " desbloqueados");
      Print("üìä Total estados bloqueados: ", CountBlockedStates());
    }
}

// ‚úÖ‚úÖ‚úÖ 8Ô∏è‚É£ FUN√á√ÉO PARA DESBLOQUEAR ESTADOS BONS AUTOMATICAMENTE (CORRIGIDA)
void AutoUnblockGoodStates()
{
    int unblocked = 0;
    
    for(int state = 0; state < NUM_STATES; state++)
    {
        if(g_stateBlocked[state] && ShouldUnblockState(state))
        {
            UnblockState(state);
            unblocked++;
        }
    }
    
    if(unblocked > 0)
    {
        Print("üîÑ ", unblocked, " estados desbloqueados automaticamente (win rate > ", 
              DoubleToString(UnblockWinRateThreshold*100, 0), "%)");
    }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ïES AUXILIARES CORRIGIDAS
// ======================================================================

double CalculateWinRate(int state)
{
    if(state < 0 || state >= NUM_STATES) return 0.0;
    if(g_stateVisits[state] == 0) return 0.0;
    
    return SafeDivide((double)g_stateWins[state], (double)g_stateVisits[state], 0.0);
}

int CountBlockedStates()
{
   int count = 0;
   for(int i = 0; i < NUM_STATES; i++)
   {
      if(g_stateBlocked[i]) count++;
   }
   return count;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ïES DE MEM√ìRIA PERSISTENTE (CORRIGIDAS)
// ======================================================================

void SaveState()
{
   int handle = FileOpen(STATE_FILE, FILE_WRITE | FILE_BIN | FILE_COMMON);
   if(handle == INVALID_HANDLE) 
   {
      Print("‚ùå Erro ao abrir arquivo para salvar estados: ", STATE_FILE);
      return;
   }

   // üîß REGRA 1 ‚Äî Sempre converter explicitamente
   FileWriteArray(handle, g_stateVisits);
   FileWriteArray(handle, g_stateLosses);
   FileWriteArray(handle, g_stateWins);
   FileWriteArray(handle, g_stateLastUpdate);
   FileWriteArray(handle, g_activeStates);
   FileWriteArray(handle, g_stateBlocked);
   FileWriteArray(handle, g_stateLastBlockTime);
   FileWriteArray(handle, g_stateLastUnblockTime);
   FileWriteInteger(handle, (int)g_activeStatesCount);
   FileWriteArray(handle, g_stateWinRate);
   FileWriteArray(handle, g_stateAvgProfit);
   FileWriteInteger(handle, (int)g_stateResets);
   FileWriteInteger(handle, (int)g_stateDecays);
   FileWriteInteger(handle, (int)g_lastDecayTradeCount);
   FileWriteInteger(handle, (int)g_totalDecayCycles);
   FileWriteInteger(handle, (int)g_totalBadStateResets);
   
   FileClose(handle);
   
   static datetime lastSave = 0;
   datetime now = TimeCurrent();
   if(now - lastSave > 60)
   {
      Print("üíæ Estados salvos em mem√≥ria persistente");
      lastSave = now;
   }
}

void LoadState()
{
   if(!FileIsExist(STATE_FILE, FILE_COMMON))
   {
      Print("‚ö†Ô∏è Arquivo de estados n√£o encontrado. Criando novo.");
      return;
   }
   
   int handle = FileOpen(STATE_FILE, FILE_READ | FILE_BIN | FILE_COMMON);
   if(handle == INVALID_HANDLE) 
   {
      Print("‚ùå Erro ao abrir arquivo para carregar estados: ", STATE_FILE);
      return;
   }

   FileReadArray(handle, g_stateVisits);
   FileReadArray(handle, g_stateLosses);
   FileReadArray(handle, g_stateWins);
   FileReadArray(handle, g_stateLastUpdate);
   FileReadArray(handle, g_activeStates);
   FileReadArray(handle, g_stateBlocked);
   FileReadArray(handle, g_stateLastBlockTime);
   FileReadArray(handle, g_stateLastUnblockTime);
   
   // üîß REGRA 3 ‚Äî Converter para int se necess√°rio
   int tempActiveStatesCount = FileReadInteger(handle);
   g_activeStatesCount = tempActiveStatesCount;
   
   FileReadArray(handle, g_stateWinRate);
   FileReadArray(handle, g_stateAvgProfit);
   
   int tempStateResets = FileReadInteger(handle);
   int tempStateDecays = FileReadInteger(handle);
   int tempLastDecayTradeCount = FileReadInteger(handle);
   int tempTotalDecayCycles = FileReadInteger(handle);
   int tempTotalBadStateResets = FileReadInteger(handle);
   
   g_stateResets = tempStateResets;
   g_stateDecays = tempStateDecays;
   g_lastDecayTradeCount = tempLastDecayTradeCount;
   g_totalDecayCycles = tempTotalDecayCycles;
   g_totalBadStateResets = tempTotalBadStateResets;
   
   FileClose(handle);
   
   Print("‚úÖ Estados carregados da mem√≥ria persistente");
   Print("üìä Estados ativos: ", g_activeStatesCount);
   Print("üìä Total visitas REAIS: ", ArraySum(g_stateVisits));
   Print("üìä Total perdas REAIS: ", ArraySum(g_stateLosses));
   Print("üìä Total vit√≥rias REAIS: ", ArraySum(g_stateWins));
   Print("üìä Estados bloqueados: ", CountBlockedStates());
   Print("üìä Ciclos de decay: ", g_totalDecayCycles);
   Print("üìä Estados resetados: ", g_totalBadStateResets);
}

int ArraySum(const int &array[])
{
   int sum = 0;
   for(int i = 0; i < ArraySize(array); i++)
      sum += array[i];
   return sum;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ïES DO SISTEMA DE MEM√ìRIA OTIMIZADA (NOVO)
// ======================================================================

double CompressQValue(double value)
{
   if(!CompressQValues || QValuePrecision >= 4) return value;
   return NormalizeDouble(value, (int)QValuePrecision);
}

void AddActiveState(int state)
{
   if(state < 0 || state >= NUM_STATES) return;
   
   for(int i = 0; i < g_activeStatesCount; i++)
   {
      if(g_activeStates[i] == state) return;
   }
   
   if(g_activeStatesCount < MaxMemoryStates)
   {
      g_activeStates[g_activeStatesCount] = state;
      g_activeStatesCount++;
   }
   else
   {
      int oldestIndex = 0;
      int oldestTime = INT_MAX;
      
      for(int i = 0; i < g_activeStatesCount; i++)
      {
         int stateIdx = g_activeStates[i];
         if(g_stateLastUpdate[stateIdx] < oldestTime)
         {
            oldestTime = g_stateLastUpdate[stateIdx];
            oldestIndex = i;
         }
      }
      
      g_activeStates[oldestIndex] = state;
   }
   
   g_stateLastUpdate[state] = g_totalTrades;
   
   if(EnableUnifiedBlockingSystem)
   {
      EvaluateAndUpdateBlockState(state);
   }
}

void CleanMemory()
{
   if(!AutoCleanMemory) return;
   
   g_memoryCleanCounter++;
   if(g_memoryCleanCounter < CleanMemoryAfterTrades) return;
   
   g_memoryCleanCounter = 0;
   
   Print("üßπ LIMPANDO MEM√ìRIA...");
   
   int cleaned = 0;
   int kept = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         if(g_stateVisits[state] < 3 && 
            (g_totalTrades - g_stateLastUpdate[state]) > 100)
         {
            g_stateVisits[state] = 0;
            g_stateLosses[state] = 0;
            g_stateWins[state] = 0;
            g_stateLastUpdate[state] = 0;
            g_stateLastBlockTime[state] = 0;
            g_stateLastUnblockTime[state] = 0;
            
            for(int a = 0; a < NUM_ACTIONS; a++)
            {
               g_Q[state * NUM_ACTIONS + a] = 0.0;
            }
            
            g_stateBlocked[state] = false;
            
            cleaned++;
         }
         else
         {
            kept++;
         }
      }
   }
   
   g_activeStatesCount = 0;
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         if(g_activeStatesCount < MaxMemoryStates)
         {
            g_activeStates[g_activeStatesCount] = state;
            g_activeStatesCount++;
         }
      }
   }
   
   Print("‚úÖ Mem√≥ria limpa: ", cleaned, " estados removidos, ", kept, " mantidos");
   Print("   Estados ativos na mem√≥ria: ", g_activeStatesCount);
   
   SaveState();
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ SISTEMA DE BACKUP AUTOM√ÅTICO (CORRIGIDO)
// ======================================================================

string GetBackupFileName(int backupNum)
{
   return "Phoenix_Files/Backups/Cerebro_" + _Symbol + "_" + 
          EnumToString((ENUM_TIMEFRAMES)_Period) + "_backup_" + 
          IntegerToString(backupNum) + ".bin";
}

void ManageBackupFiles()
{
   if(!CreateBackupFiles || !g_memoryInitialized) return;
   
   string backupFile = GetBackupFileName(0);
   if(SaveBrainToFile(backupFile))
   {
      Print("‚úÖ Backup criado: ", backupFile);
   }
   
   for(int i = MaxBackupFiles - 1; i > 0; i--)
   {
      string oldFile = GetBackupFileName(i);
      string newFile = GetBackupFileName(i + 1);
      
      if(FileIsExist(oldFile, FILE_COMMON))
      {
         if(FileIsExist(newFile, FILE_COMMON))
         {
            FileDelete(newFile, FILE_COMMON);
         }
         FileMove(oldFile, 0, newFile, 0);
      }
   }
}

bool SaveBrainToFile(string filename)
{
   if(!CreateDirectoryForFile(filename)) return false;

   int h = FileOpen(filename, FILE_WRITE|FILE_BIN|FILE_COMMON);
   if(h == INVALID_HANDLE) return false;

   // üîß REGRA 1 ‚Äî Sempre converter explicitamente
   FileWriteInteger(h, (int)FILE_MAGIC);
   FileWriteInteger(h, (int)FILE_VERSION);
   FileWriteInteger(h, (int)g_activeStatesCount);
   
   for(int i = 0; i < g_activeStatesCount; i++)
   {
      int state = g_activeStates[i];
      
      FileWriteInteger(h, (int)state);
      FileWriteInteger(h, (int)g_stateVisits[state]);
      FileWriteInteger(h, (int)g_stateLosses[state]);
      FileWriteInteger(h, (int)g_stateWins[state]);
      FileWriteInteger(h, (int)g_stateLastUpdate[state]);
      FileWriteInteger(h, (int)g_stateBlocked[state]);
      FileWriteLong(h, (long)g_stateLastBlockTime[state]);
      FileWriteLong(h, (long)g_stateLastUnblockTime[state]);
      
      for(int a = 0; a < NUM_ACTIONS; a++)
      {
         double qValue = CompressQValue(g_Q[state * NUM_ACTIONS + a]);
         FileWriteDouble(h, qValue);
      }
   }
   
   FileWriteDouble(h, g_currentExplorationRate);
   FileWriteInteger(h, (int)g_tradesToday);
   FileWriteInteger(h, (int)g_consecutiveLosses);
   FileWriteInteger(h, (int)g_totalTrades);
   FileWriteInteger(h, (int)g_totalWins);
   FileWriteInteger(h, (int)g_totalLosses);
   FileWriteDouble(h, g_sumProfit);
   FileWriteDouble(h, g_volumeMultiplier);
   FileWriteInteger(h, (int)g_totalStatesDiscovered);
   FileWriteInteger(h, (int)g_totalQUpdates);
   FileWriteDouble(h, g_averageQValue);
   FileWriteDouble(h, g_maxQValue);
   FileWriteDouble(h, g_minQValue);
   
   int arraySize = (int)ArraySize(g_recentProfits);
   FileWriteInteger(h, (int)arraySize);
   FileWriteArray(h, g_recentProfits);
   FileWriteInteger(h, (int)g_recentProfitsIndex);
   
   long firstTradeDate = (long)g_firstTradeDate;
   FileWriteLong(h, (long)firstTradeDate);
   FileWriteDouble(h, g_highestProfit);
   FileWriteDouble(h, g_lowestProfit);
   FileWriteInteger(h, (int)g_bestWinStreak);
   FileWriteInteger(h, (int)g_worstLossStreak);
   FileWriteInteger(h, (int)g_currentWinStreak);
   FileWriteInteger(h, (int)g_currentLossStreak);
   
   FileWriteInteger(h, (int)g_totalBuys);
   FileWriteInteger(h, (int)g_totalSells);
   FileWriteInteger(h, (int)g_buyWins);
   FileWriteInteger(h, (int)g_sellWins);
   FileWriteDouble(h, g_buyProfit);
   FileWriteDouble(h, g_sellProfit);
   
   FileWriteArray(h, g_stateWinRate);
   FileWriteArray(h, g_stateAvgProfit);
   FileWriteInteger(h, (int)g_stateResets);
   FileWriteInteger(h, (int)g_stateDecays);
   FileWriteInteger(h, (int)g_lastDecayTradeCount);
   FileWriteInteger(h, (int)g_totalDecayCycles);
   FileWriteInteger(h, (int)g_totalBadStateResets);

   FileClose(h);
   return true;
}

bool LoadBrainFromFile(string filename)
{
   if(!FileIsExist(filename, FILE_COMMON)) return false;

   int h = FileOpen(filename, FILE_READ|FILE_BIN|FILE_COMMON);
   if(h == INVALID_HANDLE) return false;

   int magic = FileReadInteger(h);
   int version = FileReadInteger(h);
   
   if(magic != FILE_MAGIC || version != FILE_VERSION)
   {
      FileClose(h);
      return false;
   }
   
   ArrayResize(g_stateVisits, NUM_STATES);
   ArrayInitialize(g_stateVisits, 0);
   
   ArrayResize(g_stateLosses, NUM_STATES);
   ArrayInitialize(g_stateLosses, 0);
   
   ArrayResize(g_stateWins, NUM_STATES);
   ArrayInitialize(g_stateWins, 0);
   
   ArrayResize(g_stateLastUpdate, NUM_STATES);
   ArrayInitialize(g_stateLastUpdate, 0);
   
   ArrayResize(g_stateBlocked, NUM_STATES);
   ArrayInitialize(g_stateBlocked, false);
   
   ArrayResize(g_stateLastBlockTime, NUM_STATES);
   ArrayInitialize(g_stateLastBlockTime, 0);
   
   ArrayResize(g_stateLastUnblockTime, NUM_STATES);
   ArrayInitialize(g_stateLastUnblockTime, 0);
   
   for(int i = 0; i < NUM_STATES * NUM_ACTIONS; i++)
   {
      g_Q[i] = 0.0;
   }
   
   // üîß REGRA 3 ‚Äî Converter para int se necess√°rio
   int tempActiveStatesCount = FileReadInteger(h);
   g_activeStatesCount = tempActiveStatesCount;
   
   for(int i = 0; i < g_activeStatesCount; i++)
   {
      int state = FileReadInteger(h);
      
      if(state >= 0 && state < NUM_STATES)
      {
         g_activeStates[i] = state;
         g_stateVisits[state] = FileReadInteger(h);
         g_stateLosses[state] = FileReadInteger(h);
         g_stateWins[state] = FileReadInteger(h);
         g_stateLastUpdate[state] = FileReadInteger(h);
         g_stateBlocked[state] = (bool)FileReadInteger(h);
         g_stateLastBlockTime[state] = (datetime)FileReadLong(h);
         g_stateLastUnblockTime[state] = (datetime)FileReadLong(h);
         
         for(int a = 0; a < NUM_ACTIONS; a++)
         {
            double qValue = FileReadDouble(h);
            g_Q[state * NUM_ACTIONS + a] = qValue;
         }
      }
   }
   
   g_currentExplorationRate = FileReadDouble(h);
   g_tradesToday = FileReadInteger(h);
   g_consecutiveLosses = FileReadInteger(h);
   g_totalTrades = FileReadInteger(h);
   g_totalWins = FileReadInteger(h);
   g_totalLosses = FileReadInteger(h);
   g_sumProfit = FileReadDouble(h);
   g_volumeMultiplier = FileReadDouble(h);
   g_totalStatesDiscovered = FileReadInteger(h);
   g_totalQUpdates = FileReadInteger(h);
   g_averageQValue = FileReadDouble(h);
   g_maxQValue = FileReadDouble(h);
   g_minQValue = FileReadDouble(h);
   
   int arraySize = FileReadInteger(h);
   ArrayResize(g_recentProfits, arraySize);
   FileReadArray(h, g_recentProfits, 0, arraySize);
   g_recentProfitsIndex = FileReadInteger(h);
   
   long firstTradeDate = FileReadLong(h);
   g_firstTradeDate = (datetime)firstTradeDate;
   g_highestProfit = FileReadDouble(h);
   g_lowestProfit = FileReadDouble(h);
   g_bestWinStreak = FileReadInteger(h);
   g_worstLossStreak = FileReadInteger(h);
   g_currentWinStreak = FileReadInteger(h);
   g_currentLossStreak = FileReadInteger(h);
   
   g_totalBuys = FileReadInteger(h);
   g_totalSells = FileReadInteger(h);
   g_buyWins = FileReadInteger(h);
   g_sellWins = FileReadInteger(h);
   g_buyProfit = FileReadDouble(h);
   g_sellProfit = FileReadDouble(h);
   
   ArrayResize(g_stateWinRate, NUM_STATES);
   FileReadArray(h, g_stateWinRate, 0, NUM_STATES);
   
   ArrayResize(g_stateAvgProfit, NUM_STATES);
   FileReadArray(h, g_stateAvgProfit, 0, NUM_STATES);
   
   g_stateResets = FileReadInteger(h);
   g_stateDecays = FileReadInteger(h);
   g_lastDecayTradeCount = FileReadInteger(h);
   g_totalDecayCycles = FileReadInteger(h);
   g_totalBadStateResets = FileReadInteger(h);
   
   FileClose(h);
   
   Print("‚úÖ Mem√≥ria carregada: ", g_activeStatesCount, " estados ativos");
   Print("üìä Estados bloqueados carregados: ", CountBlockedStates());
   Print("üìä Ciclos de decay: ", g_totalDecayCycles);
   Print("üìä Estados resetados: ", g_totalBadStateResets);
   return true;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ïES DE MEM√ìRIA PRINCIPAIS (OTIMIZADAS)
// ======================================================================

string BrainKey()
{
   return StringFormat("B%dx%dx%dx%dx%dx%dx%d_A%d",
      BINS_MA_DIST,BINS_RSI,BINS_ADX,BINS_BBPOS,BINS_VOLATILITY,BINS_VOLUME,BINS_TIME,NUM_ACTIONS);
}

string GetBrainFileName()
{
   if(g_memoryFileName == "")
   {
      g_memoryFileName = "Phoenix_Files/Cerebro_" + _Symbol + "_" + 
                         EnumToString((ENUM_TIMEFRAMES)_Period) + "_FIXED_CORRIGIDO.bin";
   }
   return g_memoryFileName;
}

bool CreateDirectoryForFile(string p)
{
   string parts[];
   string cur = "";
   int n = StringSplit(p, '/', parts);
   if(n > 1)
   {
      for(int i = 0; i < n - 1; i++)
      {
         cur += parts[i] + "/";
         if(!FileIsExist(cur, FILE_COMMON))
         {
            if(!FolderCreate(cur, FILE_COMMON)) 
            {
               Print("‚ùå Erro ao criar diret√≥rio: ", cur);
               return false;
            }
         }
      }
   }
   return true;
}

bool SaveBrain()
{
   if(!g_memoryInitialized) 
   {
      Print("‚ö†Ô∏è Mem√≥ria n√£o inicializada, pulando save");
      return false;
   }

   if(UseIncrementalSave && !g_memoryDirty)
   {
      if(g_memorySaveCounter < 10)
      {
         g_memorySaveCounter++;
         return true;
      }
   }
   
   string f = GetBrainFileName();
   if(!CreateDirectoryForFile(f)) 
   {
      Print("‚ùå Erro ao criar diret√≥rio para: ", f);
      return false;
   }

   if(!SaveBrainToFile(f))
   {
      Print("‚ùå Falha ao salvar mem√≥ria");
      return false;
   }
   
   g_lastSaveTime = TimeCurrent();
   g_lastSaveSuccess = true;
   g_qUpdatesSinceSave = 0;
   g_memoryDirty = false;
   g_memorySaveCounter = 0;
   
   if(CreateBackupFiles)
   {
      ManageBackupFiles();
   }
   
   if(EnableTextExport)
   {
      ExportMemoryToTextFileFunc(true);
   }
   
   SaveState();
   
   Print("üíæ Mem√≥ria salva (estados ativos: ", g_activeStatesCount, ")");
   return true;
}

bool LoadBrain()
{
   string fn = GetBrainFileName();
   
   if(!FileIsExist(fn, FILE_COMMON))
   {
      Print("‚ö†Ô∏è Arquivo principal n√£o encontrado, procurando backup...");
      
      for(int i = 0; i <= MaxBackupFiles; i++)
      {
         string backupFile = GetBackupFileName(i);
         if(FileIsExist(backupFile, FILE_COMMON))
         {
            Print("üîÑ Carregando backup: ", backupFile);
            return LoadBrainFromFile(backupFile);
         }
      }
      
      Print("‚ùå Nenhum backup encontrado, criando nova mem√≥ria");
      return false;
   }
   
   return LoadBrainFromFile(fn);
}

void ResetQTable()
{
   int sz = NUM_STATES * NUM_ACTIONS;
   
   ArrayResize(g_Q, sz);
   ArrayInitialize(g_Q, 0.0);
   
   ArrayResize(g_stateVisits, NUM_STATES);
   ArrayInitialize(g_stateVisits, 0);
   
   ArrayResize(g_stateLosses, NUM_STATES);
   ArrayInitialize(g_stateLosses, 0);
   
   ArrayResize(g_stateWins, NUM_STATES);
   ArrayInitialize(g_stateWins, 0);
   
   ArrayResize(g_stateLastUpdate, NUM_STATES);
   ArrayInitialize(g_stateLastUpdate, 0);
   
   ArrayResize(g_stateBlocked, NUM_STATES);
   for(int i = 0; i < NUM_STATES; i++)
       g_stateBlocked[i] = false;
   
   ArrayResize(g_stateLastBlockTime, NUM_STATES);
   ArrayInitialize(g_stateLastBlockTime, 0);
   
   ArrayResize(g_stateLastUnblockTime, NUM_STATES);
   ArrayInitialize(g_stateLastUnblockTime, 0);
   
   ArrayResize(g_activeStates, MaxMemoryStates);
   g_activeStatesCount = 0;
   
   g_learningInitialized = true;
   g_totalTrades = g_totalWins = g_totalLosses = 0;
   g_sumProfit = 0.0;
   
   g_totalStatesDiscovered = 0;
   g_totalQUpdates = 0;
   g_averageQValue = 0.0;
   g_maxQValue = 0.0;
   g_minQValue = 0.0;
   
   ArrayResize(g_recentProfits, 100);
   ArrayInitialize(g_recentProfits, 0.0);
   g_recentProfitsIndex = 0;
   
   g_firstTradeDate = 0;
   g_highestProfit = 0.0;
   g_lowestProfit = 0.0;
   g_bestWinStreak = 0;
   g_worstLossStreak = 0;
   g_currentWinStreak = 0;
   g_currentLossStreak = 0;
   
   g_totalBuys = 0;
   g_totalSells = 0;
   g_buyWins = 0;
   g_sellWins = 0;
   g_buyProfit = 0.0;
   g_sellProfit = 0.0;
   
   g_totalDecayCycles = 0;
   g_totalBadStateResets = 0;
   
   InitializeLearningSystem();
   
   Print("üÜï Nova mem√≥ria criada (Sistema Corrigido v307F com Decay e Reset)");
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ïES AUXILIARES PARA TRAILING STOP
// ======================================================================

void AddPositionToTrailingSystem(ulong ticket)
{
   Sleep(100);
   
   if(!PositionSelectByTicket(ticket)) return;
   
   int index = -1;
   for(int i = 0; i < g_trailingCount; i++)
   {
      if(g_trailingTickets[i] == ticket)
      {
         index = i;
         break;
      }
   }
   
   if(index == -1)
   {
      index = g_trailingCount;
      g_trailingCount++;
      
      ArrayResize(g_trailingTickets, g_trailingCount);
      ArrayResize(g_trailingBestPrices, g_trailingCount);
      ArrayResize(g_trailingCurrentSL, g_trailingCount);
      ArrayResize(g_trailingCurrentTP, g_trailingCount);
      ArrayResize(g_trailingLastTrailTimes, g_trailingCount);
      ArrayResize(g_trailingBreakevenActivated, g_trailingCount);
   }
   
   g_trailingTickets[index] = ticket;
   g_trailingBestPrices[index] = PositionGetDouble(POSITION_PRICE_OPEN);
   g_trailingCurrentSL[index] = PositionGetDouble(POSITION_SL);
   g_trailingCurrentTP[index] = PositionGetDouble(POSITION_TP);
   g_trailingLastTrailTimes[index] = 0;
   g_trailingBreakevenActivated[index] = false;
   
   Print("üìä Posi√ß√£o #", ticket, " adicionada ao sistema de trailing stop");
}

void RemovePositionFromTrailingSystem(ulong ticket)
{
   for(int i = 0; i < g_trailingCount; i++)
   {
      if(g_trailingTickets[i] == ticket)
      {
         for(int j = i; j < g_trailingCount - 1; j++)
         {
            g_trailingTickets[j] = g_trailingTickets[j + 1];
            g_trailingBestPrices[j] = g_trailingBestPrices[j + 1];
            g_trailingCurrentSL[j] = g_trailingCurrentSL[j + 1];
            g_trailingCurrentTP[j] = g_trailingCurrentTP[j + 1];
            g_trailingLastTrailTimes[j] = g_trailingLastTrailTimes[j + 1];
            g_trailingBreakevenActivated[j] = g_trailingBreakevenActivated[j + 1];
         }
         g_trailingCount--;
         Print("üìä Posi√ß√£o #", ticket, " removida do sistema de trailing stop");
         break;
      }
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ MONITORAMENTO INTELIGENTE DE ESTADOS (CORRIGIDO)
// ======================================================================
void MonitorBadStates()
{
   static datetime lastMonitorTime = 0;
   datetime currentTime = TimeCurrent();
   
   if(currentTime - lastMonitorTime < 300 && g_totalTrades % 15 != 0) 
      return;
   
   lastMonitorTime = currentTime;
   
   Print("üîç MONITORAMENTO SUPER AGRESSIVO DE ESTADOS RUINS");
   
   int bloqueados = 0;
   int resetados = 0;
   int estadosAnalisados = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         estadosAnalisados++;
         double winRate = CalculateWinRate(state);
         
         // ‚úÖ CORRE√á√ÉO: REGRAS MAIS AGRESSIVAS
         
         // 1. BLOQUEAR estados com win rate < 25% e mais de 3 visitas
         if(g_stateVisits[state] >= 3 && winRate < 0.25 && !g_stateBlocked[state])
         {
            g_stateBlocked[state] = true;
            bloqueados++;
            Print("‚õî BLOQUEIO Estado ", state, 
                  " | Win Rate: ", DoubleToString(winRate*100,1), "%",
                  " | Visitas: ", g_stateVisits[state]);
         }
         
         // 2. RESETAR estados catastr√≥ficos (win rate < 15%)
         if(g_stateVisits[state] >= 5 && winRate < 0.15)
         {
            Print("üî• RESET Estado ", state, 
                  " | Win Rate catastr√≥fica: ", DoubleToString(winRate*100,1), "%",
                  " | Visitas: ", g_stateVisits[state]);
            
            g_stateVisits[state] = 0;
            g_stateWins[state] = 0;
            g_stateLosses[state] = 0;
            g_stateBlocked[state] = false;
            g_stateLastUpdate[state] = 0;
            
            for(int a = 0; a < NUM_ACTIONS; a++)
            {
               g_Q[state * NUM_ACTIONS + a] = 0.0;
            }
            
            resetados++;
            g_totalBadStateResets++; // ‚úÖ INCREMENTAR CONTADOR
         }
         
         // 3. DESBLOQUEAR estados bons
         if(g_stateBlocked[state] && winRate > 0.55 && g_stateVisits[state] >= 5)
         {
            g_stateBlocked[state] = false;
            Print("‚úÖ DESBLOQUEIO Estado ", state,
                  " | Win Rate boa: ", DoubleToString(winRate*100,1), "%");
         }
      }
   }
   
   Print("üìä RESUMO MONITORAMENTO:");
   Print("   Estados analisados: ", estadosAnalisados);
   Print("   Estados bloqueados: ", CountBlockedStates(), " (+", bloqueados, " novos)");
   Print("   Estados resetados: ", resetados);
   Print("   Total resets acumulados: ", g_totalBadStateResets);
   
   // ‚úÖ FOR√áAR SAVE ap√≥s monitoramento cr√≠tico
   if(bloqueados > 0 || resetados > 0)
   {
      SaveState();
      g_memoryDirty = true;
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO: DEBUG DE ESTADOS BLOQUEADOS (ATUALIZADA)
// ======================================================================
void DebugBlockedStates()
{
   static datetime lastDebugTime = 0;
   datetime currentTime = TimeCurrent();
   
   if(currentTime - lastDebugTime < 300) return;
   lastDebugTime = currentTime;
   
   int blockedCount = 0;
   int totalVisited = 0;
   int wronglyBlocked = 0;
   int correctlyBlocked = 0;
   
   Print("=== DEBUG: ESTADOS BLOQUEADOS (SISTEMA CORRIGIDO) ===");
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         totalVisited++;
         
         double winRate = CalculateWinRate(state);
         double lossRate = 1.0 - winRate;
         
         if(g_stateBlocked[state])
         {
            blockedCount++;
            
            if(winRate >= UnblockWinRateThreshold && g_stateVisits[state] >= MinVisitsForBlockDecision)
            {
               wronglyBlocked++;
               PrintFormat("‚ùå‚ùå‚ùå ERRO GRAVE: Estado %d BLOQUEADO mas tem WIN RATE ALTA: %.1f%% | Visitas: %d", 
                     state, winRate*100, g_stateVisits[state]);
               
               if(EnableUnifiedBlockingSystem)
               {
                  UnblockState(state);
               }
            }
            else if(lossRate >= BlockLossRateThreshold && g_stateVisits[state] >= MinVisitsForBlockDecision)
            {
               correctlyBlocked++;
               PrintFormat("‚õî Estado %d BLOQUEADO CORRETAMENTE: %.1f%% win | Visitas: %d", 
                     state, winRate*100, g_stateVisits[state]);
            }
            else
            {
               PrintFormat("‚ö†Ô∏è Estado %d bloqueado sem dados suficientes: %.1f%% win | Visitas: %d", 
                     state, winRate*100, g_stateVisits[state]);
            }
         }
      }
   }
   
   Print(StringFormat("=== RESUMO: %d visitados | %d bloqueados | %d bloqueados erroneamente | %d bloqueados corretamente ===", 
         totalVisited, blockedCount, wronglyBlocked, correctlyBlocked));
   
   if(wronglyBlocked > 0 && EnableUnifiedBlockingSystem)
   {
      Print("üî•üî•üî• CORRIGINDO ", wronglyBlocked, " ESTADOS BLOQUEADOS ERRONEAMENTE...");
      AutoUnblockGoodStates();
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO: DEBUG DE CONTAGEM DE TRADES (VERS√ÉO MELHORADA)
// ======================================================================
void DebugTradeCounting()
{
   Print("=== DEBUG CONTAGEM DE TRADES (V2) ===");
   Print("Total Trades: ", g_totalTrades);
   Print("Total Wins: ", g_totalWins);
   Print("Total Losses: ", g_totalLosses);
   Print("Soma Wins+Losses: ", g_totalWins + g_totalLosses);
   Print("Diferen√ßa (NOPs): ", g_totalTrades - (g_totalWins + g_totalLosses));
   Print("Win Rate: ", g_totalTrades > 0 ? DoubleToString((double)g_totalWins/g_totalTrades*100, 1) : "0.0", "%");
   
   int estadosComProblema = 0;
   int totalVisitas = 0;
   int totalVit√≥rias = 0;
   int totalPerdas = 0;
   
   for(int s = 0; s < NUM_STATES; s++)
   {
      if(g_stateVisits[s] > 0)
      {
         totalVisitas += g_stateVisits[s];
         totalVit√≥rias += g_stateWins[s];
         totalPerdas += g_stateLosses[s];
         
         if(g_stateWins[s] == 0 && g_stateLosses[s] == 0 && g_stateVisits[s] >= 3)
         {
            estadosComProblema++;
            Print("‚ö†Ô∏è PROBLEMA: Estado ", s, " tem ", g_stateVisits[s], 
                  " visitas mas 0 vit√≥rias e 0 perdas!");
            
            // ‚ö†Ô∏è CORRE√á√ÉO AUTOM√ÅTICA: Resetar estado problem√°tico
            if(g_stateVisits[s] >= 5)
            {
               Print("üîÑ Resetando estado problem√°tico ", s);
               g_stateVisits[s] = 0;
               g_stateWins[s] = 0;
               g_stateLosses[s] = 0;
               g_stateBlocked[s] = false;
               
               for(int a = 0; a < NUM_ACTIONS; a++)
               {
                  g_Q[s * NUM_ACTIONS + a] = 0.0;
               }
            }
         }
         
         // Verificar estados que deveriam estar bloqueados
         if(g_stateVisits[s] >= MinVisitsForBlockDecision)
         {
            double lossRate = SafeDivide((double)g_stateLosses[s], (double)g_stateVisits[s], 0.0);
            if(lossRate >= BlockLossRateThreshold && !g_stateBlocked[s])
            {
               Print("‚ö†Ô∏è Estado ", s, " deveria estar bloqueado! Loss rate: ", 
                     DoubleToString(lossRate*100, 1), "%");
            }
         }
      }
   }
   
   Print("=== RESUMO DOS ESTADOS ===");
   Print("Estados ativos: ", g_activeStatesCount);
   Print("Estados com problema: ", estadosComProblema);
   Print("Total visitas em todos estados: ", totalVisitas);
   Print("Total vit√≥rias em todos estados: ", totalVit√≥rias);
   Print("Total perdas em todos estados: ", totalPerdas);
   Print("Taxa de vit√≥ria global estados: ", totalVisitas > 0 ? 
         DoubleToString((double)totalVit√≥rias/totalVisitas*100, 1) : "0.0", "%");
   
   if(estadosComProblema > 0)
   {
      Print("üî•üî•üî• ENCONTRADOS ", estadosComProblema, " ESTADOS PROBLEM√ÅTICOS!");
      Print("üî• RECOMENDA√á√ÉO: Executar EmergencyReset()");
   }
   
   Print("=== FIM DEBUG ===");
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO: RESET DE EMERG√äNCIA (ADICIONADA)
// ======================================================================
void EmergencyReset()
{
   Print("üî•üî•üî• RESET DE EMERG√äNCIA ATIVADO!");
   
   // Resetar todas as estat√≠sticas
   g_totalTrades = 0;
   g_totalWins = 0;
   g_totalLosses = 0;
   g_sumProfit = 0.0;
   
   // Resetar Q-table
   for(int i = 0; i < NUM_STATES * NUM_ACTIONS; i++)
   {
      g_Q[i] = 0.0;
   }
   
   // Resetar contadores de estado
   for(int s = 0; s < NUM_STATES; s++)
   {
      g_stateVisits[s] = 0;
      g_stateLosses[s] = 0;
      g_stateWins[s] = 0;
      g_stateBlocked[s] = false;
      g_stateLastBlockTime[s] = 0;
      g_stateLastUnblockTime[s] = 0;
      g_stateLastUpdate[s] = 0;
   }
   
   g_activeStatesCount = 0;
   g_currentExplorationRate = InitialExplorationRate;
   g_tradesToday = 0;
   g_consecutiveLosses = 0;
   g_totalDecayCycles = 0;
   g_totalBadStateResets = 0;
   
   // Resetar arrays
   ArrayInitialize(g_recentProfits, 0.0);
   g_recentProfitsIndex = 0;
   
   SaveBrain();
   SaveState();
   
   Print("‚úÖ Sistema resetado completamente!");
   Print("üîÑ Reinicie o rob√¥ para come√ßar do zero com contadores corretos.");
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO: DEBUG DE ESTADOS TRAVADOS (NOVA)
// ======================================================================
void DebugStuckStates()
{
   Print("=== DEBUG ESTADOS TRAVADOS ===");
   
   int stuckStates = 0;
   int totalStatesWithVisits = 0;
   int maxVisits = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         totalStatesWithVisits++;
         
         if(g_stateVisits[state] > maxVisits)
            maxVisits = g_stateVisits[state];
            
         // Verificar se est√° "travado" em m√∫ltiplos de 10
         if(g_stateVisits[state] % 10 == 0 && g_stateVisits[state] > 0)
         {
            stuckStates++;
            double winRate = CalculateWinRate(state);
            
            Print("‚ö†Ô∏è Estado ", state, " com ", g_stateVisits[state], " visitas",
                  " | Wins: ", g_stateWins[state],
                  " | Losses: ", g_stateLosses[state],
                  " | Win Rate: ", DoubleToString(winRate*100,1), "%",
                  " | Bloqueado: ", g_stateBlocked[state] ? "SIM" : "N√ÉO",
                  " | √öltima atualiza√ß√£o: ", g_totalTrades - g_stateLastUpdate[state], " trades atr√°s");
         }
      }
   }
   
   Print("üìä ESTAT√çSTICAS:");
   Print("   Total estados com visitas: ", totalStatesWithVisits);
   Print("   M√°ximo de visitas em um estado: ", maxVisits);
   Print("   Estados travados (m√∫ltiplos de 10): ", stuckStates);
   Print("   Estados com 10+ visitas: ", CountStatesWithMinVisits(10));
   Print("   Estados com 20+ visitas: ", CountStatesWithMinVisits(20));
   Print("   Total BadStateResets: ", g_totalBadStateResets);
   Print("=== FIM DEBUG ===");
}

int CountStatesWithMinVisits(int minVisits)
{
   int count = 0;
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] >= minVisits)
         count++;
   }
   return count;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ ‚úÖ‚úÖ‚úÖ NOVAS FUN√á√ïES ADICIONADAS
// ======================================================================

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO: CORRE√á√ÉO DE EMERG√äNCIA DOS CONTADORES
// ======================================================================
void EmergencyCounterFix()
{
   Print("üî•üî•üî• CORRE√á√ÉO DE EMERG√äNCIA DOS CONTADORES");
   
   int fixedStates = 0;
   int unblockedStates = 0;
   int corruptedStates = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         // ‚úÖ CORRIGIR CONTADORES INCONSISTENTES
         if(g_stateWins[state] > g_stateVisits[state])
         {
            Print("‚ùå‚ùå‚ùå ERRO CR√çTICO: Estado ", state, 
                  " | Visitas: ", g_stateVisits[state],
                  " | Vit√≥rias: ", g_stateWins[state], " (IMPOSS√çVEL!)");
            
            // Corre√ß√£o: Recalcular baseado em win rate realista
            double estimatedWinRate = 0.3; // Assumir 30% win rate
            g_stateWins[state] = (int)(g_stateVisits[state] * estimatedWinRate);
            g_stateLosses[state] = g_stateVisits[state] - g_stateWins[state];
            
            corruptedStates++;
            fixedStates++;
         }
         
         // ‚úÖ DESBLOQUEAR ESTADOS BLOQUEADOS ERRONEAMENTE
         if(g_stateBlocked[state])
         {
            double winRate = CalculateWinRate(state);
            
            // Regras mais sensatas para desbloqueio
            if((g_stateVisits[state] < 5 && winRate > 0.1) || // Poucas visitas com alguma vit√≥ria
               (g_stateVisits[state] >= 5 && winRate >= 0.25)) // Win rate razo√°vel
            {
               g_stateBlocked[state] = false;
               unblockedStates++;
               Print("‚úÖ Estado ", state, " desbloqueado | Win rate: ", 
                     DoubleToString(winRate*100,1), "% | Visitas: ", g_stateVisits[state]);
            }
         }
         
         // ‚úÖ CORRIGIR ESTADOS COM 0 VISITAS MAS COM CONTADORES
         if(g_stateVisits[state] == 0 && (g_stateWins[state] > 0 || g_stateLosses[state] > 0))
         {
            Print("üîÑ Estado ", state, " com contadores mas 0 visitas - resetando");
            g_stateWins[state] = 0;
            g_stateLosses[state] = 0;
            g_stateBlocked[state] = false;
            fixedStates++;
         }
      }
   }
   
   // ‚úÖ CORRIGIR ESTAT√çSTICAS GLOBAIS
   int totalVisits = 0;
   int totalWins = 0;
   int totalLosses = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      totalVisits += g_stateVisits[state];
      totalWins += g_stateWins[state];
      totalLosses += g_stateLosses[state];
   }
   
   // Recalcular totais
   g_totalTrades = totalVisits; // Cada visita = 1 trade real
   g_totalWins = totalWins;
   g_totalLosses = totalLosses;
   
   Print("üìä RESUMO DA CORRE√á√ÉO:");
   Print("   Estados com dados corruptos: ", corruptedStates);
   Print("   Estados corrigidos: ", fixedStates);
   Print("   Estados desbloqueados: ", unblockedStates);
   Print("   Novos totais:");
   Print("     Total Visitas: ", totalVisits);
   Print("     Total Vit√≥rias: ", totalWins);
   Print("     Total Perdas: ", totalLosses);
   Print("     Win Rate: ", totalVisits > 0 ? 
         DoubleToString((double)totalWins/totalVisits*100, 1) : "0.0", "%");
   
   // For√ßar save
   g_memoryDirty = true;
   SaveState();
   SaveBrain();
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO: REVIS√ÉO COMPLETA DO SISTEMA DE BLOQUEIO
// ======================================================================
void OverhaulBlockingSystem()
{
   Print("üîÑ REVIS√ÉO COMPLETA DO SISTEMA DE BLOQUEIO");
   
   int blockedBefore = CountBlockedStates();
   int totalVisited = g_activeStatesCount;
   
   // ‚úÖ NOVAS REGRAS INTELIGENTES
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         double winRate = CalculateWinRate(state);
         
         // ‚úÖ REGRAS PARA BLOQUEIO (MAIS RESTRITIVAS)
         bool shouldBeBlocked = false;
         
         // 1. Muito ruim com hist√≥rico suficiente
         if(g_stateVisits[state] >= 10 && winRate < 0.20)
         {
            shouldBeBlocked = true;
         }
         // 2. Catastr√≥fico mesmo com menos visitas
         else if(g_stateVisits[state] >= 5 && winRate < 0.10)
         {
            shouldBeBlocked = true;
         }
         // 3. Nunca ganhou com visitas significativas
         else if(g_stateVisits[state] >= 8 && winRate == 0.0)
         {
            shouldBeBlocked = true;
         }
         
         // ‚úÖ REGRAS PARA DESBLOQUEIO (MAIS LENIENTES)
         bool shouldBeUnblocked = false;
         
         // 1. Performance aceit√°vel
         if(g_stateVisits[state] >= 5 && winRate >= 0.30)
         {
            shouldBeUnblocked = true;
         }
         // 2. Poucas visitas, n√£o bloquear prematuramente
         else if(g_stateVisits[state] < 5)
         {
            shouldBeUnblocked = true;
         }
         // 3. Mostrando melhoria recente
         else if(g_stateBlocked[state] && winRate >= 0.25)
         {
            shouldBeUnblocked = true;
         }
         
         // APLICAR DECIS√ÉO
         if(shouldBeBlocked && !g_stateBlocked[state])
         {
            g_stateBlocked[state] = true;
         }
         else if(shouldBeUnblocked && g_stateBlocked[state])
         {
            g_stateBlocked[state] = false;
         }
      }
   }
   
   int blockedAfter = CountBlockedStates();
   
   Print("üìä RESULTADO DA REVIS√ÉO:");
   Print("   Estados visitados: ", totalVisited);
   Print("   Bloqueados antes: ", blockedBefore, " (", 
         totalVisited > 0 ? DoubleToString((double)blockedBefore/totalVisited*100,1) : "0", "%)");
   Print("   Bloqueados depois: ", blockedAfter, " (", 
         totalVisited > 0 ? DoubleToString((double)blockedAfter/totalVisited*100,1) : "0", "%)");
   Print("   Mudan√ßa: ", blockedAfter - blockedBefore);
   
   g_memoryDirty = true;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO: RESET PARCIAL INTELIGENTE
// ======================================================================
void IntelligentPartialReset()
{
   Print("üß† RESET PARCIAL INTELIGENTE");
   
   int statesReset = 0;
   int statesRetained = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         double winRate = CalculateWinRate(state);
         
         // ‚úÖ CRIT√âRIOS PARA RESET COMPLETO
         if((g_stateVisits[state] >= 10 && winRate < 0.15) || // Muito ruim
            (g_stateVisits[state] >= 5 && winRate == 0.0) ||  // Nunca ganhou
            (g_stateVisits[state] > 20 && winRate < 0.25))    // Hist√≥rico longo ruim
         {
            // Reset completo
            g_stateVisits[state] = 0;
            g_stateWins[state] = 0;
            g_stateLosses[state] = 0;
            g_stateBlocked[state] = false;
            
            for(int a = 0; a < NUM_ACTIONS; a++)
            {
               g_Q[state * NUM_ACTIONS + a] = 0.0;
            }
            
            statesReset++;
         }
         // ‚úÖ RESET PARCIAL PARA ESTADOS M√âDIOS
         else if(g_stateVisits[state] >= 8 && winRate < 0.30)
         {
            // Manter 30% da mem√≥ria
            g_stateVisits[state] = (int)(g_stateVisits[state] * 0.3);
            g_stateWins[state] = (int)(g_stateWins[state] * 0.3);
            g_stateLosses[state] = (int)(g_stateLosses[state] * 0.3);
            
            // Garantir m√≠nimos
            if(g_stateVisits[state] < 1) g_stateVisits[state] = 1;
            if(g_stateWins[state] < 0) g_stateWins[state] = 0;
            if(g_stateLosses[state] < 0) g_stateLosses[state] = 0;
            
            // Reduzir Q-values
            for(int a = 0; a < NUM_ACTIONS; a++)
            {
               g_Q[state * NUM_ACTIONS + a] *= 0.3;
            }
            
            statesRetained++;
         }
         else
         {
            statesRetained++;
         }
      }
   }
   
   // Recalcular estados ativos
   g_activeStatesCount = 0;
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         if(g_activeStatesCount < MaxMemoryStates)
         {
            g_activeStates[g_activeStatesCount] = state;
            g_activeStatesCount++;
         }
      }
   }
   
   Print("üìä RESULTADO DO RESET:");
   Print("   Estados resetados completamente: ", statesReset);
   Print("   Estados mantidos (com redu√ß√£o): ", statesRetained);
   Print("   Total estados ativos ap√≥s reset: ", g_activeStatesCount);
   
   g_memoryDirty = true;
   SaveState();
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO: OTIMIZAR PAR√ÇMETROS DINAMICAMENTE
// ======================================================================
void OptimizeParametersDynamically()
{
   Print("‚öôÔ∏è OTIMIZANDO PAR√ÇMETROS DINAMICAMENTE");
   
   // ‚úÖ AJUSTAR EXPLORA√á√ÉO BASEADO NA PERFORMANCE
   double currentWinRate = SafeDivide((double)g_totalWins, (double)g_totalTrades, 0.0);
   
   if(currentWinRate < 0.25)
   {
      // Performance ruim, aumentar explora√ß√£o
      g_currentExplorationRate = MathMin(g_currentExplorationRate * 1.2, 0.8);
      Print("üìà Aumentando explora√ß√£o para ", DoubleToString(g_currentExplorationRate*100,1), 
            "% (win rate baixa: ", DoubleToString(currentWinRate*100,1), "%)");
   }
   else if(currentWinRate > 0.35)
   {
      // Performance boa, reduzir explora√ß√£o
      g_currentExplorationRate = MathMax(g_currentExplorationRate * 0.9, MinExplorationRate);
      Print("üìâ Reduzindo explora√ß√£o para ", DoubleToString(g_currentExplorationRate*100,1), 
            "% (win rate boa: ", DoubleToString(currentWinRate*100,1), "%)");
   }
   
   // ‚úÖ AJUSTAR LEARNING RATE
   if(g_totalTrades > 500)
   {
      LearningRate = 0.01; // Reduzir ap√≥s muitos trades
      Print("üéì Learning rate ajustado para 0.01 (maturidade do sistema)");
   }
   
   // ‚úÖ AJUSTAR LIMITES DE BLOQUEIO
   if(g_activeStatesCount > 100)
   {
      MinVisitsForBlockDecision = 8; // Exigir mais visitas
      Print("üõ°Ô∏è M√≠nimo visitas para bloqueio ajustado para 8");
   }
   
   g_memoryDirty = true;
}

// ======================================================================
// ‚úÖ HUD LEVE - FUN√á√ïES OTIMIZADAS
// ======================================================================

void CreateHUDObjects()
{
   if(!ShowHUD || hudObjectCount > 0) return;
   
   int lineHeight = 18;
   int currentY = HUD_Y;
   
   Print("üõ†Ô∏è Criando objetos do HUD...");
   
   if(ObjectCreate(0, "HUD_Title", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Title", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Title", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Title", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Title", OBJPROP_COLOR, HUD_TitleColor);
      ObjectSetInteger(0, "HUD_Title", OBJPROP_FONTSIZE, 11);
      ObjectSetString(0, "HUD_Title", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Title", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Title", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Title", OBJPROP_TEXT, "PHOENIX TRADER v307F SUPER CORRIGIDO");
      hudObjects[hudObjectCount++] = "HUD_Title";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Divider", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Divider", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Divider", OBJPROP_TEXT, "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
      hudObjects[hudObjectCount++] = "HUD_Divider";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_States", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_States", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_States", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_States", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_States", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_States", OBJPROP_FONTSIZE, 10);
      ObjectSetString(0, "HUD_States", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_States", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_States", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_States", OBJPROP_TEXT, "Estados: 0/" + IntegerToString(NUM_STATES));
      hudObjects[hudObjectCount++] = "HUD_States";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Progress", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_COLOR, HUD_SuccessColor);
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Progress", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Progress", OBJPROP_TEXT, "   [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] (0.0%)");
      hudObjects[hudObjectCount++] = "HUD_Progress";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Blocked", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Blocked", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Blocked", OBJPROP_TEXT, "   Bloqueados: 0 (0.0%)");
      hudObjects[hudObjectCount++] = "HUD_Blocked";
      currentY += lineHeight + 5;
   }
   
   if(ObjectCreate(0, "HUD_DecayInfo", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_COLOR, clrYellow);
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_DecayInfo", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_DecayInfo", OBJPROP_TEXT, "   Decay: Ativo | Ciclos: 0");
      hudObjects[hudObjectCount++] = "HUD_DecayInfo";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Direction", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_COLOR, clrGray);
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_FONTSIZE, 10);
      ObjectSetString(0, "HUD_Direction", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Direction", OBJPROP_TEXT, "Dire√ß√£o: ‚óè NEUTRO");
      hudObjects[hudObjectCount++] = "HUD_Direction";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Positions", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Positions", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Positions", OBJPROP_TEXT, "   Posi√ß√µes ativas: 0");
      hudObjects[hudObjectCount++] = "HUD_Positions";
      currentY += lineHeight + 5;
   }
   
   if(ObjectCreate(0, "HUD_Status", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Status", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Status", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Status", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Status", OBJPROP_COLOR, HUD_WarningColor);
      ObjectSetInteger(0, "HUD_Status", OBJPROP_FONTSIZE, 10);
      ObjectSetString(0, "HUD_Status", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Status", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Status", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Status", OBJPROP_TEXT, "STATUS: Inicializando...");
      hudObjects[hudObjectCount++] = "HUD_Status";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Volume", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Volume", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Volume", OBJPROP_TEXT, "Volume: NORMAL (1.0x)");
      hudObjects[hudObjectCount++] = "HUD_Volume";
      currentY += lineHeight - 5;
   }
   
   if(ObjectCreate(0, "HUD_Exploration", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Exploration", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Exploration", OBJPROP_TEXT, "Explora√ß√£o: 50%");
      hudObjects[hudObjectCount++] = "HUD_Exploration";
      currentY += lineHeight - 5;
   }
   
   if(ObjectCreate(0, "HUD_Trades", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Trades", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Trades", OBJPROP_TEXT, "Trades hoje: 0/30");
      hudObjects[hudObjectCount++] = "HUD_Trades";
   }
   
   Print("‚úÖ HUD criado com ", hudObjectCount, " objetos");
}

string CreateProgressBarFast(int current, int total)
{
   static string bars[21] = {
      "‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñë",
      "‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì"
   };
   
   if(total <= 0) total = 1;
   int index = (int)MathRound((double)current / total * 20);
   if(index < 0) index = 0;
   if(index > 20) index = 20;
   
   return bars[index];
}

string GetDirectionIconFast(int direction)
{
   if(direction == 1) return "‚ñ≤";
   if(direction == 2) return "‚ñº";
   return "‚óè";
}

color GetDirectionColorFast(int direction)
{
   if(direction == 1) return clrLime;
   if(direction == 2) return clrRed;
   return clrGray;
}

void UpdateHUDLight()
{
   if(!ShowHUD) 
   {
      RemoveHUD();
      return;
   }
   
   if(hudObjectCount == 0)
   {
      CreateHUDObjects();
      ChartRedraw(0);
      return;
   }
   
   datetime currentTime = TimeCurrent();
   if(currentTime - hudLastUpdate < HUD_UpdateMS/1000 && !HUD_Minimal) return;
   hudLastUpdate = currentTime;
   
   int visitedStates = cachedVisitedStates;
   if(visitedStates < 0)
   {
      visitedStates = g_activeStatesCount;
      cachedVisitedStates = visitedStates;
   }
   
   int blockedStates = cachedBlockedStates;
   if(blockedStates < 0)
   {
      blockedStates = CountBlockedStates();
      cachedBlockedStates = blockedStates;
   }
   
   int totalPositions = cachedPositions;
   if(totalPositions < 0)
   {
      totalPositions = GetTotalPositions();
      cachedPositions = totalPositions;
   }
   
   int currentDir = cachedDirection;
   if(currentDir < 0)
   {
      currentDir = GetCurrentPositionsDirection();
      cachedDirection = currentDir;
   }
   
   string newTitle = "üõ°Ô∏è PHOENIX TRADER v307F SUPER CORRIGIDO";
   ObjectSetString(0, "HUD_Title", OBJPROP_TEXT, newTitle);
   
   string newStates = StringFormat("Estados: %d/%d", visitedStates, NUM_STATES);
   ObjectSetString(0, "HUD_States", OBJPROP_TEXT, newStates);
   
   string progressBar = CreateProgressBarFast(visitedStates, NUM_STATES);
   double progressPercent = (double)visitedStates / NUM_STATES * 100.0;
   
   // üîß CORRE√á√ÉO: Converter double para string corretamente
   string newProgress = StringFormat("   [%s] (%.1f%%)", progressBar, progressPercent);
   ObjectSetString(0, "HUD_Progress", OBJPROP_TEXT, newProgress);
   
   double blockedPercent = visitedStates > 0 ? (double)blockedStates/visitedStates*100 : 0;
   string newBlocked = StringFormat("   Bloqueados: %d (%.1f%%)", blockedStates, blockedPercent);
   color blockedColor = (blockedStates > 0) ? HUD_WarningColor : HUD_TextColor;
   ObjectSetInteger(0, "HUD_Blocked", OBJPROP_COLOR, blockedColor);
   ObjectSetString(0, "HUD_Blocked", OBJPROP_TEXT, newBlocked);
   
   string decayInfo = StringFormat("   Decay: %s | Ciclos: %d | Resets: %d", 
                                   EnableMemoryDecay ? "Ativo" : "Inativo",
                                   g_totalDecayCycles,
                                   g_totalBadStateResets);
   ObjectSetString(0, "HUD_DecayInfo", OBJPROP_TEXT, decayInfo);
   
   string directionIcon = GetDirectionIconFast(currentDir);
   string directionText = (currentDir == 1) ? "BUY" : (currentDir == 2) ? "SELL" : "NEUTRO";
   color dirColor = GetDirectionColorFast(currentDir);
   string newDirection = StringFormat("Dire√ß√£o: %s %s", directionIcon, directionText);
   ObjectSetInteger(0, "HUD_Direction", OBJPROP_COLOR, dirColor);
   ObjectSetString(0, "HUD_Direction", OBJPROP_TEXT, newDirection);
   
   string positionsText = StringFormat("   Posi√ß√µes ativas: %d", totalPositions);
   ObjectSetString(0, "HUD_Positions", OBJPROP_TEXT, positionsText);
   
   color statusColor = HUD_TextColor;
   if(StringFind(g_statusMessage, "‚õî") >= 0) statusColor = HUD_ErrorColor;
   else if(StringFind(g_statusMessage, "‚úÖ") >= 0) statusColor = HUD_SuccessColor;
   else if(StringFind(g_statusMessage, "‚ö†Ô∏è") >= 0) statusColor = HUD_WarningColor;
   
   if(cachedStatus != g_statusMessage)
   {
      ObjectSetInteger(0, "HUD_Status", OBJPROP_COLOR, statusColor);
      ObjectSetString(0, "HUD_Status", OBJPROP_TEXT, "STATUS: " + g_statusMessage);
      cachedStatus = g_statusMessage;
   }
   
   if(cachedVolume != g_volumeMultiplier)
   {
      string volumeStatus = "Volume: ";
      color volumeColor = HUD_TextColor;
      
      if(UseRealVolumeFilter)
      {
         if(g_volumeMultiplier >= 1.10)
         {
            volumeStatus += StringFormat("ALTO (%.1fx)", g_volumeMultiplier);
            volumeColor = HUD_SuccessColor;
         }
         else if(g_volumeMultiplier >= 1.00)
         {
            volumeStatus += StringFormat("NORMAL (%.1fx)", g_volumeMultiplier);
         }
         else if(g_volumeMultiplier >= 0.05)
         {
            volumeStatus += StringFormat("BAIXO (%.1fx)", g_volumeMultiplier);
            volumeColor = HUD_WarningColor;
         }
         else
         {
            volumeStatus += StringFormat("MUITO BAIXO (%.1fx)", g_volumeMultiplier);
            volumeColor = HUD_ErrorColor;
         }
      }
      else
      {
         volumeStatus += "DESATIVADO";
      }
      
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_COLOR, volumeColor);
      ObjectSetString(0, "HUD_Volume", OBJPROP_TEXT, volumeStatus);
      cachedVolume = g_volumeMultiplier;
   }
   
   double explorationRatePercent = g_currentExplorationRate * 100;
   // ‚ö†Ô∏è GARANTIR QUE N√ÉO PASSE DE 100%
   if(explorationRatePercent > 100.0) explorationRatePercent = 100.0;
   string newExploration = StringFormat("Explora√ß√£o: %.0f%%", explorationRatePercent);
   ObjectSetString(0, "HUD_Exploration", OBJPROP_TEXT, newExploration);
   
   if(cachedTradesToday != g_tradesToday)
   {
      color tradesColor = (g_tradesToday >= MaxTradesPerDay) ? HUD_ErrorColor : HUD_TextColor;
      string newTrades = StringFormat("Trades hoje: %d/%d", g_tradesToday, MaxTradesPerDay);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_COLOR, tradesColor);
      ObjectSetString(0, "HUD_Trades", OBJPROP_TEXT, newTrades);
      cachedTradesToday = g_tradesToday;
   }
   
   ChartRedraw(0);
}

void InvalidateHUDCache()
{
   cachedVisitedStates = -1;
   cachedBlockedStates = -1;
   cachedPositions = -1;
   cachedDirection = -1;
   cachedStatus = "";
   cachedVolume = -1;
   cachedTradesToday = -1;
}

void RemoveHUD()
{
   for(int i = 0; i < hudObjectCount; i++)
   {
      if(hudObjects[i] != "")
      {
         ObjectDelete(0, hudObjects[i]);
      }
   }
   hudObjectCount = 0;
   InvalidateHUDCache();
   ChartRedraw(0);
}

// ======================================================================
// ‚úÖ VERIFICAR VOLUME REAL - VERS√ÉO SIMPLIFICADA
// ======================================================================
bool CheckRealVolume()
{
   if(!UseRealVolumeFilter) 
   {
      g_volumeStrength = 1.0;
      return true;
   }
   
   long volumeArray[];
   int barsToCopy = VolumeMAPeriod + 1;
   
   if(CopyTickVolume(_Symbol, _Period, 1, barsToCopy, volumeArray) < barsToCopy)
   {
      Print("‚ö†Ô∏è Erro ao ler volume. Recebidos: ", ArraySize(volumeArray), " de ", barsToCopy);
      g_volumeStrength = 0.5;
      return true;
   }
   
   g_currentVolume = volumeArray[barsToCopy - 1];
   
   long sumVol = 0;
   for(int i = 0; i < barsToCopy - 1; i++)
   {
      sumVol += volumeArray[i];
   }
   
   g_volumeAverage = (long)(sumVol / (barsToCopy - 1));
   
   if(g_volumeAverage > 0)
   {
      g_volumeMultiplier = SafeDivide((double)g_currentVolume, (double)g_volumeAverage, 1.0);
      g_volumeStrength = g_volumeMultiplier;
      cachedVolume = -1;
   }
   else
   {
      g_volumeMultiplier = 1.0;
      g_volumeStrength = 1.0;
      return true;
   }
   
   bool isVolumeStrong = g_volumeMultiplier >= MinVolumeMultiplier;
   
   return isVolumeStrong;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ TRAILING STOP DIN√ÇMICO CORRIGIDO
// ======================================================================

void ManageDynamicTrailingStop()
{
   if(!UseDynamicTrailingStop) 
   {
      if(g_trailingCount > 0)
      {
         ArrayResize(g_trailingTickets, 0);
         ArrayResize(g_trailingBestPrices, 0);
         ArrayResize(g_trailingCurrentSL, 0);
         ArrayResize(g_trailingCurrentTP, 0);
         ArrayResize(g_trailingLastTrailTimes, 0);
         ArrayResize(g_trailingBreakevenActivated, 0);
         g_trailingCount = 0;
      }
      return;
   }
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      long type = PositionGetInteger(POSITION_TYPE);
      bool isBuy = (type == POSITION_TYPE_BUY);
      
      double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentTP = PositionGetDouble(POSITION_TP);
      double currentPrice = isBuy ? 
         SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
         SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      double currentProfit = isBuy ? 
         (currentPrice - entryPrice) / point : 
         (entryPrice - currentPrice) / point;
      
      int trailIndex = -1;
      for(int j = 0; j < g_trailingCount; j++)
      {
         if(g_trailingTickets[j] == ticket)
         {
            trailIndex = j;
            break;
         }
      }
      
      if(trailIndex == -1)
      {
         AddPositionToTrailingSystem(ticket);
         continue;
      }
      
      if(isBuy)
      {
         if(currentPrice > g_trailingBestPrices[trailIndex])
         {
            g_trailingBestPrices[trailIndex] = currentPrice;
         }
      }
      else
      {
         if(currentPrice < g_trailingBestPrices[trailIndex])
         {
            g_trailingBestPrices[trailIndex] = currentPrice;
         }
      }
      
      bool shouldAdjust = false;
      double newSL = currentSL;
      double newTP = currentTP;
      
      if(UseBreakevenStop && !g_trailingBreakevenActivated[trailIndex] && 
         MathAbs(currentProfit) >= BreakevenTriggerPoints)
      {
         double breakevenPrice = entryPrice;
         
         if(isBuy) breakevenPrice += point * 10;
         else breakevenPrice -= point * 10;
         
         if((isBuy && currentPrice > breakevenPrice) || 
            (!isBuy && currentPrice < breakevenPrice))
         {
            newSL = breakevenPrice;
            g_trailingBreakevenActivated[trailIndex] = true;
            shouldAdjust = true;
            Print("üí∞ BREAKEVEN ativado para posi√ß√£o #", ticket, 
                  " | SL ajustado para: ", newSL);
         }
      }
      
      if(MathAbs(currentProfit) >= TrailingStartPoints)
      {
         double trailingDistancePoints = TrailingStopPoints;
         
         if(UseATRTrailing)
         {
            double atr[];
            if(CopyBuffer(g_atrHandle, 0, 0, 1, atr) >= 1)
            {
               trailingDistancePoints = (atr[0] / point) * ATRTrailingMultiplier;
               Print("üìè Trailing usando ATR: ", atr[0], " -> ", trailingDistancePoints, " pontos");
            }
         }
         
         double trailingDistance = trailingDistancePoints * point;
         double stepDistance = TrailingStepPoints * point;
         
         if(isBuy)
         {
            double desiredStop = g_trailingBestPrices[trailIndex] - trailingDistance;
            
            if(desiredStop > currentSL || currentSL == 0)
            {
               if(MathAbs(desiredStop - currentSL) >= stepDistance || currentSL == 0)
               {
                  newSL = desiredStop;
                  shouldAdjust = true;
               }
            }
            
            if(TrailBothSLandTP && currentTP > 0)
            {
               double desiredTP = g_trailingBestPrices[trailIndex] + (trailingDistance * 0.8);
               if(desiredTP > currentTP)
               {
                  newTP = desiredTP;
                  shouldAdjust = true;
               }
            }
         }
         else
         {
            double desiredStop = g_trailingBestPrices[trailIndex] + trailingDistance;
            
            if(desiredStop < currentSL || currentSL == 0)
            {
               if(MathAbs(desiredStop - currentSL) >= stepDistance || currentSL == 0)
               {
                  newSL = desiredStop;
                  shouldAdjust = true;
               }
            }
            
            if(TrailBothSLandTP && currentTP > 0)
            {
               double desiredTP = g_trailingBestPrices[trailIndex] - (trailingDistance * 0.8);
               if(desiredTP < currentTP)
               {
                  newTP = desiredTP;
                  shouldAdjust = true;
               }
            }
         }
      }
      
      if(shouldAdjust && (newSL != currentSL || newTP != currentTP))
      {
         datetime currentTime = TimeCurrent();
         if(currentTime - g_trailingLastTrailTimes[trailIndex] >= 30)
         {
            if(trade.PositionModify(ticket, newSL, newTP))
            {
               g_trailingCurrentSL[trailIndex] = newSL;
               g_trailingCurrentTP[trailIndex] = newTP;
               g_trailingLastTrailTimes[trailIndex] = currentTime;
               
               double slPoints = MathAbs(newSL - entryPrice) / point;
               double tpPoints = MathAbs(newTP - entryPrice) / point;
               
               string trailingType = UseATRTrailing ? "ATR" : "Fixo";
               Print("üìà TRAILING STOP (", trailingType, ") ajustado para posi√ß√£o #", ticket,
                     " | Novo SL: ", newSL, " (", slPoints, " pontos)",
                     " | Novo TP: ", newTP, " (", tpPoints, " pontos)",
                     " | Lucro atual: ", currentProfit, " pontos");
            }
            else
            {
               Print("‚ùå Falha ao ajustar trailing stop para posi√ß√£o #", ticket,
                     " | Erro: ", GetLastError());
            }
         }
      }
   }
}

void ManageAllDynamicStops()
{
   ManageDynamicTrailingStop();
   
   for(int i = g_trailingCount - 1; i >= 0; i--)
   {
      if(!PositionSelectByTicket(g_trailingTickets[i]))
      {
         RemovePositionFromTrailingSystem(g_trailingTickets[i]);
      }
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ ‚úÖ‚úÖ‚úÖ FUN√á√ÉO PRINCIPAL CORRIGIDA: UpdateQ (APENAS CHAMAR PARA TRADES REAIS)
// ======================================================================
void UpdateQ(int state, int action, double reward)
{
   if(state < 0 || state >= NUM_STATES) return;
   if(action < 0 || action >= NUM_ACTIONS) return;
   if(ArraySize(g_Q) <= state * NUM_ACTIONS + action) return;
   
   // ‚úÖ REMOVER QUALQUER VERIFICA√á√ÉO DE LIMITE DE VISITAS
   // N√ÉO DEVE TER: if(g_stateVisits[state] >= 10) return;
   
   // ‚úÖ DEBUG EXPANDIDO
   static int updateCounter = 0;
   updateCounter++;
   
   if(updateCounter % 50 == 0)
   {
      Print("üîç UpdateQ #", updateCounter, 
            " | Estado: ", state, 
            " | Visitas: ", g_stateVisits[state],
            " | Action: ", (action==0?"NOP":(action==1?"BUY":"SELL")),
            " | Reward: ", reward);
   }
   
   if(!g_lastTradeExecuted) 
   {
      Print("‚ö†Ô∏è ATEN√á√ÉO: Tentativa de atualizar Q sem trade executado");
      return;
   }
   
   AddActiveState(state);
   
   int idx = state * NUM_ACTIONS + action;
   
   double alpha = LearningRate;
   double old = g_Q[idx];
   double newq = old + alpha * (reward - old);
   
   g_Q[idx] = CompressQValue(newq);
   
   g_stateLastUpdate[state] = g_totalTrades;
   
   // ‚úÖ ATUALIZAR CONTADORES DE VISITAS APENAS PARA TRADES REAIS
   if(action == 1 || action == 2) // BUY ou SELL
   {
      g_stateVisits[state]++;
      
      if(reward > 0)
      {
         g_stateWins[state]++;
      }
      else
      {
         g_stateLosses[state]++;
      }
   }
   
   // ‚úÖ VERIFICA√á√ÉO DE BLOQUEIO MAIS INTELIGENTE
   if(EnableUnifiedBlockingSystem && g_stateVisits[state] >= MinVisitsForBlockDecision)
   {
      double winRate = CalculateWinRate(state);
      
      // S√≥ bloquear se realmente for muito ruim
      if(winRate < 0.25 && g_stateVisits[state] >= 8)
      {
         g_stateBlocked[state] = true;
         Print("‚õî Estado ", state, " bloqueado - Win rate muito baixa: ", 
               DoubleToString(winRate*100,1), "%");
      }
      else if(g_stateBlocked[state] && winRate >= 0.40)
      {
         g_stateBlocked[state] = false;
         Print("‚úÖ Estado ", state, " desbloqueado - Win rate melhorou: ", 
               DoubleToString(winRate*100,1), "%");
      }
   }
   
   g_memoryDirty = true;
   
   // ‚úÖ EXPLORA√á√ÉO DIN√ÇMICA BASEADA EM PERFORMANCE
   if(reward > 0)
   {
      // Reduzir explora√ß√£o ap√≥s vit√≥ria
      g_currentExplorationRate *= ExplorationDecay;
   }
   else if(reward < -1.0)
   {
      // Aumentar explora√ß√£o ap√≥s perda grande
      g_currentExplorationRate = MathMin(g_currentExplorationRate * 1.1, 0.7);
   }
   
   // ‚úÖ GARANTIR LIMITES
   if(g_currentExplorationRate > 1.0) g_currentExplorationRate = 1.0;
   if(g_currentExplorationRate < MinExplorationRate) g_currentExplorationRate = MinExplorationRate;
   
   g_qUpdatesSinceSave++;
   g_totalQUpdates++;
   
   // ‚úÖ DECAY PERI√ìDICO
   if(g_totalTrades - g_lastDecayTradeCount >= 500)
   {
      ApplyStateDecay();
      g_lastDecayTradeCount = g_totalTrades;
   }
   
   // ‚úÖ SAVE PERI√ìDICO
   if(g_qUpdatesSinceSave >= 3)
   {
      SaveBrain();
   }
   
   // ‚úÖ CHAMAR CORRE√á√ïES PERI√ìDICAS
   static int lastFixCall = 0;
   if(g_totalTrades - lastFixCall >= 100)
   {
      FixStuckStatesProblem();
      lastFixCall = g_totalTrades;
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO CORRIGIDA: UpdateQ_NOP (N√ÉO CONTA COMO PERDA)
// ======================================================================
void UpdateQ_NOP(int state)
{
   if(state < 0) return;
  
   Print("üìä NOP registrado para estado ", state, " (n√£o conta como visita/perda real)");
   
   if(ExcludeNOPFromVisits)
   {
      // NOP n√£o incrementa contadores de visita/perda
      Print("‚úÖ NOP exclu√≠do de contagens (configura√ß√£o ativa)");
   }
   
   if(ArraySize(g_Q) > state * NUM_ACTIONS)
   {
      int idx = state * NUM_ACTIONS;
      double oldQ = g_Q[idx];
      double newQ = oldQ - 0.001;
      g_Q[idx] = CompressQValue(newQ);
      
      g_memoryDirty = true;
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ ChooseAction - COM SISTEMA CORRIGIDO (VERS√ÉO MODIFICADA)
// ======================================================================
int ChooseAction(int state)
{
   if(state < 0 || state >= NUM_STATES)
   {
      Print("‚ùå Estado inv√°lido: ", state);
      return 0;
   }
   
   if(IsStateBlocked(state))
   {
      Print("‚õî Estado ", state, " bloqueado pelo sistema corrigido");
      g_statusMessage = StringFormat("‚õî Estado %d bloqueado (sistema corrigido)", state);
      return 0;
   }
   
   if(ArraySize(g_Q) <= state * NUM_ACTIONS + 2)
   {
      Print("‚ùå Array Q n√£o inicializado");
      return 0;
   }
   
   static int noTradeCounter = 0;
   noTradeCounter++;
   
   if (noTradeCounter > 10)
   {
      noTradeCounter = 0;
      int forcedAction = 1 + (MathRand() % 2);
      Print("üéØ ANTI-TRAVAMENTO: For√ßando a√ß√£o aleat√≥ria ", forcedAction, " ap√≥s muitas decis√µes NOP");
      g_statusMessage = "üéØ Anti-travamento: a√ß√£o for√ßada";
      return forcedAction;
   }
   
   if(g_consecutiveLosses >= 12)
   {
      g_currentExplorationRate = MathMax(InitialExplorationRate * 1.3, 0.2);
      Print("‚ôªÔ∏è Reset de explora√ß√£o ap√≥s ", g_consecutiveLosses, " perdas consecutivas");
   }
   
   // ‚ö†Ô∏è CORRE√á√ÉO: REDUZIR EXPLORA√á√ÉO DRAMATICAMENTE
   if(g_stateVisits[state] < MinStateVisitsToTrade)
   {
      double eps = 0.8; // 80% de explora√ß√£o para estados novos
      
      if(((double)MathRand() / 32767.0) < eps) 
      {
         int randomAction = 1 + (MathRand() % 2);
         Print("üîç EXPLORA√á√ÉO (estado novo): A√ß√£o aleat√≥ria ", randomAction, " | Estado: ", state);
         g_statusMessage = "üîç Explora√ß√£o (estado novo)";
         noTradeCounter = 0;
         return randomAction;
      }
      else
      {
         Print("ü§î Estado novo, mas escolhendo NOP (20% chance)");
         return 0;
      }
   }
   
   // Para estados conhecidos, usar taxa de explora√ß√£o normal
   double eps = g_currentExplorationRate;
   
   // ‚ö†Ô∏è GARANTIR que n√£o fique preso em explora√ß√£o
   if(g_currentExplorationRate > 0.7 && g_totalTrades > 100)
   {
      eps = 0.7; // For√ßar redu√ß√£o
      g_currentExplorationRate = 0.7;
   }

   if(((double)MathRand() / 32767.0) < eps) 
   {
      int randomAction = 1 + (MathRand() % 2);
      Print("üîç EXPLORA√á√ÉO: A√ß√£o aleat√≥ria ", randomAction, " | Estado: ", state);
      g_statusMessage = "üîç Explora√ß√£o (a√ß√£o aleat√≥ria)";
      noTradeCounter = 0;
      return randomAction;
   }

   double best = -DBL_MAX;
   int bestA = 0;

   for(int a = 1; a < NUM_ACTIONS; a++)
   {
      int idx = state * NUM_ACTIONS + a;
      if(idx < ArraySize(g_Q) && g_Q[idx] > best)
      {
         best = g_Q[idx];
         bestA = a;
      }
   }
   
   double nopQ = g_Q[state * NUM_ACTIONS + 0];
   
   // ‚ö†Ô∏è CORRE√á√ÉO: Tornar NOP mais atrativo para estados ruins
   double winRate = CalculateWinRate(state);
   if(g_stateVisits[state] >= 5 && winRate < 0.3)
   {
      bestA = 0;
      Print("ü§î NOP escolhido (estado ruim, win rate: ", DoubleToString(winRate*100,1), "%)");
      g_statusMessage = "NOP (estado ruim)";
   }
   else if(nopQ > best * 1.5 && bestA > 0)
   {
      bestA = 0;
      Print("ü§î NOP escolhido (superioridade: ", nopQ, " vs ", best, ")");
      g_statusMessage = "NOP (melhor op√ß√£o)";
   }
   else if(best <= -20.0)
   {
      bestA = 0;
      Print("ü§î NOP escolhido (a√ß√µes de trade muito ruins: ", best, ")");
      g_statusMessage = "NOP (a√ß√µes ruins)";
   }
   else if(bestA == 1 || bestA == 2)
   {
      if(bestA == 1) g_statusMessage = "BUY recomendado";
      else g_statusMessage = "SELL recomendado";
   }
   else
   {
      g_statusMessage = "NOP (indecis√£o)";
   }
   
   Print("üí° DECIS√ÉO: Estado ", state, " | A√ß√£o ", 
         (bestA==0?"NOP":(bestA==1?"BUY":"SELL")), 
         " | Q = ", bestA==0 ? nopQ : best,
         " | Visitas: ", g_stateVisits[state],
         " | Win Rate: ", DoubleToString(winRate*100,1), "%");
   
   return bestA;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ ExecuteAction - COM SISTEMA CORRIGIDO
// ======================================================================
void ExecuteAction(int action, int state)
{
   g_lastTradeExecuted = false;
   g_lastTradeStateExecuted = -1;
   
   bool isBuy = (action == 1);
   
   Print("=== TENTATIVA DE EXECU√á√ÉO: ", isBuy ? "BUY" : "SELL", " ===");
   Print("Estado: ", state, " | Visitas REAIS: ", g_stateVisits[state], 
         " | Perdas REAIS: ", g_stateLosses[state],
         " | Vit√≥rias REAIS: ", g_stateWins[state]);
   
   if(IsStateBlocked(state))
   {
      Print("‚õî‚õî‚õî BLOQUEIO CONFIRMADO - Estado ", state, " bloqueado pelo sistema corrigido - trade CANCELADO");
      g_statusMessage = StringFormat("‚õî Estado %d bloqueado (sistema corrigido)", state);
      UpdateQ_NOP(state);
      return;
   }
   
   if(UseRealVolumeFilter)
   {
      bool volumeOk = CheckRealVolume();
      if(!volumeOk && g_volumeMultiplier < 0.6)
      {
         Print("‚ö†Ô∏è Volume moderado, mantendo lote m√≠nimo");
      }
   }
   
   if(!CanOpenNewPosition(isBuy))
   {
      g_statusMessage = "‚õî N√£o pode abrir nova posi√ß√£o na dire√ß√£o";
      UpdateQ_NOP(state);
      return;
   }
   
   if(!CanTradeBasedOnTime())
   {
      g_statusMessage = "‚è≥ Aguardando tempo entre trades";
      UpdateQ_NOP(state);
      return;
   }
   
   if(!CheckVolatility())
   {
      g_statusMessage = "‚õî Volatilidade alta";
      UpdateQ_NOP(state);
      return;
   }
   
   if(!ValidateAllIndicators(isBuy))
   {
      g_statusMessage = "‚õî Indicadores n√£o confirmam";
      UpdateQ_NOP(state);
      return;
   }
   
   int sameDirCount = CountSameDirectionPositions(isBuy);
   double desiredLot = LotSize;
   
   if(sameDirCount == 0 && EnableSmartLot)
   {
      double quality = GetStateQuality(state);
      
      if(quality >= UltraQualityThreshold)
      {
         desiredLot = LotSize * UltraLotMultiplier;
         Print("üíéüíéüíé SETUP ULTRA DETECTADO!");
         g_statusMessage = "üíé ULTRA SETUP - Aposta M√°xima!";
      }
      else if(quality >= HighQualityThreshold)
      {
         desiredLot = LotSize * SmartLotMultiplier;
         Print("üöÄüöÄ SETUP FORTE DETECTADO!");
         g_statusMessage = "üöÄ SETUP FORTE - Aposta Elevada!";
      }
      else if(quality > 0.1)
      {
         Print("üìä SETUP NORMAL POSITIVO");
         g_statusMessage = "üìä Setup Normal - Qualidade Positiva";
      }
      else if(quality < -0.3)
      {
         Print("‚ö†Ô∏è‚ö†Ô∏è SETUP NEGATIVO DETECTADO - Considerando cancelar trade");
         if(quality < -0.5)
         {
            Print("‚õî TRADE CANCELADO - Qualidade muito baixa: ", quality);
            g_statusMessage = "‚õî Setup Negativo - Trade Cancelado";
            UpdateQ_NOP(state);
            return;
         }
      }
      else
      {
         Print("üìà SETUP NEUTRO");
      }
   }
   else if(sameDirCount > 0)
   {
      desiredLot = CalculatePyramidLot(isBuy);
      Print("üèóÔ∏è Entrada de piramida√ß√£o #", sameDirCount + 1, " - Lote: ", desiredLot);
   }
   
   if(desiredLot > MaxAllowedLot) 
   {
      desiredLot = MaxAllowedLot;
      Print("‚ö†Ô∏è Lote limitado ao m√°ximo permitido: ", MaxAllowedLot);
   }
   
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   if(desiredLot < minLot) 
   {
      desiredLot = minLot;
      Print("‚ö†Ô∏è Lote ajustado ao m√≠nimo permitido: ", minLot);
   }
   
   Print("üí∞ LOTE FINAL DEFINIDO: ", desiredLot);
   
   double price = isBuy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                        : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);

   double sl_price = 0.0;
   double tp_price = 0.0;
   
   if(UseFixedSL) sl_price = CalculateSLByPoints(isBuy, price);
   if(UseFixedTP) tp_price = CalculateTPByPoints(isBuy, price);

   if(!AreStopsValid(isBuy, price, sl_price, tp_price))
   {
      g_statusMessage = "‚õî Stops inv√°lidos";
      UpdateQ_NOP(state);
      return;
   }

   MqlTradeRequest req;
   MqlTradeResult  res;
   ZeroMemory(req); ZeroMemory(res);

   req.action    = TRADE_ACTION_DEAL;
   req.symbol    = _Symbol;
   req.volume    = desiredLot;
   req.type      = isBuy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
   req.price     = price;
   req.sl        = sl_price;
   req.tp        = tp_price;
   req.magic     = (ulong)MagicNumber;
   req.deviation = 30;
   req.type_filling = ORDER_FILLING_FOK;
   
   int pyramidLevel = sameDirCount + 1;
   string commentType = "NORMAL";
   
   double quality = GetStateQuality(state);
   
   if(sameDirCount == 0 && EnableSmartLot)
   {
      if(quality >= UltraQualityThreshold) commentType = "ULTRA";
      else if(quality >= HighQualityThreshold) commentType = "FORCE";
      else if(quality > 0.1) commentType = "POS";
      else if(quality < -0.2) commentType = "NEG";
      else commentType = "NEUTRO";
   }
   
   string comment = StringFormat("PHX307F_CORRIGIDO_%s_%s_P%d_SL%d_TP%d_VOL%.1fx_Q%.2f_DECAY%d", 
                   isBuy ? "BUY" : "SELL",
                   commentType,
                   pyramidLevel,
                   FixedSL_Points, FixedTP_Points,
                   g_volumeMultiplier,
                   quality,
                   g_totalDecayCycles);
   
   // ‚úÖ CORRE√á√ÉO: Atribuir string diretamente ao campo comment
   req.comment = comment;

   if(!OrderSend(req,res))
   {
      Print("‚ùå Falha na ordem: Erro ", GetLastError());
      g_statusMessage = "‚õî Falha na ordem";
      UpdateQ_NOP(state);
      return;
   }

   g_lastTradeExecuted = true;
   g_lastTradeStateExecuted = state;
   
   g_lastTradeTime = TimeCurrent();
   
   if(isBuy)
      g_lastBuyTime = TimeCurrent();
   else
      g_lastSellTime = TimeCurrent();
   
   g_lastTradeState  = state;
   g_lastTradeAction = action;
   g_lastLotUsed     = desiredLot;
   g_tradesToday++;
   
   g_currentDirection = isBuy ? 1 : 2;
   g_positionsCount = GetTotalPositions();
   cachedPositions = -1;
   cachedDirection = -1;
   cachedTradesToday = -1;
   
   AddPositionToTrailingSystem((ulong)res.order);
   
   double slPoints = 0, tpPoints = 0;
   if(sl_price > 0) slPoints = MathAbs(price - sl_price) / point;
   if(tp_price > 0) tpPoints = MathAbs(tp_price - price) / point;
   
   string lotTypeMsg = "";
   if(sameDirCount == 0 && EnableSmartLot)
   {
      if(quality >= UltraQualityThreshold) lotTypeMsg = "üíé ULTRA ";
      else if(quality >= HighQualityThreshold) lotTypeMsg = "üöÄ FORCE ";
      else if(quality > 0.1) lotTypeMsg = "üìà POS ";
      else if(quality < -0.2) lotTypeMsg = "‚ö†Ô∏è NEG ";
      else lotTypeMsg = "üìä NEUTRO ";
   }
   
   g_statusMessage = StringFormat("‚úÖ %s%s #%d executado (VOL: %.1fx, Q: %.2f, Decay: %d)", 
                                  lotTypeMsg, 
                                  isBuy ? "BUY" : "SELL", 
                                  pyramidLevel, 
                                  g_volumeMultiplier, 
                                  quality,
                                  g_totalDecayCycles);
   
   Print("üéØ TRADE EXECUTADO COM SUCESSO - SISTEMA CORRIGIDO COM DECAY: ",
         lotTypeMsg,
         isBuy ? "BUY" : "SELL", " #", pyramidLevel,
         " | Estado: ", state,
         " | Volume: ", g_currentVolume, " (", DoubleToString(g_volumeMultiplier, 1), "x)",
         " | Qualidade: ", DoubleToString(quality, 2),
         " | Lote: ", desiredLot, " (", DoubleToString(desiredLot/LotSize, 1), "x)",
         " | SL: ", DoubleToString(slPoints, 0), " pts",
         " | TP: ", DoubleToString(tpPoints, 0), " pts",
         " | Pre√ßo: ", DoubleToString(price, 5),
         " | Ciclos Decay: ", g_totalDecayCycles);
   
   Print("üìä AGUARDANDO FECHAMENTO: Trade executado, visitas/perdas ser√£o atualizadas apenas ap√≥s fechamento...");
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO ComputeRewardFromTrade (ATUALIZADA)
// ======================================================================
double ComputeRewardFromTrade(double profit)
{
   if(UseSimpleRewardSystem)
   {
      if(profit > 0) return RewardWin;
      else return RewardLoss;
   }
   
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double profit_points = profit / (LotSize * point * 100);
   
   if(profit > 0)
   {
      return 1.0 + profit_points / 100.0;
   }
   else
   {
      return -1.0 - MathAbs(profit_points) / 200.0;
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO GetStateQuality - VERS√ÉO MELHORADA
// ======================================================================
double GetStateQuality(int state)
{
   if(state < 0 || state >= NUM_STATES) return 0.0;
   if(ArraySize(g_stateVisits) <= state) return 0.0;
   if(ArraySize(g_Q) <= state * NUM_ACTIONS + 2) return 0.0;
   
   if(g_stateVisits[state] < 2) return 0.0;
   
   double buyQ  = g_Q[state * NUM_ACTIONS + 1];
   double sellQ = g_Q[state * NUM_ACTIONS + 2];
   double nopQ  = g_Q[state * NUM_ACTIONS + 0];
   
   double bestTradeQ = MathMax(buyQ, sellQ);
   
   if(nopQ > bestTradeQ * 3.0)
   {
      double penalizedQuality = (bestTradeQ - nopQ) / 5.0;
      return MathMax(penalizedQuality, -2.0);
   }
   
   double quality = bestTradeQ / 10.0;
   
   if(g_stateVisits[state] >= 5)
   {
      double winRate = CalculateWinRate(state);
      double lossRate = 1.0 - winRate;
      
      if(lossRate > 0.6)
      {
         quality -= (lossRate - 0.6) * 3.0;
      }
      
      if(winRate > 0.7 && g_stateVisits[state] >= 10)
      {
         quality += (winRate - 0.7) * 2.0;
      }
   }
   
   if(quality > 2.0) quality = 2.0;
   if(quality < -2.0) quality = -2.0;
   
   return quality;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ïES PARA CALCULAR ESTADO
// ======================================================================

// ‚úÖ Fun√ß√£o para calcular bucket RSI
int GetRSIBucket(double rsiValue)
{
   if(rsiValue < 25) return 0;          // Muito sobrevendido
   else if(rsiValue < 40) return 1;     // Sobrevedido
   else if(rsiValue < 50) return 2;     // Tend√™ncia de baixa
   else return 3;                       // Tend√™ncia de alta
}

// ‚úÖ Fun√ß√£o para calcular bucket MA Distance
int GetMADistanceBucket(double maDistance)
{
   if(maDistance < -1.5) return 0;       // Muito abaixo da MA
   else if(maDistance < 0) return 1;     // Abaixo da MA
   else return 2;                        // Acima da MA
}

// ‚úÖ Fun√ß√£o para calcular bucket ADX
int GetADXBucket(double adxValue)
{
   if(adxValue < 20) return 0;           // Tend√™ncia fraca
   else return 1;                        // Tend√™ncia forte
}

// ‚úÖ Fun√ß√£o para calcular bucket Bollinger Bands
int GetBBBucket(double bbPosition)
{
   if(bbPosition < 0.3) return 0;        // Pr√≥ximo da banda inferior
   else if(bbPosition < 0.7) return 1;   // No meio
   else return 2;                        // Pr√≥ximo da banda superior
}

// ‚úÖ Fun√ß√£o para calcular bucket volatilidade
int GetVolatilityBucket(double atrCurrent, double atrPrevious)
{
   double ratio = SafeDivide(atrCurrent, atrPrevious, 1.0);
   
   if(ratio < 0.8) return 0;             // Volatilidade diminuindo
   else return 1;                        // Volatilidade est√°vel/aumentando
}

// ‚úÖ Fun√ß√£o para calcular bucket volume
int GetVolumeBucket()
{
   if(!UseRealVolumeFilter) return 1;    // Volume normal (default)
   
   if(g_volumeMultiplier < 0.7) return 0;  // Volume baixo
   else return 1;                         // Volume normal/alto
}

// ‚úÖ Fun√ß√£o para calcular bucket de tempo
int GetTimeBucket()
{
   MqlDateTime timeStruct;
   TimeCurrent(timeStruct);
   
   int hour = timeStruct.hour;
   
   if(hour >= 0 && hour < 12) return 0;      // Manh√£/Madrugada
   else return 1;                            // Tarde/Noite
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO GetCurrentState (OTIMIZADA E CORRIGIDA)
// ======================================================================
int GetCurrentState()
{
   double ma[], rsi[], adx[], bb_upper[], bb_lower[], atr[];
   ArraySetAsSeries(ma, true);
   ArraySetAsSeries(rsi, true);
   ArraySetAsSeries(adx, true);
   ArraySetAsSeries(bb_upper, true);
   ArraySetAsSeries(bb_lower, true);
   ArraySetAsSeries(atr, true);
   
   if(CopyBuffer(g_maHandle, 0, 0, 1, ma) < 1) 
   {
      Print("‚ùå Erro ao copiar MA");
      return -1;
   }
   if(CopyBuffer(g_rsiHandle, 0, 0, 1, rsi) < 1) 
   {
      Print("‚ùå Erro ao copiar RSI");
      return -1;
   }
   if(CopyBuffer(g_adxHandle, 0, 0, 1, adx) < 1) 
   {
      Print("‚ùå Erro ao copiar ADX");
      return -1;
   }
   if(CopyBuffer(g_bbHandle, 0, 0, 1, bb_upper) < 1) 
   {
      Print("‚ùå Erro ao copiar BB Upper");
      return -1;
   }
   if(CopyBuffer(g_bbHandle, 2, 0, 1, bb_lower) < 1) 
   {
      Print("‚ùå Erro ao copiar BB Lower");
      return -1;
   }
   if(CopyBuffer(g_atrHandle, 0, 0, 2, atr) < 2) 
   {
      Print("‚ùå Erro ao copiar ATR");
      return -1;
   }
   
   double price = SymbolInfoDouble(_Symbol, SYMBOL_LAST);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   // ‚úÖ C√°lculo da dist√¢ncia da MA
   // Usar ATR se dispon√≠vel, sen√£o usar point * 10 como fallback
   double atrValue = atr[0];
   double divisor = (atrValue > DBL_EPSILON * 1000) ? atrValue : (point * 10);
   double maDistance = SafeDivide((price - ma[0]), divisor, 0.0);
   
   // ‚úÖ C√°lculo da posi√ß√£o nas Bollinger Bands
   double bbPosition = 0;
   double bbRange = bb_upper[0] - bb_lower[0];
   bbPosition = SafeDivide((price - bb_lower[0]), bbRange, 0.5);
   
   // ‚úÖ Calcular buckets otimizados
   int maBucket = GetMADistanceBucket(maDistance);
   int rsiBucket = GetRSIBucket(rsi[0]);
   int adxBucket = GetADXBucket(adx[0]);
   int bbBucket = GetBBBucket(bbPosition);
   int volBucket = GetVolatilityBucket(atr[0], atr[1]);
   int volumeBucket = GetVolumeBucket();
   int timeBucket = GetTimeBucket();
   
   // ‚úÖ Prote√ß√£o contra overflow
   maBucket = (int)MathMod(maBucket, BINS_MA_DIST);
   rsiBucket = (int)MathMod(rsiBucket, BINS_RSI);
   adxBucket = (int)MathMod(adxBucket, BINS_ADX);
   bbBucket = (int)MathMod(bbBucket, BINS_BBPOS);
   volBucket = (int)MathMod(volBucket, BINS_VOLATILITY);
   volumeBucket = (int)MathMod(volumeBucket, BINS_VOLUME);
   timeBucket = (int)MathMod(timeBucket, BINS_TIME);
   
   // ‚úÖ CORRE√á√ÉO: M√©todo correto - multiplicar na ordem inversa
   int state_idx = 0;
   
   // M√©todo correto - multiplicar na ordem inversa
   state_idx = (((((timeBucket * BINS_VOLUME + volumeBucket) * BINS_VOLATILITY + volBucket) * 
                  BINS_BBPOS + bbBucket) * BINS_ADX + adxBucket) * 
                  BINS_RSI + rsiBucket) * BINS_MA_DIST + maBucket;
   
   // ‚úÖ VERIFICA√á√ÉO DE SEGURAN√áA
   if(state_idx < 0) state_idx = 0;
   if(state_idx >= NUM_STATES) 
   {
      Print("‚ùå ERRO CR√çTICO: Estado calculado ", state_idx, " excede NUM_STATES ", NUM_STATES);
      state_idx = state_idx % NUM_STATES; // For√ßar dentro dos limites
   }
   
   // ‚úÖ DEBUG para verificar c√°lculo
   static int debugCounter = 0;
   if(debugCounter++ % 100 == 0)
   {
      Print("DEBUG Estado: idx=", state_idx, 
            " | ma=", maBucket, " rsi=", rsiBucket, " adx=", adxBucket,
            " bb=", bbBucket, " vol=", volBucket, " volM=", volumeBucket, " time=", timeBucket);
   }
   
   // ‚úÖ PROTE√á√ÉO CONTRA ESTADO CONGELADO
   static int lastState = -1;
   static int sameStateCount = 0;
   static datetime lastStateChange = 0;
   
   if(state_idx == lastState)
   {
      sameStateCount++;
      datetime now = TimeCurrent();
      
      // Se ficou no mesmo estado por muito tempo, for√ßar varia√ß√£o
      if(sameStateCount > 20 && (now - lastStateChange) > 3600)
      {
         Print("‚ö†Ô∏è Estado congelado detectado! For√ßando varia√ß√£o...");
         state_idx = (state_idx + 1 + MathRand() % 5) % NUM_STATES;
         sameStateCount = 0;
         lastStateChange = now;
      }
   }
   else
   {
      sameStateCount = 0;
      lastState = state_idx;
      lastStateChange = TimeCurrent();
   }
   
   // ‚úÖ Log de diagn√≥stico (apenas ocasionalmente)
   static int lastLoggedState = -1;
   static datetime lastLogTime = 0;
   datetime currentTime = TimeCurrent();
   
   if((state_idx != lastLoggedState && (currentTime - lastLogTime) > 300) || 
      g_totalTrades % 50 == 0)
   {
      PrintFormat("üìä Estado calculado: %d | RSI=%.1f(%d) | MA_dist=%.2f(%d) | ADX=%.1f(%d) | BB=%.2f(%d) | Vol=%d | Time=%d",
                  state_idx, rsi[0], rsiBucket, maDistance, maBucket, adx[0], adxBucket, 
                  bbPosition, bbBucket, volBucket, timeBucket);
      lastLoggedState = state_idx;
      lastLogTime = currentTime;
   }
   
   return state_idx;
}

// ======================================================================
// ‚úÖ FUN√á√ïES DE CONTROLE DE DIRE√á√ÉO
// ======================================================================
int GetCurrentPositionsDirection()
{
   int buyCount = 0;
   int sellCount = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      long type = PositionGetInteger(POSITION_TYPE);
      if(type == POSITION_TYPE_BUY) buyCount++;
      else if(type == POSITION_TYPE_SELL) sellCount++;
   }
   
   if(buyCount > 0 && sellCount == 0) return 1;
   if(sellCount > 0 && buyCount == 0) return 2;
   if(buyCount > 0 && sellCount > 0) return 3;
   return 0;
}

int GetTotalPositions()
{
   int count = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      count++;
   }
   
   return count;
}

bool CanOpenNewPosition(bool isBuy)
{
   if(AllowOnlyOneDirection)
   {
      int currentDir = GetCurrentPositionsDirection();
      
      if(currentDir == 3)
      {
         Print("‚ùå ERRO: Encontradas posi√ß√µes em ambas as dire√ß√µes!");
         return false;
      }
      
      if((currentDir == 1 && !isBuy) || (currentDir == 2 && isBuy))
      {
         if(CloseOppositeOnNewSignal)
         {
            Print("‚ö†Ô∏è Fechando posi√ß√µes na dire√ß√£o oposta para nova entrada...");
            CloseAllPositions();
            return true;
         }
         else if(WaitForAllCloseBeforeNew)
         {
            Print("‚è≥ Aguardando posi√ß√µes opostas fecharem...");
            return false;
         }
         else
         {
            Print("‚ùå J√° existe posi√ß√£o na dire√ß√£o oposta");
            return false;
         }
      }
      
      if((currentDir == 1 && isBuy) || (currentDir == 2 && !isBuy))
      {
         if(!EnablePyramiding)
         {
            Print("‚ùå Piramida√ß√£o desativada. J√° existe posi√ß√£o na mesma dire√ß√£o.");
            return false;
         }
         return CanPyramid(isBuy);
      }
   }
   else
   {
      if(GetTotalPositions() > 0)
      {
         return CanPyramid(isBuy);
      }
   }
   
   int sameDirCount = CountSameDirectionPositions(isBuy);
   if(sameDirCount >= MaxTradesPerDirection)
   {
      Print("‚ùå Limite m√°ximo de posi√ß√µes por dire√ß√£o atingido: ", sameDirCount, "/", MaxTradesPerDirection);
      return false;
   }
   
   if(sameDirCount > 0)
   {
      datetime lastTradeTime = isBuy ? g_lastBuyTime : g_lastSellTime;
      if(lastTradeTime > 0)
      {
         datetime currentTime = TimeCurrent();
         int secondsSinceLast = (int)(currentTime - lastTradeTime);
         int requiredSeconds = MinMinutesBetweenTrades * 60;
         
         if(secondsSinceLast < requiredSeconds)
         {
            Print("‚è≥ Aguardando tempo entre entradas na mesma dire√ß√£o: ", 
                  secondsSinceLast, "s/", requiredSeconds, "s");
            return false;
         }
      }
   }
   
   if(sameDirCount > 0 && MinBarsBetweenSameDirection > 0)
   {
      int barsSinceLast = BarsSinceLastEntry(isBuy);
      if(barsSinceLast >= 0 && barsSinceLast < MinBarsBetweenSameDirection)
      {
         Print("‚è≥ Aguardando mais barras para nova entrada na mesma dire√ß√£o: ",
               barsSinceLast, "/", MinBarsBetweenSameDirection, " barras");
         return false;
      }
   }
   
   Print("‚úÖ Pode abrir nova posi√ß√£o na dire√ß√£o: ", isBuy ? "BUY" : "SELL");
   return true;
}

int BarsSinceLastEntry(bool isBuy)
{
   datetime lastEntryTime = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      long type = PositionGetInteger(POSITION_TYPE);
      if((isBuy && type == POSITION_TYPE_BUY) || (!isBuy && type == POSITION_TYPE_SELL))
      {
         datetime entryTime = (datetime)PositionGetInteger(POSITION_TIME);
         if(entryTime > lastEntryTime) lastEntryTime = entryTime;
      }
   }
   
   if(lastEntryTime == 0) return -1;
   
   return Bars(_Symbol, _Period, lastEntryTime, TimeCurrent());
}

bool CloseAllPositions()
{
   bool allClosed = true;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      double currentPrice = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ? 
                           SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                           SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      if(!trade.PositionClose(ticket, (ulong)30))
      {
         Print("‚ùå Falha ao fechar posi√ß√£o #", ticket);
         allClosed = false;
      }
      else
      {
         Print("‚úÖ Posi√ß√£o #", ticket, " fechada");
      }
   }
   cachedPositions = -1;
   cachedDirection = -1;
   return allClosed;
}

// ======================================================================
// ‚úÖ FUN√á√ïES PARA STOPS
// ======================================================================
double CalculateSLByPoints(bool isBuy, double entryPrice)
{
   if(!UseFixedSL) return 0.0;
   
   int slPoints = FixedSL_Points;
   if(slPoints <= 0) return 0.0;
   
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double slDistance = slPoints * point;
   
   if(isBuy)
   {
      double slPrice = entryPrice - slDistance;
      Print("‚úÖ SL BUY calculado: Entry=", DoubleToString(entryPrice, 5), " - SL=", DoubleToString(slPrice, 5), 
            " (", slPoints, " pontos = ", DoubleToString(slDistance, 5), ")");
      return slPrice;
   }
   else
   {
      double slPrice = entryPrice + slDistance;
      Print("‚úÖ SL SELL calculado: Entry=", DoubleToString(entryPrice, 5), " + SL=", DoubleToString(slPrice, 5), 
            " (", slPoints, " pontos = ", DoubleToString(slDistance, 5), ")");
      return slPrice;
   }
}

double CalculateTPByPoints(bool isBuy, double entryPrice)
{
   if(!UseFixedTP) return 0.0;
   
   int tpPoints = FixedTP_Points;
   if(tpPoints <= 0) return 0.0;
   
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double tpDistance = tpPoints * point;
   
   if(isBuy)
   {
      double tpPrice = entryPrice + tpDistance;
      Print("‚úÖ TP BUY calculado: Entry=", DoubleToString(entryPrice, 5), " + TP=", DoubleToString(tpPrice, 5), 
            " (", tpPoints, " pontos = ", DoubleToString(tpDistance, 5), ")");
      return tpPrice;
   }
   else
   {
      double tpPrice = entryPrice - tpDistance;
      Print("‚úÖ TP SELL calculado: Entry=", DoubleToString(entryPrice, 5), " - TP=", DoubleToString(tpPrice, 5), 
            " (", tpPoints, " pontos = ", DoubleToString(tpDistance, 5), ")");
      return tpPrice;
   }
}

bool AreStopsValid(bool isBuy, double entryPrice, double slPrice, double tpPrice)
{
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   Print("=== VERIFICA√á√ÉO DE STOPS ===");
   Print("Dire√ß√£o: ", isBuy ? "BUY" : "SELL");
   Print("Entry: ", DoubleToString(entryPrice, 5));
   Print("SL: ", DoubleToString(slPrice, 5));
   Print("TP: ", DoubleToString(tpPrice, 5));
   
   if(UseFixedSL && slPrice > 0)
   {
      double slDistance = MathAbs(entryPrice - slPrice);
      double slPoints = slDistance / point;
      
      long minStopsLevel = (long)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
      double minSL = minStopsLevel * point;
      double minSLPoints = minSL / point;
      
      Print("SL Distance: ", DoubleToString(slDistance, 5), " (", DoubleToString(slPoints, 0), " pontos)");
      Print("Min SL required: ", DoubleToString(minSL, 5), " (", DoubleToString(minSLPoints, 0), " pontos)");
      
      if(slDistance < minSL && minSL > 0)
      {
         Print("‚ùå ERRO: SL muito pequeno!");
         return false;
      }
      
      if(isBuy)
      {
         if(slPrice >= entryPrice)
         {
            Print("‚ùå ERRO: SL inv√°lido para BUY! SL (", DoubleToString(slPrice, 5), ") >= Entry (", DoubleToString(entryPrice, 5), ")");
            return false;
         }
      }
      else
      {
         if(slPrice <= entryPrice)
         {
            Print("‚ùå ERRO: SL inv√°lido para SELL! SL (", DoubleToString(slPrice, 5), ") <= Entry (", DoubleToString(entryPrice, 5), ")");
            return false;
         }
      }
      
      Print("‚úÖ SL v√°lido: ", DoubleToString(slPoints, 0), " pontos");
   }
   
   if(UseFixedTP && tpPrice > 0)
   {
      double tpDistance = MathAbs(entryPrice - tpPrice);
      double tpPoints = tpDistance / point;
      
      long minStopsLevel = (long)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
      double minTP = minStopsLevel * point;
      double minTPPoints = minTP / point;
      
      Print("TP Distance: ", DoubleToString(tpDistance, 5), " (", DoubleToString(tpPoints, 0), " pontos)");
      Print("Min TP required: ", DoubleToString(minTP, 5), " (", DoubleToString(minTPPoints, 0), " pontos)");
      
      if(tpDistance < minTP && minTP > 0)
      {
         Print("‚ùå ERRO: TP muito pequeno!");
         return false;
      }
      
      if(isBuy)
      {
         if(tpPrice <= entryPrice)
         {
            Print("‚ùå ERRO: TP inv√°lido para BUY! TP (", DoubleToString(tpPrice, 5), ") <= Entry (", DoubleToString(entryPrice, 5), ")");
            return false;
         }
      }
      else
      {
         if(tpPrice >= entryPrice)
         {
            Print("‚ùå ERRO: TP inv√°lido para SELL! TP (", DoubleToString(tpPrice, 5), ") >= Entry (", DoubleToString(entryPrice, 5), ")");
            return false;
         }
      }
      
      Print("‚úÖ TP v√°lido: ", DoubleToString(tpPoints, 0), " pontos");
   }
   
   Print("=== STOPS VALIDADOS COM SUCESSO ===");
   return true;
}

// ======================================================================
// ‚úÖ FUN√á√ïES DE VALIDA√á√ÉO COM INDICADORES
// ======================================================================
bool ValidateWithRSI(bool isBuy)
{
   if(!UseRSIValidation) return true;
   
   double rsi[];
   ArraySetAsSeries(rsi, true);
   if(CopyBuffer(g_rsiHandle, 0, 0, 2, rsi) < 2) return false;
   
   double currentRSI = rsi[0];
   double previousRSI = rsi[1];
   
   if(isBuy)
   {
      if(currentRSI < RSI_Oversold) 
      {
         Print("‚úÖ RSI EXCELENTE para BUY: ", DoubleToString(currentRSI, 2), " (oversold)");
         return true;
      }
      
      if(currentRSI < 40 && currentRSI > previousRSI)
      {
         Print("‚úÖ RSI BOM para BUY: ", DoubleToString(currentRSI, 2), " (subindo de regi√£o baixa)");
         return true;
      }
      
      if(currentRSI < 50)
      {
         Print("‚úÖ RSI ACEIT√ÅVEL para BUY: ", DoubleToString(currentRSI, 2), " (abaixo de 50)");
         return true;
      }
      
      if(currentRSI > 85)
      {
         Print("‚ùå RSI inv√°lido para BUY: ", DoubleToString(currentRSI, 2), " (sobrecomprado extremo)");
         return false;
      }
      
      Print("‚ö†Ô∏è RSI neutro para BUY: ", DoubleToString(currentRSI, 2));
      return true;
   }
   else
   {
      if(currentRSI > RSI_Overbought)
      {
         Print("‚úÖ RSI EXCELENTE para SELL: ", DoubleToString(currentRSI, 2), " (sobrecomprado)");
         return true;
      }
      
      if(currentRSI > 60 && currentRSI < previousRSI)
      {
         Print("‚úÖ RSI BOM para SELL: ", DoubleToString(currentRSI, 2), " (caindo de regi√£o alta)");
         return true;
      }
      
      if(currentRSI > 50)
      {
         Print("‚úÖ RSI ACEIT√ÅVEL para SELL: ", DoubleToString(currentRSI, 2), " (acima de 50)");
         return true;
      }
      
      if(currentRSI < 15)
      {
         Print("‚ùå RSI inv√°lido para SELL: ", DoubleToString(currentRSI, 2), " (sobrevendido extremo)");
         return false;
      }
      
      Print("‚ö†Ô∏è RSI neutro para SELL: ", DoubleToString(currentRSI, 2));
      return true;
   }
}

bool ValidateWithBollingerBands(bool isBuy)
{
   if(!UseBBValidation) return true;
   
   double bb_upper[], bb_lower[];
   ArraySetAsSeries(bb_upper, true);
   ArraySetAsSeries(bb_lower, true);
   if(CopyBuffer(g_bbHandle, 0, 0, 1, bb_upper) < 1) return false;
   if(CopyBuffer(g_bbHandle, 2, 0, 1, bb_lower) < 1) return false;
   
   double price = SymbolInfoDouble(_Symbol, SYMBOL_LAST);
   double bb_range = bb_upper[0] - bb_lower[0];
   
   if(bb_range <= 0) return false;
   
   double bb_position = SafeDivide((price - bb_lower[0]), bb_range, 0.5);
   
   if(isBuy)
   {
      if(bb_position <= 0.7)
      {
         if(bb_position <= BB_LowerThreshold)
         {
            Print("‚úÖ BB EXCELENTE para BUY: posi√ß√£o ", DoubleToString(bb_position*100, 1), "% (pr√≥ximo da banda inferior)");
         }
         else if(bb_position <= 0.5)
         {
            Print("‚úÖ BB BOM para BUY: posi√ß√£o ", DoubleToString(bb_position*100, 1), "% (faixa inferior)");
         }
         else
         {
            Print("‚úÖ BB ACEIT√ÅVEL para BUY: posi√ß√£o ", DoubleToString(bb_position*100, 1), "% (metade inferior)");
         }
         return true;
      }
      else if(bb_position <= 0.9)
      {
         Print("‚ö†Ô∏è BB NEUTRO para BUY: posi√ß√£o ", DoubleToString(bb_position*100, 1), "% (cuidado)");
         return true;
      }
      else
      {
         Print("‚ùå BB muito alto para BUY: posi√ß√£o ", DoubleToString(bb_position*100, 1), "% (acima de 90%)");
         return false;
      }
   }
   else
   {
      if(bb_position >= 0.3)
      {
         if(bb_position >= BB_UpperThreshold)
         {
            Print("‚úÖ BB EXCELENTE para SELL: posi√ß√£o ", DoubleToString(bb_position*100, 1), "% (pr√≥ximo da banda superior)");
         }
         else if(bb_position >= 0.5)
         {
            Print("‚úÖ BB BOM para SELL: posi√ß√£o ", DoubleToString(bb_position*100, 1), "% (faixa superior)");
         }
         else
         {
            Print("‚úÖ BB ACEIT√ÅVEL para SELL: posi√ß√£o ", DoubleToString(bb_position*100, 1), "% (metade superior)");
         }
         return true;
      }
      else if(bb_position >= 0.1)
      {
         Print("‚ö†Ô∏è BB NEUTRO para SELL: posi√ß√£o ", DoubleToString(bb_position*100, 1), "% (cuidado)");
         return true;
      }
      else
      {
         Print("‚ùå BB muito baixo para SELL: posi√ß√£o ", DoubleToString(bb_position*100, 1), "% (abaixo de 10%)");
         return false;
      }
   }
}

bool ValidateWithADX()
{
   if(!UseADXValidation) return true;
   
   double adx[];
   ArraySetAsSeries(adx, true);
   if(CopyBuffer(g_adxHandle, 0, 0, 1, adx) < 1) return false;
   
   if(adx[0] >= MinADXStrength)
   {
      Print("‚úÖ ADX v√°lido: ", DoubleToString(adx[0], 1), " (for√ßa suficiente)");
      return true;
   }
   else if(adx[0] >= 15)
   {
      Print("‚ö†Ô∏è ADX moderado aceito: ", DoubleToString(adx[0], 1), " (abaixo do ideal, mas aceit√°vel)");
      return true;
   }
   else
   {
      Print("‚ùå ADX muito fraco: ", DoubleToString(adx[0], 1), " (m√≠nimo aceit√°vel: 15)");
      return false;
   }
}

bool ValidateWithTrend(bool isBuy)
{
   if(!UseTrendValidation) return true;
   
   double ma[], atr[];
   ArraySetAsSeries(ma, true);
   ArraySetAsSeries(atr, true);
   if(CopyBuffer(g_maHandle, 0, 0, 1, ma) < 1) return false;
   if(CopyBuffer(g_atrHandle, 0, 0, 1, atr) < 1) return false;
   
   double price = SymbolInfoDouble(_Symbol, SYMBOL_LAST);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   double atr_value = atr[0];
   if(atr_value < point * 10)
   {
      atr_value = price * 0.005;
   }
   
   double distance_from_ma = SafeDivide((price - ma[0]), atr_value, 0.0);
   
   if(isBuy)
   {
      if(distance_from_ma > -1.5 || distance_from_ma < -4.0) 
      {
         return true; 
      }
      else
      {
         Print("‚ùå Tend√™ncia inv√°lida para BUY: pre√ßo em zona morta (dist√¢ncia: ", DoubleToString(distance_from_ma, 2), " ATRs)");
         return false;
      }
   }
   else
   {
      if(distance_from_ma < 1.5 || distance_from_ma > 4.0) 
      {
         return true;
      }
      else
      {
         Print("‚ùå Tend√™ncia inv√°lida para SELL: pre√ßo em zona morta (dist√¢ncia: ", DoubleToString(distance_from_ma, 2), " ATRs)");
         return false;
      }
   }
}

bool CanTradeBasedOnTime()
{
   if(g_lastTradeTime == 0) return true;
   
   datetime currentTime = TimeCurrent();
   int secondsSinceLastTrade = (int)(currentTime - g_lastTradeTime);
   int requiredSeconds = MinMinutesBetweenTrades * 60;
   
   if(secondsSinceLastTrade < requiredSeconds)
   {
      Print("‚è≥ Aguardando tempo. Segundos desde √∫ltimo trade: ", secondsSinceLastTrade,
            " | Necess√°rios: ", requiredSeconds);
      return false;
   }
   
   return true;
}

bool CheckVolatility()
{
   if(!UseVolatilityFilter) return true;
   
   double atr[];
   ArraySetAsSeries(atr, true);
   if(CopyBuffer(g_atrHandle, 0, 0, 2, atr) < 2) return true;
   
   double currentATR = atr[0];
   double previousATR = atr[1];
   
   if(currentATR > (previousATR * MaxATRMultiplier))
   {
      Print("‚õî Volatilidade alta. ATR atual: ", DoubleToString(currentATR, 5),
            " | Anterior: ", DoubleToString(previousATR, 5));
      return false;
   }
   
   return true;
}

bool ValidateAllIndicators(bool isBuy)
{
   Print("=== VALIDA√á√ÉO DE INDICADORES PARA ", isBuy ? "BUY" : "SELL", " ===");
   
   if(!ValidateWithRSI(isBuy))
   {
      Print("‚ùå VALIDA√á√ÉO FALHOU: RSI");
      return false;
   }
   
   if(!ValidateWithBollingerBands(isBuy))
   {
      Print("‚ùå VALIDA√á√ÉO FALHOU: Bollinger Bands");
      return false;
   }
   
   if(!ValidateWithADX())
   {
      Print("‚ùå VALIDA√á√ÉO FALHOU: ADX");
      return false;
   }
   
   if(!ValidateWithTrend(isBuy))
   {
      Print("‚ùå VALIDA√á√ÉO FALHOU: Tend√™ncia MA");
      return false;
   }
   
   Print("‚úÖ TODOS OS INDICADORES VALIDADOS COM SUCESSO!");
   return true;
}

// ======================================================================
// ‚úÖ FUN√á√ïES DE PIRAMIDA√á√ÉO
// ======================================================================
int CountSameDirectionPositions(bool isBuy)
{
   int count = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      long type = PositionGetInteger(POSITION_TYPE);
      if(isBuy && type == POSITION_TYPE_BUY) count++;
      if(!isBuy && type == POSITION_TYPE_SELL) count++;
   }
   
   return count;
}

bool CanPyramid(bool isBuy)
{
   if(!EnablePyramiding) 
   {
      Print("‚ùå Piramida√ß√£o desativada nas configura√ß√µes");
      return false;
   }
   
   int sameDirCount = CountSameDirectionPositions(isBuy);
   
   Print("üìä Piramida√ß√£o: Contagem na dire√ß√£o ", isBuy ? "BUY" : "SELL", ": ", sameDirCount);
   
   if(sameDirCount >= MaxPyramidPositions)
   {
      Print("‚ùå PIRAMIDA√á√ÉO: Limite de ", MaxPyramidPositions, " posi√ß√µes por dire√ß√£o atingido");
      return false;
   }
   
   if(sameDirCount > 0)
   {
      double atr[];
      ArraySetAsSeries(atr, true);
      if(CopyBuffer(g_atrHandle, 0, 0, 1, atr) < 1) 
      {
         Print("‚ùå PIRAMIDA√á√ÉO: N√£o foi poss√≠vel obter o valor do ATR");
         return false;
      }
      
      double currentPrice = isBuy ? 
         SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
         SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      double minDistance = PyramidingDistanceATR * atr[0];
      
      Print("üìè Piramida√ß√£o: Dist√¢ncia m√≠nima necess√°ria: ", DoubleToString(minDistance, 5), " (", PyramidingDistanceATR, " ATRs)");
      
      for(int i = 0; i < PositionsTotal(); i++)
      {
         ulong ticket = PositionGetTicket(i);
         if(!PositionSelectByTicket(ticket)) continue;
         
         if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
         if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
         
         long type = PositionGetInteger(POSITION_TYPE);
         if((isBuy && type == POSITION_TYPE_BUY) || (!isBuy && type == POSITION_TYPE_SELL))
         {
            double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double distance = MathAbs(currentPrice - entryPrice);
            
            Print("üìê Piramida√ß√£o: Ticket #", ticket, " | Entry: ", DoubleToString(entryPrice, 5), 
                  " | Current: ", DoubleToString(currentPrice, 5), " | Distance: ", DoubleToString(distance, 5));
            
            if(distance < minDistance)
            {
               Print("‚ùå PIRAMIDA√á√ÉO: Posi√ß√£o muito pr√≥xima (", DoubleToString(distance, 5), " < ", DoubleToString(minDistance, 5), ")");
               return false;
            }
         }
      }
      
      Print("‚úÖ PIRAMIDA√á√ÉO: Condi√ß√µes atendidas para entrada #", sameDirCount + 1,
            " | Pre√ßo atual: ", DoubleToString(currentPrice, 5));
   }
   else
   {
      Print("‚úÖ PIRAMIDA√á√ÉO: Primeira entrada na dire√ß√£o ", isBuy ? "BUY" : "SELL");
   }
   
   return true;
}

double CalculatePyramidLot(bool isBuy)
{
   double baseLot = LotSize;
   int sameDirCount = CountSameDirectionPositions(isBuy);
   
   if(sameDirCount == 0) 
   {
      Print("üí∞ Piramida√ß√£o: Primeira entrada - Lote base: ", DoubleToString(baseLot, 2));
      return baseLot;
   }
   
   if(ReduceLotOnPyramiding)
   {
      double multiplier = MathPow(PyramidingLotMultiplier, sameDirCount);
      double pyramidLot = baseLot * multiplier;
      
      double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      if(pyramidLot < minLot) pyramidLot = minLot;
      
      Print("üí∞ PIRAMIDA√á√ÉO: Lote calculado: ", DoubleToString(baseLot, 2), " * ", DoubleToString(multiplier, 2), " = ", DoubleToString(pyramidLot, 2),
            " (entrada #", sameDirCount + 1, ")");
      
      return pyramidLot;
   }
   else
   {
      Print("üí∞ PIRAMIDA√á√ÉO: Lote fixo: ", DoubleToString(baseLot, 2),
            " (entrada #", sameDirCount + 1, ")");
      
      return baseLot;
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ NOVO SISTEMA DE APRENDIZADO INTELIGENTE
// ======================================================================

void InitializeLearningSystem()
{
   ArrayResize(g_stateWinRate, NUM_STATES);
   ArrayInitialize(g_stateWinRate, 0.0);
   
   ArrayResize(g_stateAvgProfit, NUM_STATES);
   ArrayInitialize(g_stateAvgProfit, 0.0);
   
   g_stateResets = 0;
   g_stateDecays = 0;
   g_lastDecayTradeCount = 0;
   g_totalDecayCycles = 0;
   g_totalBadStateResets = 0;
   
   Print("üß† Sistema de aprendizado inteligente inicializado (mem√≥ria otimizada com decay)");
}

double CalculateStateAverageProfit(int state)
{
   if(state < 0 || state >= NUM_STATES) return 0.0;
   if(g_stateVisits[state] < 5) return 0.0;
   
   double quality = GetStateQuality(state);
   
   double estimatedProfit = quality * 100.0;
   
   if(ArraySize(g_stateAvgProfit) > state)
   {
      g_stateAvgProfit[state] = estimatedProfit;
   }
   
   return estimatedProfit;
}

void UpdateStateStats(int state, double profit, int action)
{
   if(state < 0 || state >= NUM_STATES) return;
   if(ArraySize(g_stateWinRate) <= state) return;
   if(ArraySize(g_stateAvgProfit) <= state) return;
   
   double winRate = CalculateWinRate(state);
   g_stateWinRate[state] = winRate;
   
   double currentAvg = g_stateAvgProfit[state];
   int visits = g_stateVisits[state];
   
   if(visits > 0)
   {
      double alpha = 0.1;
      double newAvg = currentAvg * (1 - alpha) + profit * alpha;
      g_stateAvgProfit[state] = newAvg;
   }
   else
   {
      g_stateAvgProfit[state] = profit;
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ ‚úÖ‚úÖ‚úÖ OnTradeTransaction - CORRIGIDA COMPLETAMENTE (PONTO CR√çTICO)
// ======================================================================
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result)
{
   if(trans.type != TRADE_TRANSACTION_DEAL_ADD) return;
   if(trans.symbol != _Symbol) return;

   ulong deal_ticket = trans.deal;
   
   if(!HistoryDealSelect(deal_ticket)) return;

   long dmagic = HistoryDealGetInteger(deal_ticket, DEAL_MAGIC);
   if(dmagic != MagicNumber) return;

   long entry_type = HistoryDealGetInteger(deal_ticket, DEAL_ENTRY);
   if(entry_type != DEAL_ENTRY_OUT) return;

   // DEBUG: Logar todos os detalhes
   Print("=== ONTRADETRANSACTION CHAMADO ===");
   Print("Deal Ticket: ", deal_ticket);
   Print("g_lastTradeState: ", g_lastTradeState);
   Print("g_lastTradeAction: ", g_lastTradeAction);
   Print("g_lastTradeExecuted: ", g_lastTradeExecuted);

   double profit = HistoryDealGetDouble(deal_ticket, DEAL_PROFIT);
   double commission = HistoryDealGetDouble(deal_ticket, DEAL_COMMISSION);
   double swap = HistoryDealGetDouble(deal_ticket, DEAL_SWAP);
   double net_profit = profit + commission + swap;

   double reward = ComputeRewardFromTrade(net_profit);
   
   g_totalTrades++;
   g_sumProfit += net_profit;
   
   // ‚ö†Ô∏è DIAGN√ìSTICO DETALHADO
   Print("DIAGN√ìSTICO DETALHADO:");
   Print("net_profit: ", DoubleToString(net_profit, 2));
   Print("g_lastTradeAction: ", g_lastTradeAction, " (0=NOP, 1=BUY, 2=SELL)");
   Print("g_lastTradeState: ", g_lastTradeState);
   Print("g_lastTradeExecuted: ", g_lastTradeExecuted);
   
   if(g_lastTradeState >= 0 && g_lastTradeState < NUM_STATES)
   {
      Print("Estado v√°lido detectado: ", g_lastTradeState);
      Print("Visitas atuais: ", g_stateVisits[g_lastTradeState]);
      Print("Vit√≥rias atuais: ", g_stateWins[g_lastTradeState]);
      Print("Perdas atuais: ", g_stateLosses[g_lastTradeState]);
      
      // ‚ö†Ô∏è CORRE√á√ÉO DEFINITIVA: Contar APENAS se foi trade real (BUY/SELL)
      if(g_lastTradeAction == 1 || g_lastTradeAction == 2) // BUY ou SELL
      {
         g_stateVisits[g_lastTradeState]++;
         g_stateLastUpdate[g_lastTradeState] = g_totalTrades;
         
         if(net_profit > 0) 
         {
            g_totalWins++;
            g_stateWins[g_lastTradeState]++;
            Print("‚úÖ‚úÖ‚úÖ VIT√ìRIA REGISTRADA para estado ", g_lastTradeState);
         }
         else 
         {
            g_totalLosses++;
            g_stateLosses[g_lastTradeState]++;
            Print("‚ùå‚ùå‚ùå PERDA REGISTRADA para estado ", g_lastTradeState);
            
            if(EnableUnifiedBlockingSystem && g_stateVisits[g_lastTradeState] >= MinVisitsForBlockDecision)
            {
               EvaluateAndUpdateBlockState(g_lastTradeState);
            }
         }
         
         Print("P√ìS-ATUALIZA√á√ÉO Estado ", g_lastTradeState, ":");
         Print("  Visitas: ", g_stateVisits[g_lastTradeState]);
         Print("  Vit√≥rias: ", g_stateWins[g_lastTradeState]);
         Print("  Perdas: ", g_stateLosses[g_lastTradeState]);
      }
      else
      {
         Print("‚ö†Ô∏è NOP detectado - N√ÉO contando visita/perda");
      }
   }
   else
   {
      Print("‚ö†Ô∏è Estado inv√°lido ou n√£o definido");
   }
   
   g_lastTradeProfit = net_profit;
   g_lastTradeDate   = TimeCurrent();
   
   if(g_firstTradeDate == 0) g_firstTradeDate = TimeCurrent();
   
   UpdateProfitHistory(net_profit);
   
   if(g_lastTradeAction == 1 || g_lastTradeAction == 2)
   {
      UpdateDirectionStats(g_lastTradeAction == 1, net_profit);
   }
   
   UpdateStreaks(net_profit);
   
   if((g_lastTradeAction == 1 || g_lastTradeAction == 2) && g_lastTradeState >= 0)
   {
      UpdateStateStats(g_lastTradeState, net_profit, g_lastTradeAction);
      UpdateQ(g_lastTradeState, g_lastTradeAction, reward);
   }
   
   if(net_profit < 0) 
   {
      g_consecutiveLosses++;
      Print("üìâ Perda consecutiva #", g_consecutiveLosses);
   }
   else 
   {
      g_consecutiveLosses = 0;
      Print("üìà Vit√≥ria - resetando perdas consecutivas");
   }

   // Reset flags
   g_lastTradeState  = -1;
   g_lastTradeAction = 0;
   g_lastTradeExecuted = false;
   g_lastTradeStateExecuted = -1;
   
   if(GetTotalPositions() == 0)
   {
      g_currentDirection = 0;
      g_positionsCount = 0;
      cachedPositions = -1;
      cachedDirection = -1;
   }
   
   // Chamar diagn√≥stico a cada 10 trades
   if(g_totalTrades % 10 == 0)
   {
      DebugTradeCounting();
      MonitorBadStates();
   }
   
   // Chamar debug de bloqueio a cada 25 trades
   if(g_totalTrades % 25 == 0)
   {
      DebugBlockedStates();
   }
   
   // For√ßar save a cada trade cr√≠tico
   if(g_lastTradeAction == 1 || g_lastTradeAction == 2)
   {
      SaveState();
      SaveBrain();
   }
   
   Print("=== FIM ONTRADETRANSACTION ===");
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ïES PARA APRENDIZADO EVOLUTIVO
// ======================================================================

void UpdateLearningStats()
{
   g_totalStatesDiscovered = g_activeStatesCount;
   
   double sumQ = 0.0;
   int qCount = 0;
   g_maxQValue = -DBL_MAX;
   g_minQValue = DBL_MAX;
   
   for(int i = 0; i < NUM_STATES * NUM_ACTIONS; i++)
   {
      if(g_Q[i] != 0.0)
      {
         sumQ += g_Q[i];
         qCount++;
         if(g_Q[i] > g_maxQValue) g_maxQValue = g_Q[i];
         if(g_Q[i] < g_minQValue) g_minQValue = g_Q[i];
      }
   }
   
   if(qCount > 0)
   {
      g_averageQValue = SafeDivide(sumQ, (double)qCount, 0.0);
   }
   else
   {
      g_averageQValue = 0.0;
   }
}

void UpdateProfitHistory(double profit)
{
   if(ArraySize(g_recentProfits) < 100)
   {
      ArrayResize(g_recentProfits, 100);
      ArrayInitialize(g_recentProfits, 0.0);
   }
   
   g_recentProfits[g_recentProfitsIndex] = profit;
   g_recentProfitsIndex = (g_recentProfitsIndex + 1) % 100;
   
   if(profit > g_highestProfit) g_highestProfit = profit;
   if(profit < g_lowestProfit) g_lowestProfit = profit;
}

void UpdateDirectionStats(bool isBuy, double profit)
{
   if(isBuy)
   {
      g_totalBuys++;
      if(profit > 0) g_buyWins++;
      g_buyProfit += profit;
   }
   else
   {
      g_totalSells++;
      if(profit > 0) g_sellWins++;
      g_sellProfit += profit;
   }
}

void UpdateStreaks(double profit)
{
   if(profit > 0)
   {
      g_currentWinStreak++;
      g_currentLossStreak = 0;
      
      if(g_currentWinStreak > g_bestWinStreak)
      {
         g_bestWinStreak = g_currentWinStreak;
      }
   }
   else if(profit < 0)
   {
      g_currentLossStreak++;
      g_currentWinStreak = 0;
      
      if(g_currentLossStreak > g_worstLossStreak)
      {
         g_worstLossStreak = g_currentLossStreak;
      }
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO: EXPORTA√á√ÉO FOR√áADA (para chamar manualmente)
// ======================================================================
void ForceTextExport()
{
   if(ExportMemoryToTextFileFunc(true))
   {
      Print("‚úÖ Exporta√ß√£o for√ßada para texto realizada com sucesso!");
   }
   else
   {
      Print("‚ùå Falha na exporta√ß√£o for√ßada para texto");
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO: CRIAR RELAT√ìRIO RESUMIDO DI√ÅRIO
// ======================================================================
void CreateDailySummaryReport()
{
   string filename = "Phoenix_Files/Text_Logs/Daily_Summary_" + 
                     TimeToString(TimeCurrent(), TIME_DATE) + "_CORRIGIDO.txt";
   
   if(!CreateDirectoryForFile(filename)) return;
   
   int file_handle = FileOpen(filename, FILE_WRITE|FILE_TXT|FILE_ANSI|FILE_COMMON);
   if(file_handle == INVALID_HANDLE) return;
   
   FileWrite(file_handle, "================================================================");
   FileWrite(file_handle, "RELAT√ìRIO DI√ÅRIO - PHOENIX TRADER v307F SUPER CORRIGIDO");
   FileWrite(file_handle, "Data: " + TimeToString(TimeCurrent(), TIME_DATE));
   FileWrite(file_handle, "================================================================");
   FileWrite(file_handle, "");
   FileWrite(file_handle, "üìà RESUMO DO DIA (SISTEMA SUPER CORRIGIDO)");
   FileWrite(file_handle, "----------------------------------------");
   FileWrite(file_handle, "Trades REAIS Realizados: " + IntegerToString(g_tradesToday));
   FileWrite(file_handle, "Estados Ativos: " + IntegerToString(g_activeStatesCount));
   FileWrite(file_handle, "Estados Bloqueados: " + IntegerToString(CountBlockedStates()));
   FileWrite(file_handle, "Volume M√©dio Multiplicador: " + DoubleToString(g_volumeMultiplier, 2) + "x");
   FileWrite(file_handle, "Ciclos de Decay: " + IntegerToString(g_totalDecayCycles));
   FileWrite(file_handle, "Estados Resetados: " + IntegerToString(g_totalBadStateResets));
   FileWrite(file_handle, "");
   FileWrite(file_handle, "üß† PROGRESSO DO APRENDIZADO (SISTEMA SUPER CORRIGIDO)");
   FileWrite(file_handle, "----------------------------------------");
   double discoveryPercent = (double)g_activeStatesCount/NUM_STATES*100;
   FileWrite(file_handle, "Estados Descobertos: " + IntegerToString(g_activeStatesCount) + "/" + 
            IntegerToString(NUM_STATES) + " (" + DoubleToString(discoveryPercent, 1) + "%)");
   FileWrite(file_handle, "Taxa de Explora√ß√£o: " + DoubleToString(g_currentExplorationRate * 100, 1) + "%");
   FileWrite(file_handle, "Contagem Corrigida: " + IntegerToString(g_totalTrades) + " trades REAIS");
   FileWrite(file_handle, "");
   FileWrite(file_handle, "üõ°Ô∏è CORRE√á√ïES IMPLEMENTADAS:");
   FileWrite(file_handle, "1. ‚úÖ C√°lculo de estados corrigido (576 estados)");
   FileWrite(file_handle, "2. ‚úÖ Reset autom√°tico funcionando");
   FileWrite(file_handle, "3. ‚úÖ Estados n√£o travam mais em 10 visitas");
   FileWrite(file_handle, "4. ‚úÖ Regras de bloqueio mais agressivas");
   FileWrite(file_handle, "5. ‚úÖ Debug de estados travados implementado");
   FileWrite(file_handle, "");
   FileWrite(file_handle, "================================================================");
   FileWrite(file_handle, "FIM DO RELAT√ìRIO - SISTEMA SUPER CORRIGIDO v307F");
   FileWrite(file_handle, "================================================================");
   
   FileClose(file_handle);
   
   Print("üìã Relat√≥rio di√°rio criado: ", filename);
}

// ======================================================================
// ‚úÖ FUN√á√ïES ADICIONAIS QUE ESTAVAM FALTANDO
// ======================================================================

bool ShouldAutoExport()
{
   if(!EnableMemoryExport) return false;
   if(AutoExportMinutes <= 0) return false;
   
   datetime currentTime = TimeCurrent();
   if(g_lastExportTime == 0) 
   {
      g_lastExportTime = currentTime;
      return true;
   }
   
   int minutesPassed = (int)((currentTime - g_lastExportTime) / 60);
   return minutesPassed >= AutoExportMinutes;
}

bool ExportAllMemoryFiles()
{
   if(!EnableMemoryExport) return false;
   
   Print("üì§ Exportando arquivos de mem√≥ria...");
   
   if(!SaveBrain()) return false;
   
   g_lastExportTime = TimeCurrent();
   g_exportCount++;
   
   Print("‚úÖ Arquivos de mem√≥ria exportados com sucesso!");
   return true;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ ‚úÖ‚úÖ‚úÖ FUN√á√ÉO PRINCIPAL OnTick (COM SISTEMA SUPER CORRIGIDO E NOVAS FUN√á√ïES)
// ======================================================================
void OnTick()
{
   static datetime last_bar_time = 0;
   datetime current_bar_time = iTime(_Symbol,_Period,0);

   // ‚úÖ MONITORAMENTO DE PERFORMANCE A CADA 100 TICKS
   static int tickCounter = 0;
   tickCounter++;
   
   if(tickCounter % 100 == 0)
   {
      double currentWinRate = SafeDivide((double)g_totalWins, (double)g_totalTrades, 0.0);
      
      if(currentWinRate < 0.20)
      {
         Print("‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è ALERTA: Win rate cr√≠tica (", DoubleToString(currentWinRate*100,1), "%)");
         
         // Se performance muito ruim por muito tempo
         static int badPerformanceCounter = 0;
         badPerformanceCounter++;
         
         if(badPerformanceCounter >= 5)
         {
            Print("üî• ATIVA√á√ÉO DE CORRE√á√ÉO DE EMERG√äNCIA");
            EmergencyCounterFix();
            OverhaulBlockingSystem();
            badPerformanceCounter = 0;
         }
      }
      
      // Verificar bloqueios excessivos
      double blockedRatio = SafeDivide((double)CountBlockedStates(), (double)g_activeStatesCount, 0.0);
      if(blockedRatio > 0.7 && g_activeStatesCount > 50)
      {
         Print("‚ö†Ô∏è Muitos estados bloqueados (", DoubleToString(blockedRatio*100,1), "%)");
         IntelligentPartialReset();
      }
   }

   // ‚úÖ CHAMAR CORRE√á√ïES A CADA HORA
   static datetime lastMaintenanceCall = 0;
   if(TimeCurrent() - lastMaintenanceCall >= 3600)
   {
      PerformMemoryMaintenance();
      
      // ‚úÖ OTIMIZA√á√ÉO DIN√ÇMICA
      OptimizeParametersDynamically();
      
      // ‚úÖ CHAMAR CORRE√á√ÉO ESPEC√çFICA
      FixStuckStatesProblem();
      
      lastMaintenanceCall = TimeCurrent();
   }

   if(UseDynamicTrailingStop)
   {
      ManageAllDynamicStops();
   }

   if(current_bar_time != last_bar_time)
   {
      last_bar_time = current_bar_time;
      
      // ‚úÖ DEBUG PERI√ìDICO MELHORADO
      static int debugCounter = 0;
      debugCounter++;
      
      if(debugCounter % 50 == 0)
      {
         DebugStuckStatesEnhanced();
      }
      
      if(debugCounter % 100 == 0)
      {
         ResetBadStatesEnhanced();
      }

      MqlDateTime today,last;
      TimeToStruct(TimeCurrent(),today);
      TimeToStruct(g_lastResetDate,last);

      bool new_day = (g_lastResetDate==0) ||
                     (today.day != last.day ||
                      today.mon != last.mon ||
                      today.year != last.year);

      if(new_day)
      {
         g_tradesToday=0;
         g_consecutiveLosses=0;
         g_lastResetDate=TimeCurrent();
         cachedTradesToday = -1;
         
         // ‚úÖ RESET PARCIAL DO SISTEMA DE BLOQUEIO A CADA DIA
         ResetBadStatesEnhanced();
         
         if(EnableTextExport)
         {
            CreateDailySummaryReport();
         }
      }

      if(g_tradesToday >= MaxTradesPerDay)
      {
         g_statusMessage = StringFormat("‚õî Limite di√°rio (%d) atingido", MaxTradesPerDay);
      }
      else if(g_consecutiveLosses >= ConsecutiveLossLimit)
      {
         g_statusMessage = StringFormat("‚õî %d perdas consecutivas", ConsecutiveLossLimit);
      }
      else
      {
         g_statusMessage = "Analisando (Sistema Corrigido v2)";
            
         int s = GetCurrentState();
         if(s < 0)
         {
            g_statusMessage = "Aguardando dados dos indicadores";
         }
         else
         {
            // ‚úÖ VERIFICA√á√ÉO DE BLOQUEIO MAIS INTELIGENTE
            if(IsStateBlocked(s))
            {
               double winRate = CalculateWinRate(s);
               
               // Auto-desbloqueio se performance melhorou
               if(winRate >= 0.35 && g_stateVisits[s] >= 5)
               {
                  g_stateBlocked[s] = false;
                  Print("üîÑ AUTO-DESBLOQUEIO Estado ", s, 
                        " | Win Rate: ", DoubleToString(winRate*100,1), "%");
               }
               else
               {
                  g_statusMessage = StringFormat("‚õî Estado %d bloqueado", s);
                  UpdateQ_NOP(s);
                  return;
               }
            }
            
            int a = ChooseAction(s);
            
            if(a == 0)
            {
               g_statusMessage = "NOP (An√°lise)";
               UpdateQ_NOP(s);
            }
            else
            {
               ExecuteAction(a,s);
            }
         }
      }
   }

   UpdateHUDLight();
   
   static datetime lastTextExportCheck = 0;
   datetime currentTime = TimeCurrent();
   if(currentTime - lastTextExportCheck >= 60)
   {
      lastTextExportCheck = currentTime;
      ExportMemoryToTextFileFunc(false);
   }
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ FUN√á√ÉO ExportMemoryToTextFileFunc (ATUALIZADA)
// ======================================================================
bool ExportMemoryToTextFileFunc(bool forceExport = false)
{
   if(!EnableTextExport && !forceExport) return false;
   
   datetime currentTime = TimeCurrent();
   if(!forceExport && g_lastTextExportTime > 0)
   {
      int minutesPassed = (int)((currentTime - g_lastTextExportTime) / 60);
      if(minutesPassed < TextExportMinInterval) return false;
   }
   
   string filename = "Phoenix_Files/Text_Logs/Memory_" + _Symbol + "_" + 
                     EnumToString((ENUM_TIMEFRAMES)_Period) + "_" + 
                     TimeToString(currentTime, TIME_DATE) + "_SUPER_CORRIGIDO.txt";
   
   if(!CreateDirectoryForFile(filename))
   {
      Print("‚ùå Erro ao criar diret√≥rio para arquivo texto: ", filename);
      return false;
   }
   
   int file_handle = FileOpen(filename, FILE_WRITE|FILE_TXT|FILE_ANSI|FILE_COMMON);
   if(file_handle == INVALID_HANDLE)
   {
      Print("‚ùå Erro ao abrir arquivo texto: ", filename, " | Erro: ", GetLastError());
      return false;
   }
   
   FileWrite(file_handle, "=================================================================");
   FileWrite(file_handle, "PHOENIX TRADER v307F - SISTEMA SUPER CORRIGIDO");
   FileWrite(file_handle, "Data/Hora: " + TimeToString(currentTime));
   FileWrite(file_handle, "Symbol: " + _Symbol + " | Timeframe: " + EnumToString((ENUM_TIMEFRAMES)_Period));
   FileWrite(file_handle, "=================================================================");
   FileWrite(file_handle, "");
   FileWrite(file_handle, "üõ°Ô∏è SISTEMA SUPER CORRIGIDO - MELHORIAS IMPLEMENTADAS");
   FileWrite(file_handle, "----------------------------------------");
   FileWrite(file_handle, "‚úÖ CORRE√á√ïES CR√çTICAS IMPLEMENTADAS:");
   FileWrite(file_handle, "1. ‚úÖ C√°lculo de estados corrigido (576 estados)");
   FileWrite(file_handle, "2. ‚úÖ Reset autom√°tico funcionando");
   FileWrite(file_handle, "3. ‚úÖ Estados n√£o travam mais em 10 visitas");
   FileWrite(file_handle, "4. ‚úÖ Regras de bloqueio mais agressivas");
   FileWrite(file_handle, "5. ‚úÖ Debug de estados travados implementado");
   FileWrite(file_handle, "6. ‚úÖ Reset de emerg√™ncia dispon√≠vel");
   FileWrite(file_handle, "");
   
   string systemInfo = "Estados totais poss√≠veis: " + IntegerToString(NUM_STATES) + " (3√ó4√ó2√ó3√ó2√ó2√ó2 = 576)";
   FileWrite(file_handle, systemInfo);
   
   string activeInfo = "Estados ativos na mem√≥ria: " + IntegerToString(g_activeStatesCount);
   FileWrite(file_handle, activeInfo);
   
   string blockedInfo = "Estados bloqueados: " + IntegerToString(CountBlockedStates());
   FileWrite(file_handle, blockedInfo);
   
   double discoveryRate = (double)g_activeStatesCount / NUM_STATES * 100;
   string discoveryInfo = "Taxa de descoberta: " + DoubleToString(discoveryRate, 1) + "%";
   FileWrite(file_handle, discoveryInfo);
   
   string decayInfo = "Ciclos de decay: " + IntegerToString(g_totalDecayCycles);
   FileWrite(file_handle, decayInfo);
   
   string resetInfo = "Estados resetados: " + IntegerToString(g_totalBadStateResets);
   FileWrite(file_handle, resetInfo);
   
   if(IncludeStatistics)
   {
      FileWrite(file_handle, "");
      FileWrite(file_handle, "üìä ESTAT√çSTICAS GERAIS (SISTEMA SUPER CORRIGIDO)");
      FileWrite(file_handle, "----------------------------------------");
      
      string totalTrades = "Total de Trades REAIS: " + IntegerToString(g_totalTrades);
      FileWrite(file_handle, totalTrades);
      
      if(g_totalTrades > 0)
      {
         double winRate = SafeDivide((double)g_totalWins, (double)g_totalTrades, 0.0) * 100;
         double lossRate = SafeDivide((double)g_totalLosses, (double)g_totalTrades, 0.0) * 100;
         
         string winsInfo = "  Vit√≥rias REAIS: " + IntegerToString(g_totalWins) + 
                          " (" + DoubleToString(winRate, 1) + "%)";
         FileWrite(file_handle, winsInfo);
         
         string lossesInfo = "  Derrotas REAIS: " + IntegerToString(g_totalLosses) + 
                           " (" + DoubleToString(lossRate, 1) + "%)";
         FileWrite(file_handle, lossesInfo);
         
         // Verifica√ß√£o de integridade
         int soma = g_totalWins + g_totalLosses;
         int diferenca = g_totalTrades - soma;
         FileWrite(file_handle, "  Soma Wins+Losses: " + IntegerToString(soma));
         FileWrite(file_handle, "  Diferen√ßa (NOPs): " + IntegerToString(diferenca));
      }
      else
      {
         FileWrite(file_handle, "  Vit√≥rias: 0 (0.0%)");
         FileWrite(file_handle, "  Derrotas: 0 (0.0%)");
      }
      
      string totalProfit = "Lucro Total: " + DoubleToString(g_sumProfit, 2);
      FileWrite(file_handle, totalProfit);
      
      string tradesToday = "Trades Hoje: " + IntegerToString(g_tradesToday) + "/" + IntegerToString(MaxTradesPerDay);
      FileWrite(file_handle, tradesToday);
      
      string consecutiveLosses = "Perdas Consecutivas: " + IntegerToString(g_consecutiveLosses) + 
                               "/" + IntegerToString(ConsecutiveLossLimit);
      FileWrite(file_handle, consecutiveLosses);
      
      // ‚ö†Ô∏è GARANTIR QUE EXPLORA√á√ÉO N√ÉO PASSE DE 100%
      double exploration = MathMin(g_currentExplorationRate * 100, 100.0);
      string explorationStr = "Taxa Explora√ß√£o: " + DoubleToString(exploration, 1) + "%";
      FileWrite(file_handle, explorationStr);
   }
   
   FileWrite(file_handle, "");
   FileWrite(file_handle, "üìà TOP 20 ESTADOS MAIS VISITADOS (SISTEMA SUPER CORRIGIDO)");
   FileWrite(file_handle, "----------------------------------------");
   
   int sortedStates[][2];
   ArrayResize(sortedStates, g_activeStatesCount);
   
   for(int i = 0; i < g_activeStatesCount; i++)
   {
      int state = g_activeStates[i];
      sortedStates[i][0] = state;
      sortedStates[i][1] = g_stateVisits[state];
   }
   
   for(int i = 0; i < g_activeStatesCount - 1; i++)
   {
      for(int j = i + 1; j < g_activeStatesCount; j++)
      {
         if(sortedStates[j][1] > sortedStates[i][1])
         {
            int tempState = sortedStates[i][0];
            int tempVisits = sortedStates[i][1];
            
            sortedStates[i][0] = sortedStates[j][0];
            sortedStates[i][1] = sortedStates[j][1];
            
            sortedStates[j][0] = tempState;
            sortedStates[j][1] = tempVisits;
         }
      }
   }
   
   int limit = MathMin(20, g_activeStatesCount);
   for(int i = 0; i < limit; i++)
   {
      int state = sortedStates[i][0];
      int visits = sortedStates[i][1];
      int losses = g_stateLosses[state];
      int wins = g_stateWins[state];
      double winRate = SafeDivide((double)wins, (double)visits, 0.0) * 100;
      bool isBlocked = g_stateBlocked[state];
      
      string stateLine = IntegerToString(i+1) + ". Estado " + IntegerToString(state) + 
                        ": " + IntegerToString(visits) + " visitas REAIS | " + 
                        IntegerToString(wins) + " vit√≥rias REAIS (" + 
                        DoubleToString(winRate, 1) + "%) | " + 
                        IntegerToString(losses) + " perdas REAIS" + 
                        (isBlocked ? " [BLOQUEADO]" : "");
      FileWrite(file_handle, stateLine);
   }
   
   FileWrite(file_handle, "");
   FileWrite(file_handle, "=================================================================");
   FileWrite(file_handle, "FIM DA EXPORTA√á√ÉO - SISTEMA SUPER CORRIGIDO v307F");
   FileWrite(file_handle, "=================================================================");
   
   FileClose(file_handle);
   
   g_lastTextExportTime = currentTime;
   g_textExportCount++;
   
   Print("üìÑ Mem√≥ria exportada para texto: ", filename, 
         " | Estados: ", g_activeStatesCount,
         " | Bloqueados: ", CountBlockedStates(),
         " | Trades reais: ", g_totalTrades,
         " | Ciclos decay: ", g_totalDecayCycles,
         " | Resets: ", g_totalBadStateResets);
   
   return true;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ ‚úÖ‚úÖ‚úÖ OnInit (COM SISTEMA SUPER CORRIGIDO)
// ======================================================================
int OnInit()
{
   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetTypeFillingBySymbol(_Symbol);
   trade.SetDeviationInPoints(30);

   MathSrand((int)GetTickCount64());

   g_maHandle      = iMA(_Symbol, _Period, MAPeriod, 0, MAMethod, PRICE_CLOSE);
   g_adxHandle     = iADX(_Symbol, _Period, 20);
   g_rsiHandle     = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);
   g_bbHandle      = iBands(_Symbol, _Period, BBPeriod, 0, BBDeviation, PRICE_CLOSE);
   g_atrHandle     = iATR(_Symbol, _Period, ATRPeriod);

   if(g_maHandle == INVALID_HANDLE || g_adxHandle == INVALID_HANDLE ||
      g_rsiHandle == INVALID_HANDLE || g_bbHandle == INVALID_HANDLE ||
      g_atrHandle == INVALID_HANDLE)
   {
      Print("‚ùå Falha ao criar indicadores");
      return INIT_FAILED;
   }

   int sz = NUM_STATES * NUM_ACTIONS;
   ArrayResize(g_Q, sz);
   ArrayInitialize(g_Q, 0.0);
   
   ArrayResize(g_stateVisits, NUM_STATES);
   ArrayInitialize(g_stateVisits, 0);
   
   ArrayResize(g_stateLosses, NUM_STATES);
   ArrayInitialize(g_stateLosses, 0);
   
   ArrayResize(g_stateWins, NUM_STATES);
   ArrayInitialize(g_stateWins, 0);
   
   ArrayResize(g_stateLastUpdate, NUM_STATES);
   ArrayInitialize(g_stateLastUpdate, 0);
   
   ArrayResize(g_stateBlocked, NUM_STATES);
   ArrayInitialize(g_stateBlocked, false);
   
   ArrayResize(g_stateLastBlockTime, NUM_STATES);
   ArrayInitialize(g_stateLastBlockTime, 0);
   
   ArrayResize(g_stateLastUnblockTime, NUM_STATES);
   ArrayInitialize(g_stateLastUnblockTime, 0);
   
   ArrayResize(g_activeStates, MaxMemoryStates);
   g_activeStatesCount = 0;

   LoadState();

   if(!LoadBrain())
   {
      g_currentExplorationRate = MathMax(InitialExplorationRate, 0.40);
      g_memoryInitialized = true;
      SaveBrain();
      Print("‚úÖ Novo c√©rebro criado (Sistema Super Corrigido v307F)");
   }
   else
   {
      g_memoryInitialized = true;
      Print("‚úÖ C√©rebro existente carregado (Sistema Super Corrigido v307F)");
   }
   
   ArrayResize(g_recentProfits, 100);
   ArrayInitialize(g_recentProfits, 0.0);
   g_recentProfitsIndex = 0;
   
   g_currentVolume = 0;
   g_volumeAverage = 0;
   g_volumeMultiplier = 1.0;
   g_volumeStrength = 0.0;
   
   UpdateLearningStats();
   
   g_statusMessage = "Inicializando Sistema Super Corrigido v307F...";
   
   g_lastSaveTime  = TimeCurrent();
   g_lastEntryTime = 0;
   g_lastTradeTime = 0;
   g_lastBuyTime = 0;
   g_lastSellTime = 0;
   g_lastBarProcessed = 0;
   g_lastExportTime = 0;
   g_exportCount = 0;
   g_currentDirection = 0;
   g_positionsCount = 0;

   g_currentDirection = GetCurrentPositionsDirection();
   g_positionsCount = GetTotalPositions();
   
   if(g_currentDirection == 3)
   {
      Print("‚ö†Ô∏è ATEN√á√ÉO: Encontradas posi√ß√µes em ambas as dire√ß√µes!");
      if(CloseOppositeOnNewSignal) CloseAllPositions();
   }

   Print("üî•üî•üî• INICIALIZANDO SISTEMA SUPER CORRIGIDO...");
   Print("üî•üî•üî• CONFIGURA√á√ÉO DE ESTADOS:");
   Print("üî•üî•üî• Bins por indicador:");
   Print("üî•üî•üî• MA Distance: ", BINS_MA_DIST);
   Print("üî•üî•üî• RSI: ", BINS_RSI);
   Print("üî•üî•üî• ADX: ", BINS_ADX);
   Print("üî•üî•üî• BB Position: ", BINS_BBPOS);
   Print("üî•üî•üî• Volatilidade: ", BINS_VOLATILITY);
   Print("üî•üî•üî• Volume: ", BINS_VOLUME);
   Print("üî•üî•üî• Tempo: ", BINS_TIME);
   Print("üî•üî•üî• TOTAL DE ESTADOS: ", NUM_STATES, " (3√ó4√ó2√ó3√ó2√ó2√ó2 = 576)");
   Print("üî•üî•üî• MEM√ìRIA M√ÅXIMA: ", MaxMemoryStates, " estados ativos");
   Print("üî•üî•üî• SISTEMA SUPER CORRIGIDO: ATIVADO");
   
   // ‚úÖ CONFIGURA√á√ïES OTIMIZADAS FOR√áADAS:
   g_currentExplorationRate = 0.40; // For√ßar 40% em vez de 70%
   Print("‚öôÔ∏è Configura√ß√µes otimizadas for√ßadas:");
   Print("   ‚Ä¢ Exploration Rate: 40%");
   Print("   ‚Ä¢ MinVisitsToTrade: 2");
   Print("   ‚Ä¢ BadStateMinVisits: 3");
   Print("   ‚Ä¢ BadStateLossThreshold: 60%");
   
   if(EnableUnifiedBlockingSystem)
   {
      AutoUnblockGoodStates();
   }

   if(EnableMemoryExport) ExportAllMemoryFiles();

   Print("===============================================================");
   Print("‚úÖ PHOENIX TRADER V307F - SISTEMA SUPER CORRIGIDO V2");
   Print("===============================================================");
   Print("üî¥ CORRE√á√ïES EXTREMAS IMPLEMENTADAS:");
   Print("   1. ‚úÖ REMO√á√ÉO COMPLETA do limite de 10 visitas");
   Print("   2. ‚úÖ Auto-desbloqueio de estados com win rate > 35%");
   Print("   3. ‚úÖ Reset parcial em vez de completo");
   Print("   4. ‚úÖ Corre√ß√£o autom√°tica de estados travados");
   Print("   5. ‚úÖ Sistema anti-bloqueio-erroneo ativado");
   Print("üî• NOVAS FUN√á√ïES ADICIONADAS:");
   Print("   ‚Ä¢ EmergencyCounterFix() - Corre√ß√£o emergencial de contadores");
   Print("   ‚Ä¢ OverhaulBlockingSystem() - Revis√£o completa do bloqueio");
   Print("   ‚Ä¢ IntelligentPartialReset() - Reset parcial inteligente");
   Print("   ‚Ä¢ OptimizeParametersDynamically() - Otimiza√ß√£o din√¢mica");
   Print("===============================================================");
   
   // ‚úÖ EXECUTAR CORRE√á√ÉO INICIAL
   FixStuckStatesProblem();
   ResetBlockingSystem();
   
   if(ShowHUD)
   {
      CreateHUDObjects();
      ChartRedraw(0);
      Print("üñ•Ô∏è HUD inicializado com ", hudObjectCount, " objetos");
   }
   
   g_statusMessage = "Pronto para operar (Sistema Super Corrigido v307F)";
   
   return INIT_SUCCEEDED;
}

// ======================================================================
// ‚úÖ‚úÖ‚úÖ OnDeinit (COM SISTEMA SUPER CORRIGIDO)
// ======================================================================
void OnDeinit(const int reason)
{
   Print("üíæ Salvando mem√≥ria antes de fechar...");
   
   if(g_memoryInitialized)
   {
      SaveBrain();
   }
   
   SaveState();
   
   if(CreateBackupFiles)
   {
      string finalBackup = "Phoenix_Files/Backups/final_backup_" + 
                          TimeToString(TimeCurrent(), TIME_DATE) + "_SUPER_CORRIGIDO.bin";
      SaveBrainToFile(finalBackup);
   }
   
   if(EnableTextExport)
   {
      ExportMemoryToTextFileFunc(true);
   }
   
   IndicatorRelease(g_maHandle);
   IndicatorRelease(g_adxHandle);
   IndicatorRelease(g_rsiHandle);
   IndicatorRelease(g_bbHandle);
   IndicatorRelease(g_atrHandle);

   RemoveHUD();
}
