//+------------------------------------------------------------------+
//|                         Phoenix_Trader_v307_FIXED_CORRIGIDO.mq5  |
//|          CONTAGEM CORRIGIDA + DECAY FUNCIONAL + EXPLORAÃ‡ÃƒO LIMITADA |
//|                  COM SISTEMA DE MEMÃ“RIA OTIMIZADA COMPLETA       |
//|                      SISTEMA DE BLOQUEIO UNIFICADO              |
//|                             ESTADOS VARIADOS v307F_ESTADOS       |
//|                + SISTEMA DE DECAY E RESET INTELIGENTE           |
//|                  + CORREÃ‡Ã•ES CRÃTICAS IMPLEMENTADAS             |
//|               + CORREÃ‡Ã•ES EXTREMAS PARA ESTADOS TRAVADOS        |
//+------------------------------------------------------------------+
#property copyright "Phoenix Trader"
#property link      ""
#property version   "3.07"

// ====
// Includes essenciais
// ====
#include <Trade/Trade.mqh>
#include <Trade/PositionInfo.mqh>
#include <Trade/OrderInfo.mqh>
#include <Trade/DealInfo.mqh>
#include <Trade/HistoryOrderInfo.mqh>

// ====
// âœ… PASSO 1 â€” CRIAR MEMÃ“RIA PERSISTENTE (OBRIGATÃ“RIO)
// ====
#define STATE_FILE "Phoenix_Files/Backups/state_memory.bin"

// ====
// Objetos utilitÃ¡rios
// ====
CTrade          trade;
CPositionInfo   positionInfo;
COrderInfo      orderInfo;
CDealInfo       dealInfo;
CHistoryOrderInfo historyOrderInfo;

// ====
// âœ…âœ…âœ… ATUALIZAÃ‡ÃƒO CRÃTICA: DISCRETIZAÃ‡ÃƒO DE ESTADO OTIMIZADA
// ============================================================
// Reduzindo para um nÃºmero gerenciÃ¡vel de estados
#define BINS_MA_DIST   3      // Reduzido de 6 para 3
#define BINS_RSI       4      // Reduzido de 6 para 4  
#define BINS_ADX       2      // Mantido 2
#define BINS_BBPOS     3      // Reduzido de 6 para 3
#define BINS_VOLATILITY 2     // Mantido 2
#define BINS_VOLUME    2      // Reduzido de 3 para 2
#define BINS_TIME      2      // Reduzido de 4 para 2

// CÃ¡lculo do nÃºmero total de estados - DEVE SER 576
#define NUM_STATES (BINS_MA_DIST * BINS_RSI * BINS_ADX * BINS_BBPOS * BINS_VOLATILITY * BINS_VOLUME * BINS_TIME)

#define NUM_ACTIONS 3  // 0:NOP, 1:Buy, 2:Sell

// ============================================================
// âœ… CONSTANTES CRÃTICAS - APRENDIZADO CORRIGIDO
// ============================================================
const int MIN_VISITS_FOR_BLOCK = 30;

// âœ… CONSTANTE PARA BOLLINGER BANDS
// Quando a banda tem range zero (invÃ¡lida), usar 0.5 (meio da banda)
// como valor neutro, indicando que o preÃ§o estÃ¡ no centro
const double BB_NEUTRAL_POSITION = 0.5;

// PersistÃªncia
#define FILE_MAGIC   0x50484F45
#define FILE_VERSION 3073

#ifndef INT_MAX
  #define INT_MAX 2147483647
#endif
#ifndef DBL_MAX
  #define DBL_MAX 1.7e308
#endif

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“‹ PARÃ‚METROS DE ENTRADA - ORGANIZADOS POR CATEGORIA
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ›¡ï¸ 1. CONTROLE DE RISCO E LIMITES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
input group "â”€â”€â”€â”€ ğŸ›¡ï¸ LIMITES DIÃRIOS â”€â”€â”€â”€";
input int    MaxTradesPerDay          = 30;           // MÃ¡ximo de trades por dia
input int    ConsecutiveLossLimit     = 15;           // Limite de perdas consecutivas

input group "â”€â”€â”€â”€ ğŸ’° NEGOCIAÃ‡ÃƒO BÃSICA â”€â”€â”€â”€";
input double LotSize                  = 0.01;         // Tamanho do lote padrÃ£o
input int    MagicNumber              = 27101;        // NÃºmero mÃ¡gico das ordens
input int    MinMinutesBetweenTrades  = 3;            // Tempo mÃ­nimo entre trades

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ˆ 2. INDICADORES TÃ‰CNICOS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
input group "â”€â”€â”€â”€ ğŸ“Š INDICADORES PRINCIPAIS â”€â”€â”€â”€";
input int    MAPeriod                 = 200;          // PerÃ­odo da MÃ©dia MÃ³vel
input ENUM_MA_METHOD  MAMethod        = MODE_EMA;     // Tipo da MÃ©dia MÃ³vel
input int    RSIPeriod                = 20;           // PerÃ­odo do RSI
input int    BBPeriod                 = 24;           // PerÃ­odo das Bandas de Bollinger
input double BBDeviation              = 2.2;          // Desvio das Bandas de Bollinger
input int    ATRPeriod                = 18;           // PerÃ­odo do ATR

input group "â”€â”€â”€â”€ âœ… VALIDAÃ‡Ã•ES DE INDICADORES â”€â”€â”€â”€";
input bool   UseRSIValidation         = true;         // Usar validaÃ§Ã£o por RSI
input double RSI_Overbought           = 75.0;         // RSI sobrecomprado
input double RSI_Oversold             = 25.0;         // RSI sobrevendido
input bool   UseBBValidation          = true;         // Usar validaÃ§Ã£o por BB
input double BB_UpperThreshold        = 0.7;          // Threshold superior BB
input double BB_LowerThreshold        = 0.3;          // Threshold inferior BB
input bool   UseADXValidation         = true;         // Usar validaÃ§Ã£o por ADX
input double MinADXStrength           = 20.0;         // ForÃ§a mÃ­nima do ADX
input bool   UseTrendValidation       = true;         // Usar validaÃ§Ã£o de tendÃªncia
input double MinDistanceFromMA        = 0.3;          // DistÃ¢ncia mÃ­nima da MA

input group "â”€â”€â”€â”€ ğŸ“Š FILTRO DE VOLUME â”€â”€â”€â”€";
input bool   UseRealVolumeFilter      = true;         // Usar filtro de volume
input int    VolumeMAPeriod           = 15;           // PerÃ­odo MA de volume
input double MinVolumeMultiplier      = 0.5;          // Multiplicador mÃ­nimo de volume

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ¯ 3. GESTÃƒO DE STOPS E ALVOS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
input group "â”€â”€â”€â”€ ğŸ›‘ STOP LOSS (PONTOS) â”€â”€â”€â”€";
input bool   UseFixedSL               = true;         // Usar stop loss fixo
input int    FixedSL_Points           = 35000;        // Stop loss em pontos

input group "â”€â”€â”€â”€ ğŸ¯ TAKE PROFIT (PONTOS) â”€â”€â”€â”€";
input bool   UseFixedTP               = true;         // Usar take profit fixo
input int    FixedTP_Points           = 70000;        // Take profit em pontos

input group "â”€â”€â”€â”€ ğŸ¯ TRAILING STOP DINÃ‚MICO â”€â”€â”€â”€";
input bool   UseDynamicTrailingStop   = false;        // Usar trailing stop dinÃ¢mico
input int    TrailingStopPoints       = 20000;        // Trailing stop em pontos
input int    TrailingStepPoints       = 5000;         // Passo do trailing em pontos
input int    TrailingStartPoints      = 10000;        // InÃ­cio do trailing em pontos
input bool   UseATRTrailing           = false;        // Usar ATR para trailing
input double ATRTrailingMultiplier    = 2.5;          // Multiplicador ATR trailing
input bool   UseBreakevenStop         = false;        // Usar breakeven
input int    BreakevenTriggerPoints   = 15000;        // Trigger do breakeven em pontos
input bool   TrailBothSLandTP         = false;        // Trailing em SL e TP

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ’¼ 4. GESTÃƒO DE POSIÃ‡Ã•ES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
input group "â”€â”€â”€â”€ ğŸ’ BET SIZING INTELIGENTE â”€â”€â”€â”€";
input bool   EnableSmartLot           = true;         // Habilitar lote inteligente
input double HighQualityThreshold     = 0.3;          // Threshold alta qualidade
input double UltraQualityThreshold    = 0.8;          // Threshold ultra qualidade
input double SmartLotMultiplier       = 1.8;          // Multiplicador lote normal
input double UltraLotMultiplier       = 3.0;          // Multiplicador lote ultra
input double MaxAllowedLot            = 1.0;          // Lote mÃ¡ximo permitido

input group "â”€â”€â”€â”€ ğŸ“Š PIRAMIDAÃ‡ÃƒO â”€â”€â”€â”€";
input bool   EnablePyramiding         = true;         // Habilitar piramidaÃ§Ã£o
input int    MaxPyramidPositions      = 4;            // MÃ¡ximo de posiÃ§Ãµes pirÃ¢mide
input double PyramidingDistanceATR    = 0.4;          // DistÃ¢ncia entre posiÃ§Ãµes (ATR)
input bool   ReduceLotOnPyramiding    = false;        // Reduzir lote na piramidaÃ§Ã£o
input double PyramidingLotMultiplier  = 0.8;          // Multiplicador lote pirÃ¢mide

input group "â”€â”€â”€â”€ ğŸ¯ CONTROLE DE DIREÃ‡ÃƒO â”€â”€â”€â”€";
input bool   AllowOnlyOneDirection    = true;         // Permitir sÃ³ uma direÃ§Ã£o
input bool   CloseOppositeOnNewSignal = false;        // Fechar oposto em novo sinal
input bool   WaitForAllCloseBeforeNew = true;         // Aguardar fechamento total

input group "â”€â”€â”€â”€ ğŸ® CONTROLE DE ENTRADAS â”€â”€â”€â”€";
input int    MaxTradesPerDirection    = 4;            // MÃ¡ximo trades por direÃ§Ã£o
input int    MinBarsBetweenSameDirection = 2;         // Barras mÃ­nimas entre entradas
input bool   UseVolatilityFilter      = true;         // Usar filtro de volatilidade
input double MaxATRMultiplier         = 4.0;          // Multiplicador mÃ¡ximo ATR

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ§  5. SISTEMA DE APRENDIZADO (Q-Learning)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
input group "â”€â”€â”€â”€ ğŸ§  APRENDIZADO BÃSICO â”€â”€â”€â”€";
input bool   UseSimpleRewardSystem    = true;         // Sistema de recompensa simples
input double RewardWin                = 5.0;          // Recompensa por vitÃ³ria
input double RewardLoss               = -2.0;         // Penalidade por perda
double LearningRate                   = 0.03;         // Taxa de aprendizado (fixo)

input group "â”€â”€â”€â”€ ğŸ² EXPLORAÃ‡ÃƒO â”€â”€â”€â”€";
input double InitialExplorationRate   = 0.40;         // Taxa inicial de exploraÃ§Ã£o (40%)
input double MinExplorationRate       = 0.20;         // Taxa mÃ­nima de exploraÃ§Ã£o (20%)
input double ExplorationDecay         = 0.999;        // Decay da exploraÃ§Ã£o (0.1% por vitÃ³ria)
input int    MinStateVisitsToTrade    = 2;            // Visitas mÃ­nimas para operar

input group "â”€â”€â”€â”€ ğŸ”„ SISTEMA HÃBRIDO â”€â”€â”€â”€";
input bool   EnablePyramidingLearning = true;         // Aprendizado de piramidaÃ§Ã£o
input int    PyramidLearningBonus     = 10;           // BÃ´nus aprendizado pirÃ¢mide
input double PyramidBlockingMultiplier = 1.5;         // Multiplicador bloqueio pirÃ¢mide
input int    MinPyramidVisitsForBlock = 50;           // Visitas mÃ­n. para bloquear pirÃ¢mide

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ’¾ 6. MEMÃ“RIA E PERSISTÃŠNCIA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
input group "â”€â”€â”€â”€ ğŸ’¾ OTIMIZAÃ‡ÃƒO DE MEMÃ“RIA â”€â”€â”€â”€";
input bool   EnableMemoryOptimization = true;         // Habilitar otimizaÃ§Ã£o memÃ³ria
input int    MaxMemoryStates          = 1000;         // MÃ¡ximo de estados na memÃ³ria
input bool   CompressQValues          = true;         // Comprimir Q-values
input double QValuePrecision          = 2;            // PrecisÃ£o dos Q-values
input bool   AutoCleanMemory          = true;         // Limpeza automÃ¡tica
input int    CleanMemoryAfterTrades   = 100;          // Limpar apÃ³s N trades
input bool   UseIncrementalSave       = true;         // Salvamento incremental

input group "â”€â”€â”€â”€ ğŸ”„ DECAY E RESET â”€â”€â”€â”€";
input bool   EnableMemoryDecay        = true;         // Habilitar decay de memÃ³ria
input double DecayFactor              = 0.05;         // Fator de decay (5%)
input bool   EnableIntelligentReset   = true;         // Reset inteligente
input double BadStateLossThreshold    = 0.60;         // Threshold perda para reset (60%)
input int    BadStateMinVisits        = 20;           // Visitas mÃ­nimas para reset
input int    MinStatesBeforeReset     = 100;          // MÃ­nimo de estados aprendidos antes de permitir resets
input int    DecayCheckIntervalHours  = 1;            // Intervalo verificaÃ§Ã£o decay (horas)
input bool   ExcludeNOPFromVisits     = true;         // NOP nÃ£o conta visita

input group "â”€â”€â”€â”€ ğŸš« BLOQUEIO DE ESTADOS â”€â”€â”€â”€";
input bool   EnableUnifiedBlockingSystem = true;      // Sistema unificado bloqueio
input double BlockLossRateThreshold   = 0.80;         // Taxa perda para bloquear
input double UnblockWinRateThreshold  = 0.55;         // Taxa vitÃ³ria para desbloquear
int MinVisitsForBlockDecision         = 30;           // Visitas mÃ­n. decisÃ£o bloqueio

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“¤ 7. EXPORTAÃ‡ÃƒO E LOGS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
input group "â”€â”€â”€â”€ ğŸ’¾ EXPORTAÃ‡ÃƒO BINÃRIA â”€â”€â”€â”€";
input bool   EnableMemoryExport       = true;         // Habilitar exportaÃ§Ã£o
input int    AutoExportMinutes        = 30;           // Intervalo auto-export (min)
input bool   ExportOnDeinit           = true;         // Exportar ao finalizar
input bool   CreateBackupFiles        = true;         // Criar backups
input int    MaxBackupFiles           = 5;            // MÃ¡ximo de backups
input bool   ExportMemoryToTextFile   = true;         // Exportar para texto
input int    TextExportIntervalMinutes = 60;          // Intervalo export texto (min)

input group "â”€â”€â”€â”€ ğŸ“„ EXPORTAÃ‡ÃƒO TEXTO â”€â”€â”€â”€";
input bool   EnableTextExport         = false;        // Habilitar export texto (apenas binÃ¡rio recomendado)
input int    TextExportMinInterval    = 60;           // Intervalo mÃ­nimo (min)
input bool   ExportAllStates          = false;        // Exportar todos estados
input bool   IncludeQValues           = true;         // Incluir Q-values
input bool   IncludeStatistics        = true;         // Incluir estatÃ­sticas
input int    MaxStatesToExport        = 500;          // MÃ¡ximo estados exportar

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ–¥ï¸ 8. INTERFACE (HUD)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
input group "â”€â”€â”€â”€ ğŸ–¥ï¸ HUD (INTERFACE VISUAL) â”€â”€â”€â”€";
input bool   ShowHUD                  = true;         // Mostrar HUD
input int    HUD_X                    = 10;           // PosiÃ§Ã£o X
input int    HUD_Y                    = 20;           // PosiÃ§Ã£o Y
input int    HUD_UpdateMS             = 500;          // Intervalo atualizaÃ§Ã£o (ms)
input color  HUD_TitleColor           = clrLime;      // Cor tÃ­tulo
input color  HUD_TextColor            = clrWhite;     // Cor texto
input color  HUD_WarningColor         = clrOrange;    // Cor aviso
input color  HUD_ErrorColor           = clrRed;       // Cor erro
input color  HUD_SuccessColor         = clrCyan;      // Cor sucesso
input bool   HUD_Minimal              = false;        // Modo minimalista

// ======================================================================
// ======================================================================
// ğŸ“Š VARIÃVEIS GLOBAIS - ORGANIZADAS POR CATEGORIA
// ======================================================================

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ§  1. SISTEMA DE APRENDIZADO (Q-Learning e Estados)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
double g_Q[];                          // Q-table principal para aprendizado
int g_stateVisits[];                   // Contador de visitas por estado
int g_stateWins[];                     // Contadores de vitÃ³rias por estado
int g_stateLosses[];                   // Contadores de perdas por estado
int g_stateLastUpdate[];               // Ãšltimo update de cada estado
bool g_stateBlocked[];                 // Estados bloqueados por mÃ¡ performance
datetime g_stateLastBlockTime[];       // Timestamp do Ãºltimo bloqueio
datetime g_stateLastUnblockTime[];     // Timestamp do Ãºltimo desbloqueio
double g_stateWinRate[];               // Win rate calculado por estado
double g_stateAvgProfit[];             // Lucro mÃ©dio por estado

// Aprendizado - Controle
bool g_learningInitialized = false;
double g_currentExplorationRate = 0.0;
int g_totalStatesDiscovered = 0;
int g_totalQUpdates = 0;
double g_averageQValue = 0.0;
double g_maxQValue = 0.0;
double g_minQValue = 0.0;

// Aprendizado - ProteÃ§Ã£o contra estados congelados
static int g_lastCalculatedState = -1;
static int g_sameStateCount = 0;
static datetime g_lastStateChangeTime = 0;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ’¾ 2. SISTEMA DE MEMÃ“RIA E PERSISTÃŠNCIA
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
int g_activeStates[];                  // Cache de estados ativos (otimizaÃ§Ã£o)
int g_activeStatesCount = 0;
bool g_memoryDirty = false;
int g_memorySaveCounter = 0;
int g_memoryCleanCounter = 0;
string g_memoryFileName = "";
bool g_memoryInitialized = false;
datetime g_lastSaveTime = 0;
int g_qUpdatesSinceSave = 0;
bool g_lastSaveSuccess = false;

// Decay e Reset
datetime g_lastMaintenanceTime = 0;
int g_totalDecayCycles = 0;
int g_totalBadStateResets = 0;
int g_stateResets = 0;
int g_stateDecays = 0;
static int g_lastDecayTradeCount = 0;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“ˆ 3. INDICADORES TÃ‰CNICOS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string g_currentSymbol;
int g_adxHandle = INVALID_HANDLE;
int g_maHandle  = INVALID_HANDLE;
int g_rsiHandle = INVALID_HANDLE;
int g_bbHandle  = INVALID_HANDLE;
int g_atrHandle = INVALID_HANDLE;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ’° 4. CONTROLE DE TRADES E POSIÃ‡Ã•ES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ãšltima trade executada
int g_lastTradeState = -1;
double g_lastTradeProfit = 0.0;
int g_lastTradeAction = 0;
double g_lastLotUsed = 0.0;
double g_lastSLPrice = 0.0;
double g_lastTPPrice = 0.0;
bool g_lastTradeExecuted = false;
int g_lastTradeStateExecuted = -1;

// Controle de direÃ§Ã£o e posiÃ§Ãµes
int g_currentDirection = 0;
int g_positionsCount = 0;
datetime g_directionStartTime = 0;

// Controle de timing
datetime g_lastEntryTime = 0;
datetime g_lastTradeTime = 0;
datetime g_lastBuyTime = 0;
datetime g_lastSellTime = 0;
int g_lastBarProcessed = 0;

// Controle diÃ¡rio
int g_tradesToday = 0;
datetime g_lastTradeDate = 0;
datetime g_lastResetDate = 0;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“Š 5. ESTATÃSTICAS E PERFORMANCE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EstatÃ­sticas gerais
int g_totalTrades = 0;
int g_totalWins   = 0;
int g_totalLosses = 0;
double g_sumProfit = 0.0;
int g_consecutiveLosses = 0;

// EstatÃ­sticas por direÃ§Ã£o
int g_totalBuys = 0;
int g_totalSells = 0;
int g_buyWins = 0;
int g_sellWins = 0;
double g_buyProfit = 0.0;
double g_sellProfit = 0.0;

// Recordes e streaks
datetime g_firstTradeDate = 0;
double g_highestProfit = 0.0;
double g_lowestProfit = 0.0;
int g_bestWinStreak = 0;
int g_worstLossStreak = 0;
int g_currentWinStreak = 0;
int g_currentLossStreak = 0;

// Performance recente
double g_recentProfits[];
int g_recentProfitsIndex = 0;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“Š 6. VOLUME E FILTROS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
long g_currentVolume = 0;
long g_volumeAverage = 0;
double g_volumeMultiplier = 1.0;
double g_volumeStrength = 0.0;
double g_volumeRatio = 1.0;
datetime g_lastVolumeCheck = 0;
bool AllowBreakoutOverride = true;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ¯ 7. TRAILING STOP DINÃ‚MICO
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ulong   g_trailingTickets[];
double  g_trailingBestPrices[];
double  g_trailingCurrentSL[];
double  g_trailingCurrentTP[];
datetime g_trailingLastTrailTimes[];
bool    g_trailingBreakevenActivated[];
int     g_trailingCount = 0;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ–¥ï¸ 8. HUD (INTERFACE VISUAL)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
string hudObjects[15];
int hudObjectCount = 0;
datetime hudLastUpdate = 0;
string g_statusMessage = "Inicializando...";

// Cache do HUD (otimizaÃ§Ã£o)
int cachedVisitedStates = -1;
int cachedBlockedStates = -1;
int cachedPositions = -1;
int cachedDirection = -1;
string cachedStatus = "";
double cachedVolume = -1;
int cachedTradesToday = -1;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ“¤ 9. EXPORTAÃ‡ÃƒO E LOGS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
datetime g_lastExportTime = 0;
int g_exportCount = 0;
datetime g_lastTextExportTime = 0;
int g_textExportCount = 0;

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// ğŸ› 10. DEBUG E DIAGNÃ“STICO
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
int g_debugState = -1;
int g_debugVisitas = 0;
int g_debugPerdas = 0;

// ======================================================================
// âœ…âœ…âœ… CORREÃ‡Ã•ES AGUDAS PARA O PROBLEMA DE ESTADOS TRAVADOS
// ======================================================================

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡Ã•ES REMOVIDAS (d651ec8): FixStuckStatesProblem() e ResetBlockingSystem()
// Essas funÃ§Ãµes limitavam artificialmente as visitas dos estados, impedindo
// que atingissem MinVisitsForBlockDecision (20). Foram completamente removidas.
// ======================================================================

// ======================================================================
// âœ…âœ…âœ… 4. FUNÃ‡ÃƒO: DEBUG MELHORADO PARA ESTADOS TRAVADOS
// ======================================================================
void DebugStuckStatesEnhanced()
{
   Print("=== DEBUG ESTADOS TRAVADOS (VERSÃƒO MELHORADA) ===");
   
   int stuckAt10 = 0;
   int stuckAt20 = 0;
   int stuckAt30 = 0;
   int wronglyBlocked = 0;
   int correctlyBlocked = 0;
   int totalBlocked = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         if(g_stateVisits[state] == 10) stuckAt10++;
         if(g_stateVisits[state] == 20) stuckAt20++;
         if(g_stateVisits[state] == 30) stuckAt30++;
         
         if(g_stateBlocked[state])
         {
            totalBlocked++;
            double winRate = CalculateWinRate(state);
            
            if(winRate >= 0.30 && g_stateVisits[state] >= 5)
            {
               wronglyBlocked++;
               Print("âŒâŒâŒ ERRO CRÃTICO: Estado ", state, 
                     " bloqueado com win rate BOA: ", DoubleToString(winRate*100,1), "%",
                     " | Visitas: ", g_stateVisits[state]);
            }
            else if(winRate < 0.25 && g_stateVisits[state] >= 5)
            {
               correctlyBlocked++;
            }
         }
      }
   }
   
   Print("ğŸ“Š ESTATÃSTICAS DETALHADAS:");
   Print("   Estados travados em 10 visitas: ", stuckAt10);
   Print("   Estados travados em 20 visitas: ", stuckAt20);
   Print("   Estados travados em 30 visitas: ", stuckAt30);
   Print("   Estados bloqueados totais: ", totalBlocked);
   Print("   Estados bloqueados CORRETAMENTE: ", correctlyBlocked);
   Print("   Estados bloqueados ERRONEAMENTE: ", wronglyBlocked);
   Print("   Taxa de erro no bloqueio: ", totalBlocked > 0 ? 
         DoubleToString((double)wronglyBlocked/totalBlocked*100, 1) : "0.0", "%");
   
   // âœ… CORREÃ‡ÃƒO AUTOMÃTICA
   if(wronglyBlocked > 0)
   {
      Print("ğŸ”¥ğŸ”¥ğŸ”¥ APLICANDO CORREÃ‡ÃƒO AUTOMÃTICA...");
      
      for(int state = 0; state < NUM_STATES; state++)
      {
         if(g_stateBlocked[state])
         {
            double winRate = CalculateWinRate(state);
            
            if(winRate >= 0.30 && g_stateVisits[state] >= 5)
            {
               g_stateBlocked[state] = false;
               Print("âœ… Estado ", state, " desbloqueado automaticamente");
            }
         }
      }
      
      Print("âœ…âœ…âœ… ", wronglyBlocked, " estados desbloqueados automaticamente");
   }
   
   Print("=== FIM DEBUG ===");
}

// ======================================================================
// âœ…âœ…âœ… 5. FUNÃ‡ÃƒO: RESET SUAVE DE ESTADOS RUINS (VERSÃƒO MELHORADA)
// ======================================================================
void ResetBadStatesEnhanced()
{
   if(!EnableIntelligentReset) return;
   
   // âœ… PROTEÃ‡ÃƒO: NÃ£o resetar atÃ© ter base sÃ³lida de estados aprendidos
   if(g_activeStatesCount < MinStatesBeforeReset)
   {
      return; // NÃ£o resetar atÃ© ter aprendido estados suficientes
   }
   
   int statesReset = 0;
   int statesUnblocked = 0;
   
   Print("â™»ï¸ RESET INTELIGENTE DE ESTADOS RUINS (VERSÃƒO MELHORADA)");
   
   for(int s = 0; s < NUM_STATES; s++)
   {
      if(g_stateVisits[s] >= MinVisitsForBlockDecision) // Usar MinVisitsForBlockDecision
      {
         double winRate = CalculateWinRate(s);
         double lossRate = 1.0 - winRate;
         
         // âœ… CRITÃ‰RIOS PARA RESET
         bool shouldReset = false;
         string reason = "";
         
         if(lossRate > 0.75 && g_stateVisits[s] >= MinVisitsForBlockDecision)
         {
            shouldReset = true;
            reason = "Loss rate > 75%";
         }
         else if(winRate < 0.20 && g_stateVisits[s] >= MinVisitsForBlockDecision)
         {
            shouldReset = true;
            reason = "Win rate < 20%";
         }
         else if(g_stateVisits[s] >= MinVisitsForBlockDecision && winRate == 0.0)
         {
            shouldReset = true;
            reason = "Visitas suficientes, 0 vitÃ³rias";
         }
         
         if(shouldReset)
         {
            Print("ğŸ”¥ RESET Estado ", s, 
                  " | Motivo: ", reason,
                  " | Visitas: ", g_stateVisits[s],
                  " | Win Rate: ", DoubleToString(winRate*100,1), "%");
            
            // Reset parcial (mantÃ©m alguma memÃ³ria)
            g_stateVisits[s] = (int)(g_stateVisits[s] * 0.3);
            g_stateWins[s] = (int)(g_stateWins[s] * 0.3);
            g_stateLosses[s] = (int)(g_stateLosses[s] * 0.3);
            
            // Garantir mÃ­nimo
            if(g_stateVisits[s] < 1) g_stateVisits[s] = 1;
            if(g_stateWins[s] < 0) g_stateWins[s] = 0;
            if(g_stateLosses[s] < 0) g_stateLosses[s] = 0;
            
            // âœ… NÃƒO desbloquear estados ruins - manter bloqueio se existir
            // g_stateBlocked[s] permanece inalterado
            
            // Reset parcial do Q
            for(int a = 0; a < NUM_ACTIONS; a++)
            {
               g_Q[s * NUM_ACTIONS + a] *= 0.5;
            }
            
            statesReset++;
            g_totalBadStateResets++;
         }
         
         // âœ… DESBLOQUEAR ESTADOS BONS
         if(g_stateBlocked[s] && winRate >= 0.35 && g_stateVisits[s] >= MinVisitsForBlockDecision)
         {
            g_stateBlocked[s] = false;
            statesUnblocked++;
            Print("âœ… DESBLOQUEIO Estado ", s,
                  " | Win Rate boa: ", DoubleToString(winRate*100,1), "%");
         }
      }
   }
   
   if(statesReset > 0 || statesUnblocked > 0)
   {
      Print("ğŸ“Š RESUMO DO RESET:");
      Print("   Estados resetados: ", statesReset);
      Print("   Estados desbloqueados: ", statesUnblocked);
      Print("   Total resets acumulados: ", g_totalBadStateResets);
      
      g_memoryDirty = true;
      SaveState();
   }
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡Ã•ES DE DECAY E RESET INTELIGENTE (NOVAS)
// ======================================================================

// ======================================================================
// âœ…âœ…âœ… 1. FUNÃ‡ÃƒO DE DECAIMENTO SUAVE (CORRIGIDA)
// ======================================================================
void ApplyStateDecay()
{
   if(!EnableMemoryDecay) return;
   
   // âœ… PROTEÃ‡ÃƒO: NÃ£o aplicar decay antes de ter 100 estados descobertos
   // Garante fase completa de aprendizado sem perder estados prematuramente
   if(g_activeStatesCount < MinStatesBeforeReset)
   {
      return; // Decay desabilitado durante fase de descoberta inicial
   }
   
   const double DECAY_FACTOR = DecayFactor; // ConfigurÃ¡vel pelo usuÃ¡rio (% a esquecer)
   int statesDecayed = 0;
   double totalMemoryBefore = 0;
   double totalMemoryAfter = 0;

   for(int s = 0; s < NUM_STATES; s++)
   {
      if(g_stateVisits[s] > 0)
      {
         totalMemoryBefore += g_stateVisits[s];
         
         // Aplicar decay somente em estados com histÃ³rico muito significativo
         // âœ… CORREÃ‡ÃƒO: Aumentado de >10 para >50 para evitar cap artificial em 10 visitas
         if(g_stateVisits[s] > 50)
         {
            // âœ… CORREÃ‡ÃƒO: Decay deve REMOVER X%, nÃ£o MANTER X%
            // Se DecayFactor = 0.05 (5%), deve manter 95% (1.0 - 0.05)
            g_stateVisits[s] = (int)(g_stateVisits[s] * (1.0 - DECAY_FACTOR));
            g_stateLosses[s] = (int)(g_stateLosses[s] * (1.0 - DECAY_FACTOR));
            g_stateWins[s] = (int)(g_stateWins[s] * (1.0 - DECAY_FACTOR));
            
            // Garantir valores mÃ­nimos
            if(g_stateVisits[s] < 1 && g_stateVisits[s] > 0) g_stateVisits[s] = 1;
            if(g_stateLosses[s] < 0) g_stateLosses[s] = 0;
            if(g_stateWins[s] < 0) g_stateWins[s] = 0;
            
            statesDecayed++;
            
            // Atualizar Q-values gradualmente
            for(int a = 0; a < NUM_ACTIONS; a++)
            {
               int idx = s * NUM_ACTIONS + a;
               if(g_Q[idx] != 0.0)
               {
                  g_Q[idx] *= (1.0 - DECAY_FACTOR);
               }
            }
         }
         
         totalMemoryAfter += g_stateVisits[s];
      }
   }
   
   // Recalcular estados ativos
   g_activeStatesCount = 0;
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         if(g_activeStatesCount < MaxMemoryStates)
         {
            g_activeStates[g_activeStatesCount] = state;
            g_activeStatesCount++;
         }
      }
   }
   
   g_totalDecayCycles++;
   
   double memoryReduction = totalMemoryBefore > 0 ? 
                          (1.0 - (totalMemoryAfter / totalMemoryBefore)) * 100 : 0;
   
   Print("ğŸ”„ DECAY APLICADO: ", 
         "Estados ajustados: ", statesDecayed,
         " | ReduÃ§Ã£o memÃ³ria: ", DoubleToString(memoryReduction, 1), "%",
         " | Estados ativos: ", g_activeStatesCount,
         " | Ciclos: ", g_totalDecayCycles);
   
   g_memoryDirty = true;
}

// ======================================================================
// âœ…âœ…âœ… 2. RESET INTELIGENTE DE ESTADOS RUINS (CORRIGIDA)
// ======================================================================
void ResetBadStates()
{
   if(!EnableIntelligentReset) return;
   
   // Verificar se temos estados suficientes antes de permitir resets
   if(g_activeStatesCount < MinStatesBeforeReset)
   {
      return; // NÃ£o resetar atÃ© ter aprendido estados suficientes
   }
   
   int statesReset = 0;
   
   for(int s = 0; s < NUM_STATES; s++)
   {
      if(g_stateVisits[s] < BadStateMinVisits) continue; // Usar parÃ¢metro ajustÃ¡vel
      
      double lossRate = SafeDivide((double)g_stateLosses[s], (double)g_stateVisits[s], 0.0);
      
      // âš ï¸ MODIFICAÃ‡ÃƒO CRÃTICA: CondiÃ§Ã£o mais agressiva
      if((lossRate > BadStateLossThreshold || (g_stateVisits[s] > 10 && g_stateWins[s] == 0)) 
         && g_stateVisits[s] > BadStateMinVisits)
      {
         // Salvar estatÃ­sticas antes do reset
         int oldVisits = g_stateVisits[s];
         int oldLosses = g_stateLosses[s];
         int oldWins = g_stateWins[s];
         
         // Resetar contadores
         g_stateVisits[s] = 0;
         g_stateLosses[s] = 0;
         g_stateWins[s] = 0;
         // âœ… NÃƒO desbloquear estado ruim - preservar bloqueio
         // g_stateBlocked[s] permanece inalterado
         g_stateLastBlockTime[s] = 0;
         g_stateLastUnblockTime[s] = 0;
         
         // Resetar Q-table do estado
         for(int a = 0; a < NUM_ACTIONS; a++)
         {
            g_Q[s * NUM_ACTIONS + a] = 0.0;
         }
         
         statesReset++;
         g_totalBadStateResets++;
         
         Print("â™»ï¸ RESET DE ESTADO RUIM -> Estado: ", s,
               " | Visitas antigas: ", oldVisits,
               " | Perdas: ", oldLosses, " (", DoubleToString(lossRate*100, 1), "%)",
               " | VitÃ³rias: ", oldWins);
         
         g_memoryDirty = true;
      }
   }
   
   if(statesReset > 0)
   {
      // Recalcular estados ativos apÃ³s reset
      g_activeStatesCount = 0;
      for(int state = 0; state < NUM_STATES; state++)
      {
         if(g_stateVisits[state] > 0)
         {
            if(g_activeStatesCount < MaxMemoryStates)
            {
               g_activeStates[g_activeStatesCount] = state;
               g_activeStatesCount++;
            }
         }
      }
      
      Print("âœ… ", statesReset, " estados ruins resetados | Total resets: ", g_totalBadStateResets);
   }
}

// ======================================================================
// âœ…âœ…âœ… 3. MANUTENÃ‡ÃƒO PERIÃ“DICA DO SISTEMA
// ======================================================================
void PerformMemoryMaintenance()
{
   static datetime lastMaintenance = 0;
   
   if(TimeCurrent() - lastMaintenance < (DecayCheckIntervalHours * 3600))
      return;
   
   Print("ğŸ”§ INICIANDO MANUTENÃ‡ÃƒO PERIÃ“DICA DO SISTEMA...");
   
   // 1. Aplicar decay suave
   if(EnableMemoryDecay)
   {
      ApplyStateDecay();
   }
   
   // 2. Resetar estados ruins
   if(EnableIntelligentReset)
   {
      ResetBadStates();
   }
   
   // 3. Limpar memÃ³ria se necessÃ¡rio
   if(AutoCleanMemory)
   {
      CleanMemory();
   }
   
   // 4. Auto desbloquear estados bons
   if(EnableUnifiedBlockingSystem)
   {
      AutoUnblockGoodStates();
   }
   
   lastMaintenance = TimeCurrent();
   
   // Salvar apÃ³s manutenÃ§Ã£o
   SaveBrain();
   SaveState();
   
   Print("âœ… MANUTENÃ‡ÃƒO COMPLETA REALIZADA");
   Print("   â€¢ Decay aplicado: ", g_totalDecayCycles, " ciclos");
   Print("   â€¢ Estados resetados: ", g_totalBadStateResets);
   Print("   â€¢ Estados ativos: ", g_activeStatesCount);
   Print("   â€¢ Estados bloqueados: ", CountBlockedStates());
}

// ======================================================================
// âœ…âœ…âœ… SISTEMA DE BLOQUEIO UNIFICADO CORRIGIDO
// ======================================================================

// âœ…âœ…âœ… 1ï¸âƒ£ FUNÃ‡ÃƒO UNIFICADA PARA BLOQUEAR ESTADO (CORRIGIDA)
void BlockState(int state)
{
    if(state < 0 || state >= NUM_STATES) return;

    if(g_stateLastBlockTime[state] > 0 && TimeCurrent() - g_stateLastBlockTime[state] < 3600)
    {
        Print("â³ Cooldown ativo para estado ", state, " - aguardando 1h");
        return;
    }

    if(g_stateBlocked[state])
    {
        return;
    }

    int visits = g_stateVisits[state];
    int losses = g_stateLosses[state];
    
    if(visits < MinVisitsForBlockDecision)
    {
        Print("âœ… Estado ", state, " tem poucas visitas (", visits, ") - NÃƒO bloqueando");
        return;
    }
    
    double lossRate = SafeDivide((double)losses, (double)visits, 0.0);
    
    if(lossRate >= BlockLossRateThreshold)
    {
        g_stateBlocked[state] = true;
        g_stateLastBlockTime[state] = TimeCurrent();
        
        Print("â›” ESTADO BLOQUEADO CORRETAMENTE: ", state, 
              " | Visitas REAIS: ", visits, 
              " | Perdas REAIS: ", losses, 
              " | Taxa de perda: ", DoubleToString(lossRate*100, 1), "%",
              " | MÃ­nimo requerido: ", MinVisitsForBlockDecision, " visitas");
        
        g_memoryDirty = true;
        InvalidateHUDCache();
    }
    else
    {
        Print("âœ… Estado ", state, " NÃƒO bloqueado - Taxa de perda: ", 
              DoubleToString(lossRate*100, 1), "% (limite: ", BlockLossRateThreshold*100, "%)");
    }
}

// âœ…âœ…âœ… 2ï¸âƒ£ FUNÃ‡ÃƒO UNIFICADA PARA DESBLOQUEAR ESTADO (CORRIGIDA)
void UnblockState(int state)
{
    if(state < 0 || state >= NUM_STATES) return;

    if(g_stateLastUnblockTime[state] > 0 && TimeCurrent() - g_stateLastUnblockTime[state] < 3600)
    {
        Print("â³ Cooldown ativo para estado ", state, " - aguardando 1h");
        return;
    }

    if(g_stateBlocked[state])
    {
        g_stateBlocked[state] = false;
        g_stateLastUnblockTime[state] = TimeCurrent();
        
        Print("âœ… ESTADO DESBLOQUEADO: ", state, 
              " | Visitas: ", g_stateVisits[state], 
              " | VitÃ³rias: ", g_stateWins[state],
              " | Perdas: ", g_stateLosses[state],
              " | Win Rate: ", DoubleToString(CalculateWinRate(state)*100, 1), "%");
        
        g_memoryDirty = true;
        InvalidateHUDCache();
    }
}

// âœ…âœ…âœ… 3ï¸âƒ£ FUNÃ‡ÃƒO PARA VERIFICAR SE UM ESTADO DEVE SER BLOQUEADO (CORRIGIDA)
bool ShouldBlockState(int state)
{
    if(state < 0 || state >= NUM_STATES) return false;
    
    int visits = g_stateVisits[state];
    int losses = g_stateLosses[state];
    
    if(visits < MinVisitsForBlockDecision) return false;
    
    double lossRate = SafeDivide((double)losses, (double)visits, 0.0);
    
    return (lossRate >= BlockLossRateThreshold);
}

// âœ…âœ…âœ… 4ï¸âƒ£ FUNÃ‡ÃƒO PARA VERIFICAR SE UM ESTADO DEVE SER DESBLOQUEADO (CORRIGIDA)
bool ShouldUnblockState(int state)
{
    if(state < 0 || state >= NUM_STATES) return false;
    
    if(!g_stateBlocked[state]) return false;
    
    int visits = g_stateVisits[state];
    
    if(visits < MinVisitsForBlockDecision) return false;
    
    double winRate = CalculateWinRate(state);
    
    return (winRate >= UnblockWinRateThreshold);
}

// âœ…âœ…âœ… 5ï¸âƒ£ FUNÃ‡ÃƒO PRINCIPAL DE VERIFICAÃ‡ÃƒO DE BLOQUEIO (SOMENTE LEITURA)
bool IsStateBlocked(int state)
{
    if(state < 0 || state >= NUM_STATES) return false;
    
    return g_stateBlocked[state];
}

// âœ…âœ…âœ… 6ï¸âƒ£ FUNÃ‡ÃƒO PARA AVALIAR E ATUALIZAR BLOQUEIO DE ESTADO (CORRIGIDA)
void EvaluateAndUpdateBlockState(int state)
{
    if(state < 0 || state >= NUM_STATES) return;
    
    static datetime lastBlockCheck = 0;
    if(TimeCurrent() - lastBlockCheck < 300)
        return;
    
    lastBlockCheck = TimeCurrent();
    
    bool shouldBeBlocked = ShouldBlockState(state);
    bool currentlyBlocked = g_stateBlocked[state];
    
    if(shouldBeBlocked && !currentlyBlocked)
    {
        BlockState(state);
    }
    else if(!shouldBeBlocked && currentlyBlocked)
    {
        if(ShouldUnblockState(state))
        {
            UnblockState(state);
        }
    }
}

// âœ…âœ…âœ… 7ï¸âƒ£ FUNÃ‡ÃƒO PARA AVALIAR TODOS OS ESTADOS ATIVOS (CORRIGIDA)
void EvaluateAllActiveStates()
{
    static datetime lastFullEvaluation = 0;
    
    if(TimeCurrent() - lastFullEvaluation < 300)
        return;
    
    lastFullEvaluation = TimeCurrent();
    
    int blocked = 0;
    int unblocked = 0;
    
    for(int i = 0; i < g_activeStatesCount; i++)
    {
        int state = g_activeStates[i];
        
        bool shouldBeBlocked = ShouldBlockState(state);
        bool currentlyBlocked = g_stateBlocked[state];
        
        if(shouldBeBlocked && !currentlyBlocked)
        {
            BlockState(state);
            blocked++;
        }
        else if(!shouldBeBlocked && currentlyBlocked)
        {
            if(ShouldUnblockState(state))
            {
                UnblockState(state);
                unblocked++;
            }
        }
    }
    
    if(blocked > 0 || unblocked > 0)
    {
      Print("ğŸ“Š AvaliaÃ§Ã£o de estados (c/ cooldown): ", blocked, " bloqueados, ", unblocked, " desbloqueados");
      Print("ğŸ“Š Total estados bloqueados: ", CountBlockedStates());
    }
}

// âœ…âœ…âœ… 8ï¸âƒ£ FUNÃ‡ÃƒO PARA DESBLOQUEAR ESTADOS BONS AUTOMATICAMENTE (CORRIGIDA)
void AutoUnblockGoodStates()
{
    int unblocked = 0;
    
    for(int state = 0; state < NUM_STATES; state++)
    {
        if(g_stateBlocked[state] && ShouldUnblockState(state))
        {
            UnblockState(state);
            unblocked++;
        }
    }
    
    if(unblocked > 0)
    {
        Print("ğŸ”„ ", unblocked, " estados desbloqueados automaticamente (win rate > ", 
              DoubleToString(UnblockWinRateThreshold*100, 0), "%)");
    }
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡Ã•ES AUXILIARES CORRIGIDAS
// ======================================================================

// ======================================================================
// âœ… FUNÃ‡ÃƒO SAFEDIVIDE - PROTEÃ‡ÃƒO GLOBAL CONTRA DIVISÃƒO POR ZERO
// ======================================================================
// FunÃ§Ã£o de divisÃ£o segura que previne erros de divisÃ£o por zero
// ParÃ¢metros:
//   numerator - O valor a ser dividido (numerador)
//   denominator - O valor pelo qual dividir (denominador)
//   defaultValue - Valor a retornar se divisÃ£o nÃ£o for possÃ­vel (padrÃ£o: 0.0)
// Retorna:
//   - O resultado da divisÃ£o se denominador vÃ¡lido
//   - defaultValue se denominador for zero ou muito prÃ³ximo de zero
// Exemplos:
//   SafeDivide(10.0, 2.0, 0.0) retorna 5.0
//   SafeDivide(10.0, 0.0, 0.0) retorna 0.0 (valor padrÃ£o)
//   SafeDivide(price - lower, range, 0.5) retorna 0.5 se range for zero
double SafeDivide(double numerator, double denominator, double defaultValue = 0.0)
{
   if(denominator == 0.0 || MathAbs(denominator) < 0.0000001)
   {
      return defaultValue;
   }
   return numerator / denominator;
}

double CalculateWinRate(int state)
{
    if(state < 0 || state >= NUM_STATES) return 0.0;
    if(g_stateVisits[state] == 0) return 0.0;
    
    return SafeDivide((double)g_stateWins[state], (double)g_stateVisits[state], 0.0);
}

int CountBlockedStates()
{
   int count = 0;
   for(int i = 0; i < NUM_STATES; i++)
   {
      if(g_stateBlocked[i]) count++;
   }
   return count;
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡Ã•ES DE MEMÃ“RIA PERSISTENTE (CORRIGIDAS)
// ======================================================================

void SaveState()
{
   int handle = FileOpen(STATE_FILE, FILE_WRITE | FILE_BIN | FILE_COMMON);
   if(handle == INVALID_HANDLE) 
   {
      Print("âŒ Erro ao abrir arquivo para salvar estados: ", STATE_FILE);
      return;
   }

   // ğŸ”§ REGRA 1 â€” Sempre converter explicitamente
   FileWriteArray(handle, g_stateVisits);
   FileWriteArray(handle, g_stateLosses);
   FileWriteArray(handle, g_stateWins);
   FileWriteArray(handle, g_stateLastUpdate);
   FileWriteArray(handle, g_activeStates);
   FileWriteArray(handle, g_stateBlocked);
   FileWriteArray(handle, g_stateLastBlockTime);
   FileWriteArray(handle, g_stateLastUnblockTime);
   FileWriteInteger(handle, (int)g_activeStatesCount);
   FileWriteArray(handle, g_stateWinRate);
   FileWriteArray(handle, g_stateAvgProfit);
   FileWriteInteger(handle, (int)g_stateResets);
   FileWriteInteger(handle, (int)g_stateDecays);
   FileWriteInteger(handle, (int)g_lastDecayTradeCount);
   FileWriteInteger(handle, (int)g_totalDecayCycles);
   FileWriteInteger(handle, (int)g_totalBadStateResets);
   
   FileClose(handle);
   
   static datetime lastSave = 0;
   datetime now = TimeCurrent();
   if(now - lastSave > 60)
   {
      Print("ğŸ’¾ Estados salvos em memÃ³ria persistente");
      lastSave = now;
   }
}

void LoadState()
{
   if(!FileIsExist(STATE_FILE, FILE_COMMON))
   {
      Print("âš ï¸ Arquivo de estados nÃ£o encontrado. Criando novo.");
      return;
   }
   
   int handle = FileOpen(STATE_FILE, FILE_READ | FILE_BIN | FILE_COMMON);
   if(handle == INVALID_HANDLE) 
   {
      Print("âŒ Erro ao abrir arquivo para carregar estados: ", STATE_FILE);
      return;
   }

   FileReadArray(handle, g_stateVisits);
   FileReadArray(handle, g_stateLosses);
   FileReadArray(handle, g_stateWins);
   FileReadArray(handle, g_stateLastUpdate);
   FileReadArray(handle, g_activeStates);
   FileReadArray(handle, g_stateBlocked);
   FileReadArray(handle, g_stateLastBlockTime);
   FileReadArray(handle, g_stateLastUnblockTime);
   
   // ğŸ”§ REGRA 3 â€” Converter para int se necessÃ¡rio
   int tempActiveStatesCount = FileReadInteger(handle);
   g_activeStatesCount = tempActiveStatesCount;
   
   FileReadArray(handle, g_stateWinRate);
   FileReadArray(handle, g_stateAvgProfit);
   
   int tempStateResets = FileReadInteger(handle);
   int tempStateDecays = FileReadInteger(handle);
   int tempLastDecayTradeCount = FileReadInteger(handle);
   int tempTotalDecayCycles = FileReadInteger(handle);
   int tempTotalBadStateResets = FileReadInteger(handle);
   
   g_stateResets = tempStateResets;
   g_stateDecays = tempStateDecays;
   g_lastDecayTradeCount = tempLastDecayTradeCount;
   g_totalDecayCycles = tempTotalDecayCycles;
   g_totalBadStateResets = tempTotalBadStateResets;
   
   FileClose(handle);
   
   Print("âœ… Estados carregados da memÃ³ria persistente");
   Print("ğŸ“Š Estados ativos: ", g_activeStatesCount);
   Print("ğŸ“Š Total visitas REAIS: ", ArraySum(g_stateVisits));
   Print("ğŸ“Š Total perdas REAIS: ", ArraySum(g_stateLosses));
   Print("ğŸ“Š Total vitÃ³rias REAIS: ", ArraySum(g_stateWins));
   Print("ğŸ“Š Estados bloqueados: ", CountBlockedStates());
   Print("ğŸ“Š Ciclos de decay: ", g_totalDecayCycles);
   Print("ğŸ“Š Estados resetados: ", g_totalBadStateResets);
}

int ArraySum(const int &array[])
{
   int sum = 0;
   for(int i = 0; i < ArraySize(array); i++)
      sum += array[i];
   return sum;
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡Ã•ES DO SISTEMA DE MEMÃ“RIA OTIMIZADA (NOVO)
// ======================================================================

double CompressQValue(double value)
{
   if(!CompressQValues || QValuePrecision >= 4) return value;
   return NormalizeDouble(value, (int)QValuePrecision);
}

void AddActiveState(int state)
{
   if(state < 0 || state >= NUM_STATES) return;
   
   for(int i = 0; i < g_activeStatesCount; i++)
   {
      if(g_activeStates[i] == state) return;
   }
   
   if(g_activeStatesCount < MaxMemoryStates)
   {
      g_activeStates[g_activeStatesCount] = state;
      g_activeStatesCount++;
   }
   else
   {
      int oldestIndex = 0;
      int oldestTime = INT_MAX;
      
      for(int i = 0; i < g_activeStatesCount; i++)
      {
         int stateIdx = g_activeStates[i];
         if(g_stateLastUpdate[stateIdx] < oldestTime)
         {
            oldestTime = g_stateLastUpdate[stateIdx];
            oldestIndex = i;
         }
      }
      
      g_activeStates[oldestIndex] = state;
   }
   
   g_stateLastUpdate[state] = g_totalTrades;
   InvalidateHUDCache();
   
   if(EnableUnifiedBlockingSystem)
   {
      EvaluateAndUpdateBlockState(state);
   }
}

void CleanMemory()
{
   if(!AutoCleanMemory) return;
   
   g_memoryCleanCounter++;
   if(g_memoryCleanCounter < CleanMemoryAfterTrades) return;
   
   g_memoryCleanCounter = 0;
   
   Print("ğŸ§¹ LIMPANDO MEMÃ“RIA...");
   
   int cleaned = 0;
   int kept = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         if(g_stateVisits[state] < 3 && 
            (g_totalTrades - g_stateLastUpdate[state]) > 100)
         {
            g_stateVisits[state] = 0;
            g_stateLosses[state] = 0;
            g_stateWins[state] = 0;
            g_stateLastUpdate[state] = 0;
            g_stateLastBlockTime[state] = 0;
            g_stateLastUnblockTime[state] = 0;
            
            for(int a = 0; a < NUM_ACTIONS; a++)
            {
               g_Q[state * NUM_ACTIONS + a] = 0.0;
            }
            
            g_stateBlocked[state] = false;
            
            cleaned++;
         }
         else
         {
            kept++;
         }
      }
   }
   
   g_activeStatesCount = 0;
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         if(g_activeStatesCount < MaxMemoryStates)
         {
            g_activeStates[g_activeStatesCount] = state;
            g_activeStatesCount++;
         }
      }
   }
   
   Print("âœ… MemÃ³ria limpa: ", cleaned, " estados removidos, ", kept, " mantidos");
   Print("   Estados ativos na memÃ³ria: ", g_activeStatesCount);
   
   SaveState();
}

// ======================================================================
// âœ…âœ…âœ… SISTEMA DE BACKUP AUTOMÃTICO (CORRIGIDO)
// ======================================================================

string GetBackupFileName(int backupNum)
{
   return "Phoenix_Files/Backups/Cerebro_" + _Symbol + "_" + 
          EnumToString((ENUM_TIMEFRAMES)_Period) + "_backup_" + 
          IntegerToString(backupNum) + ".bin";
}

void ManageBackupFiles()
{
   if(!CreateBackupFiles || !g_memoryInitialized) return;
   
   string backupFile = GetBackupFileName(0);
   if(SaveBrainToFile(backupFile))
   {
      Print("âœ… Backup criado: ", backupFile);
   }
   
   for(int i = MaxBackupFiles - 1; i > 0; i--)
   {
      string oldFile = GetBackupFileName(i);
      string newFile = GetBackupFileName(i + 1);
      
      if(FileIsExist(oldFile, FILE_COMMON))
      {
         if(FileIsExist(newFile, FILE_COMMON))
         {
            FileDelete(newFile, FILE_COMMON);
         }
         FileMove(oldFile, 0, newFile, 0);
      }
   }
}

bool SaveBrainToFile(string filename)
{
   if(!CreateDirectoryForFile(filename)) return false;

   int h = FileOpen(filename, FILE_WRITE|FILE_BIN|FILE_COMMON);
   if(h == INVALID_HANDLE) return false;

   // ğŸ”§ REGRA 1 â€” Sempre converter explicitamente
   FileWriteInteger(h, (int)FILE_MAGIC);
   FileWriteInteger(h, (int)FILE_VERSION);
   FileWriteInteger(h, (int)g_activeStatesCount);
   
   for(int i = 0; i < g_activeStatesCount; i++)
   {
      int state = g_activeStates[i];
      
      FileWriteInteger(h, (int)state);
      FileWriteInteger(h, (int)g_stateVisits[state]);
      FileWriteInteger(h, (int)g_stateLosses[state]);
      FileWriteInteger(h, (int)g_stateWins[state]);
      FileWriteInteger(h, (int)g_stateLastUpdate[state]);
      FileWriteInteger(h, (int)g_stateBlocked[state]);
      FileWriteLong(h, (long)g_stateLastBlockTime[state]);
      FileWriteLong(h, (long)g_stateLastUnblockTime[state]);
      
      for(int a = 0; a < NUM_ACTIONS; a++)
      {
         double qValue = CompressQValue(g_Q[state * NUM_ACTIONS + a]);
         FileWriteDouble(h, qValue);
      }
   }
   
   FileWriteDouble(h, g_currentExplorationRate);
   FileWriteInteger(h, (int)g_tradesToday);
   FileWriteInteger(h, (int)g_consecutiveLosses);
   FileWriteInteger(h, (int)g_totalTrades);
   FileWriteInteger(h, (int)g_totalWins);
   FileWriteInteger(h, (int)g_totalLosses);
   FileWriteDouble(h, g_sumProfit);
   FileWriteDouble(h, g_volumeMultiplier);
   FileWriteInteger(h, (int)g_totalStatesDiscovered);
   FileWriteInteger(h, (int)g_totalQUpdates);
   FileWriteDouble(h, g_averageQValue);
   FileWriteDouble(h, g_maxQValue);
   FileWriteDouble(h, g_minQValue);
   
   int arraySize = (int)ArraySize(g_recentProfits);
   FileWriteInteger(h, (int)arraySize);
   FileWriteArray(h, g_recentProfits);
   FileWriteInteger(h, (int)g_recentProfitsIndex);
   
   long firstTradeDate = (long)g_firstTradeDate;
   FileWriteLong(h, (long)firstTradeDate);
   FileWriteDouble(h, g_highestProfit);
   FileWriteDouble(h, g_lowestProfit);
   FileWriteInteger(h, (int)g_bestWinStreak);
   FileWriteInteger(h, (int)g_worstLossStreak);
   FileWriteInteger(h, (int)g_currentWinStreak);
   FileWriteInteger(h, (int)g_currentLossStreak);
   
   FileWriteInteger(h, (int)g_totalBuys);
   FileWriteInteger(h, (int)g_totalSells);
   FileWriteInteger(h, (int)g_buyWins);
   FileWriteInteger(h, (int)g_sellWins);
   FileWriteDouble(h, g_buyProfit);
   FileWriteDouble(h, g_sellProfit);
   
   FileWriteArray(h, g_stateWinRate);
   FileWriteArray(h, g_stateAvgProfit);
   FileWriteInteger(h, (int)g_stateResets);
   FileWriteInteger(h, (int)g_stateDecays);
   FileWriteInteger(h, (int)g_lastDecayTradeCount);
   FileWriteInteger(h, (int)g_totalDecayCycles);
   FileWriteInteger(h, (int)g_totalBadStateResets);

   FileClose(h);
   return true;
}

bool LoadBrainFromFile(string filename)
{
   if(!FileIsExist(filename, FILE_COMMON)) return false;

   int h = FileOpen(filename, FILE_READ|FILE_BIN|FILE_COMMON);
   if(h == INVALID_HANDLE) return false;

   int magic = FileReadInteger(h);
   int version = FileReadInteger(h);
   
   if(magic != FILE_MAGIC || version != FILE_VERSION)
   {
      FileClose(h);
      return false;
   }
   
   ArrayResize(g_stateVisits, NUM_STATES);
   ArrayInitialize(g_stateVisits, 0);
   
   ArrayResize(g_stateLosses, NUM_STATES);
   ArrayInitialize(g_stateLosses, 0);
   
   ArrayResize(g_stateWins, NUM_STATES);
   ArrayInitialize(g_stateWins, 0);
   
   ArrayResize(g_stateLastUpdate, NUM_STATES);
   ArrayInitialize(g_stateLastUpdate, 0);
   
   ArrayResize(g_stateBlocked, NUM_STATES);
   ArrayInitialize(g_stateBlocked, false);
   
   ArrayResize(g_stateLastBlockTime, NUM_STATES);
   ArrayInitialize(g_stateLastBlockTime, 0);
   
   ArrayResize(g_stateLastUnblockTime, NUM_STATES);
   ArrayInitialize(g_stateLastUnblockTime, 0);
   
   for(int i = 0; i < NUM_STATES * NUM_ACTIONS; i++)
   {
      g_Q[i] = 0.0;
   }
   
   // ğŸ”§ REGRA 3 â€” Converter para int se necessÃ¡rio
   int tempActiveStatesCount = FileReadInteger(h);
   g_activeStatesCount = tempActiveStatesCount;
   
   for(int i = 0; i < g_activeStatesCount; i++)
   {
      int state = FileReadInteger(h);
      
      if(state >= 0 && state < NUM_STATES)
      {
         g_activeStates[i] = state;
         g_stateVisits[state] = FileReadInteger(h);
         g_stateLosses[state] = FileReadInteger(h);
         g_stateWins[state] = FileReadInteger(h);
         g_stateLastUpdate[state] = FileReadInteger(h);
         g_stateBlocked[state] = (bool)FileReadInteger(h);
         g_stateLastBlockTime[state] = (datetime)FileReadLong(h);
         g_stateLastUnblockTime[state] = (datetime)FileReadLong(h);
         
         for(int a = 0; a < NUM_ACTIONS; a++)
         {
            double qValue = FileReadDouble(h);
            g_Q[state * NUM_ACTIONS + a] = qValue;
         }
      }
   }
   
   g_currentExplorationRate = FileReadDouble(h);
   g_tradesToday = FileReadInteger(h);
   g_consecutiveLosses = FileReadInteger(h);
   g_totalTrades = FileReadInteger(h);
   g_totalWins = FileReadInteger(h);
   g_totalLosses = FileReadInteger(h);
   g_sumProfit = FileReadDouble(h);
   g_volumeMultiplier = FileReadDouble(h);
   g_totalStatesDiscovered = FileReadInteger(h);
   g_totalQUpdates = FileReadInteger(h);
   g_averageQValue = FileReadDouble(h);
   g_maxQValue = FileReadDouble(h);
   g_minQValue = FileReadDouble(h);
   
   int arraySize = FileReadInteger(h);
   ArrayResize(g_recentProfits, arraySize);
   FileReadArray(h, g_recentProfits, 0, arraySize);
   g_recentProfitsIndex = FileReadInteger(h);
   
   long firstTradeDate = FileReadLong(h);
   g_firstTradeDate = (datetime)firstTradeDate;
   g_highestProfit = FileReadDouble(h);
   g_lowestProfit = FileReadDouble(h);
   g_bestWinStreak = FileReadInteger(h);
   g_worstLossStreak = FileReadInteger(h);
   g_currentWinStreak = FileReadInteger(h);
   g_currentLossStreak = FileReadInteger(h);
   
   g_totalBuys = FileReadInteger(h);
   g_totalSells = FileReadInteger(h);
   g_buyWins = FileReadInteger(h);
   g_sellWins = FileReadInteger(h);
   g_buyProfit = FileReadDouble(h);
   g_sellProfit = FileReadDouble(h);
   
   ArrayResize(g_stateWinRate, NUM_STATES);
   FileReadArray(h, g_stateWinRate, 0, NUM_STATES);
   
   ArrayResize(g_stateAvgProfit, NUM_STATES);
   FileReadArray(h, g_stateAvgProfit, 0, NUM_STATES);
   
   g_stateResets = FileReadInteger(h);
   g_stateDecays = FileReadInteger(h);
   g_lastDecayTradeCount = FileReadInteger(h);
   g_totalDecayCycles = FileReadInteger(h);
   g_totalBadStateResets = FileReadInteger(h);
   
   FileClose(h);
   
   Print("âœ… MemÃ³ria carregada: ", g_activeStatesCount, " estados ativos");
   Print("ğŸ“Š Estados bloqueados carregados: ", CountBlockedStates());
   Print("ğŸ“Š Ciclos de decay: ", g_totalDecayCycles);
   Print("ğŸ“Š Estados resetados: ", g_totalBadStateResets);
   return true;
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡Ã•ES DE MEMÃ“RIA PRINCIPAIS (OTIMIZADAS)
// ======================================================================

string BrainKey()
{
   return StringFormat("B%dx%dx%dx%dx%dx%dx%d_A%d",
      BINS_MA_DIST,BINS_RSI,BINS_ADX,BINS_BBPOS,BINS_VOLATILITY,BINS_VOLUME,BINS_TIME,NUM_ACTIONS);
}

string GetBrainFileName()
{
   if(g_memoryFileName == "")
   {
      g_memoryFileName = "Phoenix_Files/Cerebro_" + _Symbol + "_" + 
                         EnumToString((ENUM_TIMEFRAMES)_Period) + "_FIXED_CORRIGIDO.bin";
   }
   return g_memoryFileName;
}

bool CreateDirectoryForFile(string p)
{
   string parts[];
   string cur = "";
   int n = StringSplit(p, '/', parts);
   if(n > 1)
   {
      for(int i = 0; i < n - 1; i++)
      {
         cur += parts[i] + "/";
         if(!FileIsExist(cur, FILE_COMMON))
         {
            if(!FolderCreate(cur, FILE_COMMON)) 
            {
               Print("âŒ Erro ao criar diretÃ³rio: ", cur);
               return false;
            }
         }
      }
   }
   return true;
}

bool SaveBrain()
{
   if(!g_memoryInitialized) 
   {
      Print("âš ï¸ MemÃ³ria nÃ£o inicializada, pulando save");
      return false;
   }

   if(UseIncrementalSave && !g_memoryDirty)
   {
      if(g_memorySaveCounter < 10)
      {
         g_memorySaveCounter++;
         return true;
      }
   }
   
   string f = GetBrainFileName();
   if(!CreateDirectoryForFile(f)) 
   {
      Print("âŒ Erro ao criar diretÃ³rio para: ", f);
      return false;
   }

   if(!SaveBrainToFile(f))
   {
      Print("âŒ Falha ao salvar memÃ³ria");
      return false;
   }
   
   g_lastSaveTime = TimeCurrent();
   g_lastSaveSuccess = true;
   g_qUpdatesSinceSave = 0;
   g_memoryDirty = false;
   g_memorySaveCounter = 0;
   
   if(CreateBackupFiles)
   {
      ManageBackupFiles();
   }
   
   if(EnableTextExport)
   {
      ExportMemoryToTextFileFunc(true);
   }
   
   SaveState();
   
   Print("ğŸ’¾ MemÃ³ria salva (estados ativos: ", g_activeStatesCount, ")");
   return true;
}

bool LoadBrain()
{
   string fn = GetBrainFileName();
   
   if(!FileIsExist(fn, FILE_COMMON))
   {
      Print("âš ï¸ Arquivo principal nÃ£o encontrado, procurando backup...");
      
      for(int i = 0; i <= MaxBackupFiles; i++)
      {
         string backupFile = GetBackupFileName(i);
         if(FileIsExist(backupFile, FILE_COMMON))
         {
            Print("ğŸ”„ Carregando backup: ", backupFile);
            return LoadBrainFromFile(backupFile);
         }
      }
      
      Print("âŒ Nenhum backup encontrado, criando nova memÃ³ria");
      return false;
   }
   
   return LoadBrainFromFile(fn);
}

void ResetQTable()
{
   int sz = NUM_STATES * NUM_ACTIONS;
   
   ArrayResize(g_Q, sz);
   ArrayInitialize(g_Q, 0.0);
   
   ArrayResize(g_stateVisits, NUM_STATES);
   ArrayInitialize(g_stateVisits, 0);
   
   ArrayResize(g_stateLosses, NUM_STATES);
   ArrayInitialize(g_stateLosses, 0);
   
   ArrayResize(g_stateWins, NUM_STATES);
   ArrayInitialize(g_stateWins, 0);
   
   ArrayResize(g_stateLastUpdate, NUM_STATES);
   ArrayInitialize(g_stateLastUpdate, 0);
   
   ArrayResize(g_stateBlocked, NUM_STATES);
   for(int i = 0; i < NUM_STATES; i++)
       g_stateBlocked[i] = false;
   
   ArrayResize(g_stateLastBlockTime, NUM_STATES);
   ArrayInitialize(g_stateLastBlockTime, 0);
   
   ArrayResize(g_stateLastUnblockTime, NUM_STATES);
   ArrayInitialize(g_stateLastUnblockTime, 0);
   
   ArrayResize(g_activeStates, MaxMemoryStates);
   g_activeStatesCount = 0;
   
   g_learningInitialized = true;
   g_totalTrades = g_totalWins = g_totalLosses = 0;
   g_sumProfit = 0.0;
   
   g_totalStatesDiscovered = 0;
   g_totalQUpdates = 0;
   g_averageQValue = 0.0;
   g_maxQValue = 0.0;
   g_minQValue = 0.0;
   
   ArrayResize(g_recentProfits, 100);
   ArrayInitialize(g_recentProfits, 0.0);
   g_recentProfitsIndex = 0;
   
   g_firstTradeDate = 0;
   g_highestProfit = 0.0;
   g_lowestProfit = 0.0;
   g_bestWinStreak = 0;
   g_worstLossStreak = 0;
   g_currentWinStreak = 0;
   g_currentLossStreak = 0;
   
   g_totalBuys = 0;
   g_totalSells = 0;
   g_buyWins = 0;
   g_sellWins = 0;
   g_buyProfit = 0.0;
   g_sellProfit = 0.0;
   
   g_totalDecayCycles = 0;
   g_totalBadStateResets = 0;
   
   InitializeLearningSystem();
   
   Print("ğŸ†• Nova memÃ³ria criada (Sistema Corrigido v307F com Decay e Reset)");
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡Ã•ES AUXILIARES PARA TRAILING STOP
// ======================================================================

void AddPositionToTrailingSystem(ulong ticket)
{
   Sleep(100);
   
   if(!PositionSelectByTicket(ticket)) return;
   
   int index = -1;
   for(int i = 0; i < g_trailingCount; i++)
   {
      if(g_trailingTickets[i] == ticket)
      {
         index = i;
         break;
      }
   }
   
   if(index == -1)
   {
      index = g_trailingCount;
      g_trailingCount++;
      
      ArrayResize(g_trailingTickets, g_trailingCount);
      ArrayResize(g_trailingBestPrices, g_trailingCount);
      ArrayResize(g_trailingCurrentSL, g_trailingCount);
      ArrayResize(g_trailingCurrentTP, g_trailingCount);
      ArrayResize(g_trailingLastTrailTimes, g_trailingCount);
      ArrayResize(g_trailingBreakevenActivated, g_trailingCount);
   }
   
   g_trailingTickets[index] = ticket;
   g_trailingBestPrices[index] = PositionGetDouble(POSITION_PRICE_OPEN);
   g_trailingCurrentSL[index] = PositionGetDouble(POSITION_SL);
   g_trailingCurrentTP[index] = PositionGetDouble(POSITION_TP);
   g_trailingLastTrailTimes[index] = 0;
   g_trailingBreakevenActivated[index] = false;
   
   Print("ğŸ“Š PosiÃ§Ã£o #", ticket, " adicionada ao sistema de trailing stop");
}

void RemovePositionFromTrailingSystem(ulong ticket)
{
   for(int i = 0; i < g_trailingCount; i++)
   {
      if(g_trailingTickets[i] == ticket)
      {
         for(int j = i; j < g_trailingCount - 1; j++)
         {
            g_trailingTickets[j] = g_trailingTickets[j + 1];
            g_trailingBestPrices[j] = g_trailingBestPrices[j + 1];
            g_trailingCurrentSL[j] = g_trailingCurrentSL[j + 1];
            g_trailingCurrentTP[j] = g_trailingCurrentTP[j + 1];
            g_trailingLastTrailTimes[j] = g_trailingLastTrailTimes[j + 1];
            g_trailingBreakevenActivated[j] = g_trailingBreakevenActivated[j + 1];
         }
         g_trailingCount--;
         Print("ğŸ“Š PosiÃ§Ã£o #", ticket, " removida do sistema de trailing stop");
         break;
      }
   }
}

// ======================================================================
// âœ…âœ…âœ… MONITORAMENTO INTELIGENTE DE ESTADOS (CORRIGIDO)
// ======================================================================
void MonitorBadStates()
{
   static datetime lastMonitorTime = 0;
   datetime currentTime = TimeCurrent();
   
   if(currentTime - lastMonitorTime < 300 && g_totalTrades % 15 != 0) 
      return;
   
   lastMonitorTime = currentTime;
   
   Print("ğŸ” MONITORAMENTO SUPER AGRESSIVO DE ESTADOS RUINS");
   
   int bloqueados = 0;
   int resetados = 0;
   int estadosAnalisados = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         estadosAnalisados++;
         double winRate = CalculateWinRate(state);
         
         // âœ… APENAS LOG/MONITORAMENTO - Bloqueio real feito pelo sistema unificado
         
         // Log de estados com win rate baixo (apenas informativo)
         if(g_stateVisits[state] >= MinVisitsForBlockDecision && winRate < 0.25)
         {
            Print("âš ï¸ ALERTA Estado ", state, 
                  " | Win Rate: ", DoubleToString(winRate*100,1), "%",
                  " | Visitas: ", g_stateVisits[state],
                  " | Bloqueado: ", (g_stateBlocked[state] ? "Sim" : "NÃ£o"));
         }
         
         // Log de estados crÃ­ticos (apenas informativo)
         if(g_stateVisits[state] >= MinVisitsForBlockDecision && winRate < 0.15)
         {
            Print("ğŸ”¥ CRÃTICO Estado ", state, 
                  " | Win Rate crÃ­tica: ", DoubleToString(winRate*100,1), "%",
                  " | Visitas: ", g_stateVisits[state],
                  " | Bloqueado: ", (g_stateBlocked[state] ? "Sim" : "NÃ£o"));
         }
         
         // 3. DESBLOQUEAR estados bons
         if(g_stateBlocked[state] && winRate > 0.55 && g_stateVisits[state] >= MinVisitsForBlockDecision)
         {
            g_stateBlocked[state] = false;
            InvalidateHUDCache();
            Print("âœ… DESBLOQUEIO Estado ", state,
                  " | Win Rate boa: ", DoubleToString(winRate*100,1), "%");
         }
      }
   }
   
   Print("ğŸ“Š RESUMO MONITORAMENTO:");
   Print("   Estados analisados: ", estadosAnalisados);
   Print("   Estados bloqueados: ", CountBlockedStates(), " (+", bloqueados, " novos)");
   Print("   Estados resetados: ", resetados);
   Print("   Total resets acumulados: ", g_totalBadStateResets);
   
   // âœ… FORÃ‡AR SAVE apÃ³s monitoramento crÃ­tico
   if(bloqueados > 0 || resetados > 0)
   {
      SaveState();
      g_memoryDirty = true;
   }
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO: DEBUG DE ESTADOS BLOQUEADOS (ATUALIZADA)
// ======================================================================
void DebugBlockedStates()
{
   static datetime lastDebugTime = 0;
   datetime currentTime = TimeCurrent();
   
   if(currentTime - lastDebugTime < 300) return;
   lastDebugTime = currentTime;
   
   int blockedCount = 0;
   int totalVisited = 0;
   int wronglyBlocked = 0;
   int correctlyBlocked = 0;
   
   Print("=== DEBUG: ESTADOS BLOQUEADOS (SISTEMA CORRIGIDO) ===");
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         totalVisited++;
         
         double winRate = CalculateWinRate(state);
         double lossRate = 1.0 - winRate;
         
         if(g_stateBlocked[state])
         {
            blockedCount++;
            
            if(winRate >= UnblockWinRateThreshold && g_stateVisits[state] >= MinVisitsForBlockDecision)
            {
               wronglyBlocked++;
               PrintFormat("âŒâŒâŒ ERRO GRAVE: Estado %d BLOQUEADO mas tem WIN RATE ALTA: %.1f%% | Visitas: %d", 
                     state, winRate*100, g_stateVisits[state]);
               
               if(EnableUnifiedBlockingSystem)
               {
                  UnblockState(state);
               }
            }
            else if(lossRate >= BlockLossRateThreshold && g_stateVisits[state] >= MinVisitsForBlockDecision)
            {
               correctlyBlocked++;
               PrintFormat("â›” Estado %d BLOQUEADO CORRETAMENTE: %.1f%% win | Visitas: %d", 
                     state, winRate*100, g_stateVisits[state]);
            }
            else
            {
               PrintFormat("âš ï¸ Estado %d bloqueado sem dados suficientes: %.1f%% win | Visitas: %d", 
                     state, winRate*100, g_stateVisits[state]);
            }
         }
      }
   }
   
   Print(StringFormat("=== RESUMO: %d visitados | %d bloqueados | %d bloqueados erroneamente | %d bloqueados corretamente ===", 
         totalVisited, blockedCount, wronglyBlocked, correctlyBlocked));
   
   if(wronglyBlocked > 0 && EnableUnifiedBlockingSystem)
   {
      Print("ğŸ”¥ğŸ”¥ğŸ”¥ CORRIGINDO ", wronglyBlocked, " ESTADOS BLOQUEADOS ERRONEAMENTE...");
      AutoUnblockGoodStates();
   }
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO: DEBUG DE CONTAGEM DE TRADES (VERSÃƒO MELHORADA)
// ======================================================================
void DebugTradeCounting()
{
   Print("=== DEBUG CONTAGEM DE TRADES (V2) ===");
   Print("Total Trades: ", g_totalTrades);
   Print("Total Wins: ", g_totalWins);
   Print("Total Losses: ", g_totalLosses);
   Print("Soma Wins+Losses: ", g_totalWins + g_totalLosses);
   Print("DiferenÃ§a (NOPs): ", g_totalTrades - (g_totalWins + g_totalLosses));
   Print("Win Rate: ", g_totalTrades > 0 ? DoubleToString(SafeDivide((double)g_totalWins, (double)g_totalTrades, 0.0)*100, 1) : "0.0", "%");
   
   int estadosComProblema = 0;
   int totalVisitas = 0;
   int totalVitÃ³rias = 0;
   int totalPerdas = 0;
   
   for(int s = 0; s < NUM_STATES; s++)
   {
      if(g_stateVisits[s] > 0)
      {
         totalVisitas += g_stateVisits[s];
         totalVitÃ³rias += g_stateWins[s];
         totalPerdas += g_stateLosses[s];
         
         if(g_stateWins[s] == 0 && g_stateLosses[s] == 0 && g_stateVisits[s] >= 3)
         {
            estadosComProblema++;
            Print("âš ï¸ PROBLEMA: Estado ", s, " tem ", g_stateVisits[s], 
                  " visitas mas 0 vitÃ³rias e 0 perdas!");
            
            // âš ï¸ CORREÃ‡ÃƒO AUTOMÃTICA: Resetar estado problemÃ¡tico
            if(g_stateVisits[s] >= 5)
            {
               Print("ğŸ”„ Resetando estado problemÃ¡tico ", s);
               g_stateVisits[s] = 0;
               g_stateWins[s] = 0;
               g_stateLosses[s] = 0;
               // âœ… NÃƒO desbloquear - preservar bloqueio se existir
               // g_stateBlocked[s] permanece inalterado
               
               for(int a = 0; a < NUM_ACTIONS; a++)
               {
                  g_Q[s * NUM_ACTIONS + a] = 0.0;
               }
            }
         }
         
         // Verificar estados que deveriam estar bloqueados
         if(g_stateVisits[s] >= MinVisitsForBlockDecision)
         {
            double lossRate = SafeDivide((double)g_stateLosses[s], (double)g_stateVisits[s], 0.0);
            if(lossRate >= BlockLossRateThreshold && !g_stateBlocked[s])
            {
               Print("âš ï¸ Estado ", s, " deveria estar bloqueado! Loss rate: ", 
                     DoubleToString(lossRate*100, 1), "%");
            }
         }
      }
   }
   
   Print("=== RESUMO DOS ESTADOS ===");
   Print("Estados ativos: ", g_activeStatesCount);
   Print("Estados com problema: ", estadosComProblema);
   Print("Total visitas em todos estados: ", totalVisitas);
   Print("Total vitÃ³rias em todos estados: ", totalVitÃ³rias);
   Print("Total perdas em todos estados: ", totalPerdas);
   Print("Taxa de vitÃ³ria global estados: ", totalVisitas > 0 ? 
         DoubleToString(SafeDivide((double)totalVitÃ³rias, (double)totalVisitas, 0.0)*100, 1) : "0.0", "%");
   
   if(estadosComProblema > 0)
   {
      Print("ğŸ”¥ğŸ”¥ğŸ”¥ ENCONTRADOS ", estadosComProblema, " ESTADOS PROBLEMÃTICOS!");
      Print("ğŸ”¥ RECOMENDAÃ‡ÃƒO: Executar EmergencyReset()");
   }
   
   Print("=== FIM DEBUG ===");
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO: RESET DE EMERGÃŠNCIA (ADICIONADA)
// ======================================================================
void EmergencyReset()
{
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ RESET DE EMERGÃŠNCIA ATIVADO!");
   
   // Resetar todas as estatÃ­sticas
   g_totalTrades = 0;
   g_totalWins = 0;
   g_totalLosses = 0;
   g_sumProfit = 0.0;
   
   // Resetar Q-table
   for(int i = 0; i < NUM_STATES * NUM_ACTIONS; i++)
   {
      g_Q[i] = 0.0;
   }
   
   // Resetar contadores de estado
   for(int s = 0; s < NUM_STATES; s++)
   {
      g_stateVisits[s] = 0;
      g_stateLosses[s] = 0;
      g_stateWins[s] = 0;
      g_stateBlocked[s] = false;
      g_stateLastBlockTime[s] = 0;
      g_stateLastUnblockTime[s] = 0;
      g_stateLastUpdate[s] = 0;
   }
   
   g_activeStatesCount = 0;
   g_currentExplorationRate = InitialExplorationRate;
   g_tradesToday = 0;
   g_consecutiveLosses = 0;
   g_totalDecayCycles = 0;
   g_totalBadStateResets = 0;
   
   // Resetar arrays
   ArrayInitialize(g_recentProfits, 0.0);
   g_recentProfitsIndex = 0;
   
   SaveBrain();
   SaveState();
   
   Print("âœ… Sistema resetado completamente!");
   Print("ğŸ”„ Reinicie o robÃ´ para comeÃ§ar do zero com contadores corretos.");
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO: DEBUG DE ESTADOS TRAVADOS (NOVA)
// ======================================================================
void DebugStuckStates()
{
   Print("=== DEBUG ESTADOS TRAVADOS ===");
   
   int stuckStates = 0;
   int totalStatesWithVisits = 0;
   int maxVisits = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         totalStatesWithVisits++;
         
         if(g_stateVisits[state] > maxVisits)
            maxVisits = g_stateVisits[state];
            
         // Verificar se estÃ¡ "travado" em mÃºltiplos de 10
         if(g_stateVisits[state] % 10 == 0 && g_stateVisits[state] > 0)
         {
            stuckStates++;
            double winRate = CalculateWinRate(state);
            
            Print("âš ï¸ Estado ", state, " com ", g_stateVisits[state], " visitas",
                  " | Wins: ", g_stateWins[state],
                  " | Losses: ", g_stateLosses[state],
                  " | Win Rate: ", DoubleToString(winRate*100,1), "%",
                  " | Bloqueado: ", g_stateBlocked[state] ? "SIM" : "NÃƒO",
                  " | Ãšltima atualizaÃ§Ã£o: ", g_totalTrades - g_stateLastUpdate[state], " trades atrÃ¡s");
         }
      }
   }
   
   Print("ğŸ“Š ESTATÃSTICAS:");
   Print("   Total estados com visitas: ", totalStatesWithVisits);
   Print("   MÃ¡ximo de visitas em um estado: ", maxVisits);
   Print("   Estados travados (mÃºltiplos de 10): ", stuckStates);
   Print("   Estados com 10+ visitas: ", CountStatesWithMinVisits(10));
   Print("   Estados com 20+ visitas: ", CountStatesWithMinVisits(20));
   Print("   Total BadStateResets: ", g_totalBadStateResets);
   Print("=== FIM DEBUG ===");
}

int CountStatesWithMinVisits(int minVisits)
{
   int count = 0;
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] >= minVisits)
         count++;
   }
   return count;
}

// ======================================================================
// âœ…âœ…âœ… âœ…âœ…âœ… NOVAS FUNÃ‡Ã•ES ADICIONADAS
// ======================================================================

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO: CORREÃ‡ÃƒO DE EMERGÃŠNCIA DOS CONTADORES
// ======================================================================
void EmergencyCounterFix()
{
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ CORREÃ‡ÃƒO DE EMERGÃŠNCIA DOS CONTADORES");
   
   int fixedStates = 0;
   int unblockedStates = 0;
   int corruptedStates = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         // âœ… CORRIGIR CONTADORES INCONSISTENTES
         if(g_stateWins[state] > g_stateVisits[state])
         {
            Print("âŒâŒâŒ ERRO CRÃTICO: Estado ", state, 
                  " | Visitas: ", g_stateVisits[state],
                  " | VitÃ³rias: ", g_stateWins[state], " (IMPOSSÃVEL!)");
            
            // CorreÃ§Ã£o: Recalcular baseado em win rate realista
            double estimatedWinRate = 0.3; // Assumir 30% win rate
            g_stateWins[state] = (int)(g_stateVisits[state] * estimatedWinRate);
            g_stateLosses[state] = g_stateVisits[state] - g_stateWins[state];
            
            corruptedStates++;
            fixedStates++;
         }
         
         // âœ… DESBLOQUEAR ESTADOS BLOQUEADOS ERRONEAMENTE
         if(g_stateBlocked[state])
         {
            double winRate = CalculateWinRate(state);
            
            // Regras mais sensatas para desbloqueio
            if((g_stateVisits[state] < 5 && winRate > 0.1) || // Poucas visitas com alguma vitÃ³ria
               (g_stateVisits[state] >= 5 && winRate >= 0.25)) // Win rate razoÃ¡vel
            {
               g_stateBlocked[state] = false;
               unblockedStates++;
               Print("âœ… Estado ", state, " desbloqueado | Win rate: ", 
                     DoubleToString(winRate*100,1), "% | Visitas: ", g_stateVisits[state]);
            }
         }
         
         // âœ… CORRIGIR ESTADOS COM 0 VISITAS MAS COM CONTADORES
         if(g_stateVisits[state] == 0 && (g_stateWins[state] > 0 || g_stateLosses[state] > 0))
         {
            Print("ğŸ”„ Estado ", state, " com contadores mas 0 visitas - resetando");
            g_stateWins[state] = 0;
            g_stateLosses[state] = 0;
            g_stateBlocked[state] = false;
            fixedStates++;
         }
      }
   }
   
   // âœ… CORRIGIR ESTATÃSTICAS GLOBAIS
   int totalVisits = 0;
   int totalWins = 0;
   int totalLosses = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      totalVisits += g_stateVisits[state];
      totalWins += g_stateWins[state];
      totalLosses += g_stateLosses[state];
   }
   
   // Recalcular totais
   g_totalTrades = totalVisits; // Cada visita = 1 trade real
   g_totalWins = totalWins;
   g_totalLosses = totalLosses;
   
   Print("ğŸ“Š RESUMO DA CORREÃ‡ÃƒO:");
   Print("   Estados com dados corruptos: ", corruptedStates);
   Print("   Estados corrigidos: ", fixedStates);
   Print("   Estados desbloqueados: ", unblockedStates);
   Print("   Novos totais:");
   Print("     Total Visitas: ", totalVisits);
   Print("     Total VitÃ³rias: ", totalWins);
   Print("     Total Perdas: ", totalLosses);
   Print("     Win Rate: ", totalVisits > 0 ? 
         DoubleToString((double)totalWins/totalVisits*100, 1) : "0.0", "%");
   
   // ForÃ§ar save
   g_memoryDirty = true;
   SaveState();
   SaveBrain();
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO: REVISÃƒO COMPLETA DO SISTEMA DE BLOQUEIO
// ======================================================================
void OverhaulBlockingSystem()
{
   Print("ğŸ”„ REVISÃƒO COMPLETA DO SISTEMA DE BLOQUEIO");
   
   int blockedBefore = CountBlockedStates();
   int totalVisited = g_activeStatesCount;
   
   // âœ… NOVAS REGRAS INTELIGENTES
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         double winRate = CalculateWinRate(state);
         
         // âœ… REGRAS PARA BLOQUEIO (MAIS RESTRITIVAS)
         bool shouldBeBlocked = false;
         
         // 1. Muito ruim com histÃ³rico suficiente
         if(g_stateVisits[state] >= MinVisitsForBlockDecision && winRate < 0.20)
         {
            shouldBeBlocked = true;
         }
         // 2. CatastrÃ³fico mesmo com histÃ³rico mÃ­nimo
         else if(g_stateVisits[state] >= MinVisitsForBlockDecision && winRate < 0.10)
         {
            shouldBeBlocked = true;
         }
         // 3. Nunca ganhou com visitas significativas
         else if(g_stateVisits[state] >= MinVisitsForBlockDecision && winRate == 0.0)
         {
            shouldBeBlocked = true;
         }
         
         // âœ… REGRAS PARA DESBLOQUEIO (MAIS LENIENTES)
         bool shouldBeUnblocked = false;
         
         // 1. Performance aceitÃ¡vel
         if(g_stateVisits[state] >= MinVisitsForBlockDecision && winRate >= 0.30)
         {
            shouldBeUnblocked = true;
         }
         // 2. Poucas visitas, nÃ£o bloquear prematuramente
         else if(g_stateVisits[state] < 5)
         {
            shouldBeUnblocked = true;
         }
         // 3. Mostrando melhoria recente
         else if(g_stateBlocked[state] && winRate >= 0.25)
         {
            shouldBeUnblocked = true;
         }
         
         // APLICAR DECISÃƒO
         if(shouldBeBlocked && !g_stateBlocked[state])
         {
            g_stateBlocked[state] = true;
         }
         else if(shouldBeUnblocked && g_stateBlocked[state])
         {
            g_stateBlocked[state] = false;
         }
      }
   }
   
   int blockedAfter = CountBlockedStates();
   
   Print("ğŸ“Š RESULTADO DA REVISÃƒO:");
   Print("   Estados visitados: ", totalVisited);
   Print("   Bloqueados antes: ", blockedBefore, " (", 
         totalVisited > 0 ? DoubleToString((double)blockedBefore/totalVisited*100,1) : "0", "%)");
   Print("   Bloqueados depois: ", blockedAfter, " (", 
         totalVisited > 0 ? DoubleToString((double)blockedAfter/totalVisited*100,1) : "0", "%)");
   Print("   MudanÃ§a: ", blockedAfter - blockedBefore);
   
   g_memoryDirty = true;
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO: RESET PARCIAL INTELIGENTE
// ======================================================================
void IntelligentPartialReset()
{
   // âœ… PROTEÃ‡ÃƒO: NÃ£o resetar atÃ© ter base sÃ³lida de estados aprendidos
   if(g_activeStatesCount < MinStatesBeforeReset)
   {
      return; // NÃ£o resetar atÃ© ter aprendido estados suficientes
   }
   
   Print("ğŸ§  RESET PARCIAL INTELIGENTE");
   
   int statesReset = 0;
   int statesRetained = 0;
   
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         double winRate = CalculateWinRate(state);
         
         // âœ… CRITÃ‰RIOS PARA RESET COMPLETO (usar MinVisitsForBlockDecision)
         if((g_stateVisits[state] >= MinVisitsForBlockDecision && winRate < 0.15) || // Muito ruim
            (g_stateVisits[state] >= MinVisitsForBlockDecision && winRate == 0.0) ||  // Nunca ganhou
            (g_stateVisits[state] > MinVisitsForBlockDecision && winRate < 0.25))    // HistÃ³rico longo ruim
         {
            // Reset completo
            g_stateVisits[state] = 0;
            g_stateWins[state] = 0;
            g_stateLosses[state] = 0;
            g_stateBlocked[state] = false;
            
            for(int a = 0; a < NUM_ACTIONS; a++)
            {
               g_Q[state * NUM_ACTIONS + a] = 0.0;
            }
            
            statesReset++;
         }
         // âœ… RESET PARCIAL PARA ESTADOS MÃ‰DIOS
         else if(g_stateVisits[state] >= MinVisitsForBlockDecision && winRate < 0.30)
         {
            // Manter 30% da memÃ³ria
            g_stateVisits[state] = (int)(g_stateVisits[state] * 0.3);
            g_stateWins[state] = (int)(g_stateWins[state] * 0.3);
            g_stateLosses[state] = (int)(g_stateLosses[state] * 0.3);
            
            // Garantir mÃ­nimos
            if(g_stateVisits[state] < 1) g_stateVisits[state] = 1;
            if(g_stateWins[state] < 0) g_stateWins[state] = 0;
            if(g_stateLosses[state] < 0) g_stateLosses[state] = 0;
            
            // Reduzir Q-values
            for(int a = 0; a < NUM_ACTIONS; a++)
            {
               g_Q[state * NUM_ACTIONS + a] *= 0.3;
            }
            
            statesRetained++;
         }
         else
         {
            statesRetained++;
         }
      }
   }
   
   // Recalcular estados ativos
   g_activeStatesCount = 0;
   for(int state = 0; state < NUM_STATES; state++)
   {
      if(g_stateVisits[state] > 0)
      {
         if(g_activeStatesCount < MaxMemoryStates)
         {
            g_activeStates[g_activeStatesCount] = state;
            g_activeStatesCount++;
         }
      }
   }
   
   Print("ğŸ“Š RESULTADO DO RESET:");
   Print("   Estados resetados completamente: ", statesReset);
   Print("   Estados mantidos (com reduÃ§Ã£o): ", statesRetained);
   Print("   Total estados ativos apÃ³s reset: ", g_activeStatesCount);
   
   g_memoryDirty = true;
   SaveState();
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO: OTIMIZAR PARÃ‚METROS DINAMICAMENTE
// ======================================================================
void OptimizeParametersDynamically()
{
   Print("âš™ï¸ OTIMIZANDO PARÃ‚METROS DINAMICAMENTE");
   
   // âœ… AJUSTAR EXPLORAÃ‡ÃƒO BASEADO NA PERFORMANCE
   double currentWinRate = SafeDivide((double)g_totalWins, (double)g_totalTrades, 0.0);
   
   if(currentWinRate < 0.25)
   {
      // Performance ruim, aumentar exploraÃ§Ã£o
      g_currentExplorationRate = MathMin(g_currentExplorationRate * 1.2, 0.8);
      Print("ğŸ“ˆ Aumentando exploraÃ§Ã£o para ", DoubleToString(g_currentExplorationRate*100,1), 
            "% (win rate baixa: ", DoubleToString(currentWinRate*100,1), "%)");
   }
   else if(currentWinRate > 0.35)
   {
      // Performance boa, reduzir exploraÃ§Ã£o
      g_currentExplorationRate = MathMax(g_currentExplorationRate * 0.9, MinExplorationRate);
      Print("ğŸ“‰ Reduzindo exploraÃ§Ã£o para ", DoubleToString(g_currentExplorationRate*100,1), 
            "% (win rate boa: ", DoubleToString(currentWinRate*100,1), "%)");
   }
   
   // âœ… AJUSTAR LEARNING RATE
   if(g_totalTrades > 500)
   {
      LearningRate = 0.01; // Reduzir apÃ³s muitos trades
      Print("ğŸ“ Learning rate ajustado para 0.01 (maturidade do sistema)");
   }
   
   // âœ… AJUSTAR LIMITES DE BLOQUEIO
   if(g_activeStatesCount > 100)
   {
      MinVisitsForBlockDecision = 8; // Exigir mais visitas
      Print("ğŸ›¡ï¸ MÃ­nimo visitas para bloqueio ajustado para 8");
   }
   
   g_memoryDirty = true;
}

// ======================================================================
// âœ… HUD LEVE - FUNÃ‡Ã•ES OTIMIZADAS
// ======================================================================

void CreateHUDObjects()
{
   if(!ShowHUD || hudObjectCount > 0) return;
   
   int lineHeight = 18;
   int currentY = HUD_Y;
   
   Print("ğŸ› ï¸ Criando objetos do HUD...");
   
   if(ObjectCreate(0, "HUD_Title", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Title", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Title", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Title", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Title", OBJPROP_COLOR, HUD_TitleColor);
      ObjectSetInteger(0, "HUD_Title", OBJPROP_FONTSIZE, 11);
      ObjectSetString(0, "HUD_Title", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Title", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Title", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Title", OBJPROP_TEXT, "PHOENIX TRADER v307F SUPER CORRIGIDO");
      hudObjects[hudObjectCount++] = "HUD_Title";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Divider", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Divider", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Divider", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Divider", OBJPROP_TEXT, "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
      hudObjects[hudObjectCount++] = "HUD_Divider";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_States", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_States", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_States", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_States", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_States", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_States", OBJPROP_FONTSIZE, 10);
      ObjectSetString(0, "HUD_States", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_States", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_States", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_States", OBJPROP_TEXT, "Estados: 0/" + IntegerToString(NUM_STATES));
      hudObjects[hudObjectCount++] = "HUD_States";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Progress", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_COLOR, HUD_SuccessColor);
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Progress", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Progress", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Progress", OBJPROP_TEXT, "   [â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘] (0.0%)");
      hudObjects[hudObjectCount++] = "HUD_Progress";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Blocked", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Blocked", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Blocked", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Blocked", OBJPROP_TEXT, "   Bloqueados: 0 (0.0%)");
      hudObjects[hudObjectCount++] = "HUD_Blocked";
      currentY += lineHeight + 5;
   }
   
   if(ObjectCreate(0, "HUD_DecayInfo", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_COLOR, clrYellow);
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_DecayInfo", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_DecayInfo", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_DecayInfo", OBJPROP_TEXT, "   Decay: Ativo | Ciclos: 0");
      hudObjects[hudObjectCount++] = "HUD_DecayInfo";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Direction", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_COLOR, clrGray);
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_FONTSIZE, 10);
      ObjectSetString(0, "HUD_Direction", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Direction", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Direction", OBJPROP_TEXT, "DireÃ§Ã£o: â— NEUTRO");
      hudObjects[hudObjectCount++] = "HUD_Direction";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Positions", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Positions", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Positions", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Positions", OBJPROP_TEXT, "   PosiÃ§Ãµes ativas: 0");
      hudObjects[hudObjectCount++] = "HUD_Positions";
      currentY += lineHeight + 5;
   }
   
   if(ObjectCreate(0, "HUD_Status", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Status", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Status", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Status", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Status", OBJPROP_COLOR, HUD_WarningColor);
      ObjectSetInteger(0, "HUD_Status", OBJPROP_FONTSIZE, 10);
      ObjectSetString(0, "HUD_Status", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Status", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Status", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Status", OBJPROP_TEXT, "STATUS: Inicializando...");
      hudObjects[hudObjectCount++] = "HUD_Status";
      currentY += lineHeight;
   }
   
   if(ObjectCreate(0, "HUD_Volume", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Volume", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Volume", OBJPROP_TEXT, "Volume: NORMAL (1.0x)");
      hudObjects[hudObjectCount++] = "HUD_Volume";
      currentY += lineHeight - 5;
   }
   
   if(ObjectCreate(0, "HUD_Exploration", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Exploration", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Exploration", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Exploration", OBJPROP_TEXT, "ExploraÃ§Ã£o: 50%");
      hudObjects[hudObjectCount++] = "HUD_Exploration";
      currentY += lineHeight - 5;
   }
   
   if(ObjectCreate(0, "HUD_Trades", OBJ_LABEL, 0, 0, 0))
   {
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_CORNER, CORNER_LEFT_UPPER);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_XDISTANCE, HUD_X);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_YDISTANCE, currentY);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_COLOR, HUD_TextColor);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_FONTSIZE, 9);
      ObjectSetString(0, "HUD_Trades", OBJPROP_FONT, "Arial");
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_BACK, false);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_SELECTABLE, false);
      ObjectSetString(0, "HUD_Trades", OBJPROP_TEXT, "Trades hoje: 0/30");
      hudObjects[hudObjectCount++] = "HUD_Trades";
   }
   
   Print("âœ… HUD criado com ", hudObjectCount, " objetos");
}

string CreateProgressBarFast(int current, int total)
{
   static string bars[21] = {
      "â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–‘",
      "â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“â–“"
   };
   
   if(total <= 0) total = 1;
   int index = (int)MathRound((double)current / total * 20);
   if(index < 0) index = 0;
   if(index > 20) index = 20;
   
   return bars[index];
}

string GetDirectionIconFast(int direction)
{
   if(direction == 1) return "â–²";
   if(direction == 2) return "â–¼";
   return "â—";
}

color GetDirectionColorFast(int direction)
{
   if(direction == 1) return clrLime;
   if(direction == 2) return clrRed;
   return clrGray;
}

void UpdateHUDLight()
{
   if(!ShowHUD) 
   {
      RemoveHUD();
      return;
   }
   
   if(hudObjectCount == 0)
   {
      CreateHUDObjects();
      ChartRedraw(0);
      return;
   }
   
   datetime currentTime = TimeCurrent();
   if(currentTime - hudLastUpdate < HUD_UpdateMS/1000 && !HUD_Minimal) return;
   hudLastUpdate = currentTime;
   
   int visitedStates = cachedVisitedStates;
   if(visitedStates < 0)
   {
      visitedStates = g_activeStatesCount;
      cachedVisitedStates = visitedStates;
   }
   
   int blockedStates = cachedBlockedStates;
   if(blockedStates < 0)
   {
      blockedStates = CountBlockedStates();
      cachedBlockedStates = blockedStates;
   }
   
   int totalPositions = cachedPositions;
   if(totalPositions < 0)
   {
      totalPositions = GetTotalPositions();
      cachedPositions = totalPositions;
   }
   
   int currentDir = cachedDirection;
   if(currentDir < 0)
   {
      currentDir = GetCurrentPositionsDirection();
      cachedDirection = currentDir;
   }
   
   string newTitle = "ğŸ›¡ï¸ PHOENIX TRADER v307F SUPER CORRIGIDO";
   ObjectSetString(0, "HUD_Title", OBJPROP_TEXT, newTitle);
   
   string newStates = StringFormat("Estados: %d/%d", visitedStates, NUM_STATES);
   ObjectSetString(0, "HUD_States", OBJPROP_TEXT, newStates);
   
   string progressBar = CreateProgressBarFast(visitedStates, NUM_STATES);
   double progressPercent = SafeDivide((double)visitedStates, (double)NUM_STATES, 0.0) * 100.0;
   
   // ğŸ”§ CORREÃ‡ÃƒO: Converter double para string corretamente
   string newProgress = StringFormat("   [%s] (%.1f%%)", progressBar, progressPercent);
   ObjectSetString(0, "HUD_Progress", OBJPROP_TEXT, newProgress);
   
   double blockedPercent = SafeDivide((double)blockedStates, (double)visitedStates, 0.0) * 100.0;
   string newBlocked = StringFormat("   Bloqueados: %d (%.1f%%)", blockedStates, blockedPercent);
   color blockedColor = (blockedStates > 0) ? HUD_WarningColor : HUD_TextColor;
   ObjectSetInteger(0, "HUD_Blocked", OBJPROP_COLOR, blockedColor);
   ObjectSetString(0, "HUD_Blocked", OBJPROP_TEXT, newBlocked);
   
   string decayInfo = StringFormat("   Decay: %s | Ciclos: %d | Resets: %d", 
                                   EnableMemoryDecay ? "Ativo" : "Inativo",
                                   g_totalDecayCycles,
                                   g_totalBadStateResets);
   ObjectSetString(0, "HUD_DecayInfo", OBJPROP_TEXT, decayInfo);
   
   string directionIcon = GetDirectionIconFast(currentDir);
   string directionText = (currentDir == 1) ? "BUY" : (currentDir == 2) ? "SELL" : "NEUTRO";
   color dirColor = GetDirectionColorFast(currentDir);
   string newDirection = StringFormat("DireÃ§Ã£o: %s %s", directionIcon, directionText);
   ObjectSetInteger(0, "HUD_Direction", OBJPROP_COLOR, dirColor);
   ObjectSetString(0, "HUD_Direction", OBJPROP_TEXT, newDirection);
   
   string positionsText = StringFormat("   PosiÃ§Ãµes ativas: %d", totalPositions);
   ObjectSetString(0, "HUD_Positions", OBJPROP_TEXT, positionsText);
   
   color statusColor = HUD_TextColor;
   if(StringFind(g_statusMessage, "â›”") >= 0) statusColor = HUD_ErrorColor;
   else if(StringFind(g_statusMessage, "âœ…") >= 0) statusColor = HUD_SuccessColor;
   else if(StringFind(g_statusMessage, "âš ï¸") >= 0) statusColor = HUD_WarningColor;
   
   if(cachedStatus != g_statusMessage)
   {
      ObjectSetInteger(0, "HUD_Status", OBJPROP_COLOR, statusColor);
      ObjectSetString(0, "HUD_Status", OBJPROP_TEXT, "STATUS: " + g_statusMessage);
      cachedStatus = g_statusMessage;
   }
   
   if(cachedVolume != g_volumeMultiplier)
   {
      string volumeStatus = "Volume: ";
      color volumeColor = HUD_TextColor;
      
      if(UseRealVolumeFilter)
      {
         if(g_volumeMultiplier >= 1.10)
         {
            volumeStatus += StringFormat("ALTO (%.1fx)", g_volumeMultiplier);
            volumeColor = HUD_SuccessColor;
         }
         else if(g_volumeMultiplier >= 1.00)
         {
            volumeStatus += StringFormat("NORMAL (%.1fx)", g_volumeMultiplier);
         }
         else if(g_volumeMultiplier >= 0.05)
         {
            volumeStatus += StringFormat("BAIXO (%.1fx)", g_volumeMultiplier);
            volumeColor = HUD_WarningColor;
         }
         else
         {
            volumeStatus += StringFormat("MUITO BAIXO (%.1fx)", g_volumeMultiplier);
            volumeColor = HUD_ErrorColor;
         }
      }
      else
      {
         volumeStatus += "DESATIVADO";
      }
      
      ObjectSetInteger(0, "HUD_Volume", OBJPROP_COLOR, volumeColor);
      ObjectSetString(0, "HUD_Volume", OBJPROP_TEXT, volumeStatus);
      cachedVolume = g_volumeMultiplier;
   }
   
   double explorationRatePercent = g_currentExplorationRate * 100;
   // âš ï¸ GARANTIR QUE NÃƒO PASSE DE 100%
   if(explorationRatePercent > 100.0) explorationRatePercent = 100.0;
   string newExploration = StringFormat("ExploraÃ§Ã£o: %.0f%%", explorationRatePercent);
   ObjectSetString(0, "HUD_Exploration", OBJPROP_TEXT, newExploration);
   
   if(cachedTradesToday != g_tradesToday)
   {
      color tradesColor = (g_tradesToday >= MaxTradesPerDay) ? HUD_ErrorColor : HUD_TextColor;
      string newTrades = StringFormat("Trades hoje: %d/%d", g_tradesToday, MaxTradesPerDay);
      ObjectSetInteger(0, "HUD_Trades", OBJPROP_COLOR, tradesColor);
      ObjectSetString(0, "HUD_Trades", OBJPROP_TEXT, newTrades);
      cachedTradesToday = g_tradesToday;
   }
   
   ChartRedraw(0);
}

void InvalidateHUDCache()
{
   cachedVisitedStates = -1;
   cachedBlockedStates = -1;
   cachedPositions = -1;
   cachedDirection = -1;
   cachedStatus = "";
   cachedVolume = -1;
   cachedTradesToday = -1;
}

void RemoveHUD()
{
   for(int i = 0; i < hudObjectCount; i++)
   {
      if(hudObjects[i] != "")
      {
         ObjectDelete(0, hudObjects[i]);
      }
   }
   hudObjectCount = 0;
   InvalidateHUDCache();
   ChartRedraw(0);
}

// ======================================================================
// âœ… VERIFICAR VOLUME REAL - VERSÃƒO SIMPLIFICADA
// ======================================================================
bool CheckRealVolume()
{
   if(!UseRealVolumeFilter) 
   {
      g_volumeStrength = 1.0;
      return true;
   }
   
   long volumeArray[];
   int barsToCopy = VolumeMAPeriod + 1;
   
   if(CopyTickVolume(_Symbol, _Period, 1, barsToCopy, volumeArray) < barsToCopy)
   {
      Print("âš ï¸ Erro ao ler volume. Recebidos: ", ArraySize(volumeArray), " de ", barsToCopy);
      g_volumeStrength = 0.5;
      return true;
   }
   
   g_currentVolume = volumeArray[barsToCopy - 1];
   
   long sumVol = 0;
   for(int i = 0; i < barsToCopy - 1; i++)
   {
      sumVol += volumeArray[i];
   }
   
   g_volumeAverage = (long)(sumVol / (barsToCopy - 1));
   
   if(g_volumeAverage > 0)
   {
      g_volumeMultiplier = SafeDivide((double)g_currentVolume, (double)g_volumeAverage, 1.0);
      g_volumeStrength = g_volumeMultiplier;
      cachedVolume = -1;
   }
   else
   {
      g_volumeMultiplier = 1.0;
      g_volumeStrength = 1.0;
      return true;
   }
   
   bool isVolumeStrong = g_volumeMultiplier >= MinVolumeMultiplier;
   
   return isVolumeStrong;
}

// ======================================================================
// âœ…âœ…âœ… TRAILING STOP DINÃ‚MICO CORRIGIDO
// ======================================================================

void ManageDynamicTrailingStop()
{
   if(!UseDynamicTrailingStop) 
   {
      if(g_trailingCount > 0)
      {
         ArrayResize(g_trailingTickets, 0);
         ArrayResize(g_trailingBestPrices, 0);
         ArrayResize(g_trailingCurrentSL, 0);
         ArrayResize(g_trailingCurrentTP, 0);
         ArrayResize(g_trailingLastTrailTimes, 0);
         ArrayResize(g_trailingBreakevenActivated, 0);
         g_trailingCount = 0;
      }
      return;
   }
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      long type = PositionGetInteger(POSITION_TYPE);
      bool isBuy = (type == POSITION_TYPE_BUY);
      
      double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
      double currentSL = PositionGetDouble(POSITION_SL);
      double currentTP = PositionGetDouble(POSITION_TP);
      double currentPrice = isBuy ? 
         SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
         SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
      
      // Validar point antes de usar - valor zero indica problema de configuraÃ§Ã£o
      if(point <= 0 || point < 0.0000001)
      {
         Print("âš ï¸ ERRO: Point invÃ¡lido para sÃ­mbolo ", _Symbol, ": ", point);
         continue;
      }
      
      double currentProfit = isBuy ? 
         SafeDivide(currentPrice - entryPrice, point, 0.0) : 
         SafeDivide(entryPrice - currentPrice, point, 0.0);
      
      int trailIndex = -1;
      for(int j = 0; j < g_trailingCount; j++)
      {
         if(g_trailingTickets[j] == ticket)
         {
            trailIndex = j;
            break;
         }
      }
      
      if(trailIndex == -1)
      {
         AddPositionToTrailingSystem(ticket);
         continue;
      }
      
      if(isBuy)
      {
         if(currentPrice > g_trailingBestPrices[trailIndex])
         {
            g_trailingBestPrices[trailIndex] = currentPrice;
         }
      }
      else
      {
         if(currentPrice < g_trailingBestPrices[trailIndex])
         {
            g_trailingBestPrices[trailIndex] = currentPrice;
         }
      }
      
      bool shouldAdjust = false;
      double newSL = currentSL;
      double newTP = currentTP;
      
      if(UseBreakevenStop && !g_trailingBreakevenActivated[trailIndex] && 
         MathAbs(currentProfit) >= BreakevenTriggerPoints)
      {
         double breakevenPrice = entryPrice;
         
         if(isBuy) breakevenPrice += point * 10;
         else breakevenPrice -= point * 10;
         
         if((isBuy && currentPrice > breakevenPrice) || 
            (!isBuy && currentPrice < breakevenPrice))
         {
            newSL = breakevenPrice;
            g_trailingBreakevenActivated[trailIndex] = true;
            shouldAdjust = true;
            Print("ğŸ’° BREAKEVEN ativado para posiÃ§Ã£o #", ticket, 
                  " | SL ajustado para: ", newSL);
         }
      }
      
      if(MathAbs(currentProfit) >= TrailingStartPoints)
      {
         double trailingDistancePoints = TrailingStopPoints;
         
         if(UseATRTrailing)
         {
            double atr[];
            if(CopyBuffer(g_atrHandle, 0, 0, 1, atr) >= 1)
            {
               trailingDistancePoints = (atr[0] / point) * ATRTrailingMultiplier;
               Print("ğŸ“ Trailing usando ATR: ", atr[0], " -> ", trailingDistancePoints, " pontos");
            }
         }
         
         double trailingDistance = trailingDistancePoints * point;
         double stepDistance = TrailingStepPoints * point;
         
         if(isBuy)
         {
            double desiredStop = g_trailingBestPrices[trailIndex] - trailingDistance;
            
            if(desiredStop > currentSL || currentSL == 0)
            {
               if(MathAbs(desiredStop - currentSL) >= stepDistance || currentSL == 0)
               {
                  newSL = desiredStop;
                  shouldAdjust = true;
               }
            }
            
            if(TrailBothSLandTP && currentTP > 0)
            {
               double desiredTP = g_trailingBestPrices[trailIndex] + (trailingDistance * 0.8);
               if(desiredTP > currentTP)
               {
                  newTP = desiredTP;
                  shouldAdjust = true;
               }
            }
         }
         else
         {
            double desiredStop = g_trailingBestPrices[trailIndex] + trailingDistance;
            
            if(desiredStop < currentSL || currentSL == 0)
            {
               if(MathAbs(desiredStop - currentSL) >= stepDistance || currentSL == 0)
               {
                  newSL = desiredStop;
                  shouldAdjust = true;
               }
            }
            
            if(TrailBothSLandTP && currentTP > 0)
            {
               double desiredTP = g_trailingBestPrices[trailIndex] - (trailingDistance * 0.8);
               if(desiredTP < currentTP)
               {
                  newTP = desiredTP;
                  shouldAdjust = true;
               }
            }
         }
      }
      
      if(shouldAdjust && (newSL != currentSL || newTP != currentTP))
      {
         datetime currentTime = TimeCurrent();
         if(currentTime - g_trailingLastTrailTimes[trailIndex] >= 30)
         {
            if(trade.PositionModify(ticket, newSL, newTP))
            {
               g_trailingCurrentSL[trailIndex] = newSL;
               g_trailingCurrentTP[trailIndex] = newTP;
               g_trailingLastTrailTimes[trailIndex] = currentTime;
               
               double slPoints = MathAbs(newSL - entryPrice) / point;
               double tpPoints = MathAbs(newTP - entryPrice) / point;
               
               string trailingType = UseATRTrailing ? "ATR" : "Fixo";
               Print("ğŸ“ˆ TRAILING STOP (", trailingType, ") ajustado para posiÃ§Ã£o #", ticket,
                     " | Novo SL: ", newSL, " (", slPoints, " pontos)",
                     " | Novo TP: ", newTP, " (", tpPoints, " pontos)",
                     " | Lucro atual: ", currentProfit, " pontos");
            }
            else
            {
               Print("âŒ Falha ao ajustar trailing stop para posiÃ§Ã£o #", ticket,
                     " | Erro: ", GetLastError());
            }
         }
      }
   }
}

void ManageAllDynamicStops()
{
   ManageDynamicTrailingStop();
   
   for(int i = g_trailingCount - 1; i >= 0; i--)
   {
      if(!PositionSelectByTicket(g_trailingTickets[i]))
      {
         RemovePositionFromTrailingSystem(g_trailingTickets[i]);
      }
   }
}

// ======================================================================
// âœ…âœ…âœ… âœ…âœ…âœ… FUNÃ‡ÃƒO PRINCIPAL CORRIGIDA: UpdateQ (APENAS CHAMAR PARA TRADES REAIS)
// ======================================================================
void UpdateQ(int state, int action, double reward)
{
   if(state < 0 || state >= NUM_STATES) return;
   if(action < 0 || action >= NUM_ACTIONS) return;
   if(ArraySize(g_Q) <= state * NUM_ACTIONS + action) return;
   
   // âœ… REMOVER QUALQUER VERIFICAÃ‡ÃƒO DE LIMITE DE VISITAS
   // NÃƒO DEVE TER: if(g_stateVisits[state] >= 10) return;
   
   // âœ… DEBUG EXPANDIDO
   static int updateCounter = 0;
   updateCounter++;
   
   if(updateCounter % 50 == 0)
   {
      Print("ğŸ” UpdateQ #", updateCounter, 
            " | Estado: ", state, 
            " | Visitas: ", g_stateVisits[state],
            " | Action: ", (action==0?"NOP":(action==1?"BUY":"SELL")),
            " | Reward: ", reward);
   }
   
   if(!g_lastTradeExecuted) 
   {
      Print("âš ï¸ ATENÃ‡ÃƒO: Tentativa de atualizar Q sem trade executado");
      return;
   }
   
   AddActiveState(state);
   
   int idx = state * NUM_ACTIONS + action;
   
   double alpha = LearningRate;
   double old = g_Q[idx];
   double newq = old + alpha * (reward - old);
   
   g_Q[idx] = CompressQValue(newq);
   
   g_stateLastUpdate[state] = g_totalTrades;
   
   // âœ… ATUALIZAR CONTADORES DE VISITAS APENAS PARA TRADES REAIS
   if(action == 1 || action == 2) // BUY ou SELL
   {
      g_stateVisits[state]++;
      
      if(reward > 0)
      {
         g_stateWins[state]++;
      }
      else
      {
         g_stateLosses[state]++;
      }
   }
   
   // âœ… VERIFICAÃ‡ÃƒO DE BLOQUEIO MAIS INTELIGENTE
   if(EnableUnifiedBlockingSystem && g_stateVisits[state] >= MinVisitsForBlockDecision)
   {
      double winRate = CalculateWinRate(state);
      
      // SÃ³ bloquear se realmente for muito ruim - SEM verificaÃ§Ã£o adicional de visitas
      if(winRate < 0.25)
      {
         g_stateBlocked[state] = true;
         Print("â›” Estado ", state, " bloqueado - Win rate muito baixa: ", 
               DoubleToString(winRate*100,1), "%");
      }
      else if(g_stateBlocked[state] && winRate >= 0.40)
      {
         g_stateBlocked[state] = false;
         Print("âœ… Estado ", state, " desbloqueado - Win rate melhorou: ", 
               DoubleToString(winRate*100,1), "%");
      }
   }
   
   g_memoryDirty = true;
   
   // âœ… EXPLORAÃ‡ÃƒO DINÃ‚MICA BASEADA EM PERFORMANCE
   if(reward > 0)
   {
      // Reduzir exploraÃ§Ã£o apÃ³s vitÃ³ria
      g_currentExplorationRate *= ExplorationDecay;
   }
   else if(reward < -1.0)
   {
      // Aumentar exploraÃ§Ã£o apÃ³s perda grande
      g_currentExplorationRate = MathMin(g_currentExplorationRate * 1.1, 0.7);
   }
   
   // âœ… GARANTIR LIMITES
   if(g_currentExplorationRate > 1.0) g_currentExplorationRate = 1.0;
   if(g_currentExplorationRate < MinExplorationRate) g_currentExplorationRate = MinExplorationRate;
   
   g_qUpdatesSinceSave++;
   g_totalQUpdates++;
   
   // âœ… DECAY PERIÃ“DICO REMOVIDO
   // Decay Ã© aplicado apenas pela manutenÃ§Ã£o periÃ³dica (hourly)
   // para evitar aplicaÃ§Ã£o excessiva que limitava visitas
   
   // âœ… SAVE PERIÃ“DICO
   if(g_qUpdatesSinceSave >= 3)
   {
      SaveBrain();
   }
   
   // âœ… CorreÃ§Ãµes periÃ³dicas removidas (FixStuckStatesProblem desabilitada)
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO CORRIGIDA: UpdateQ_NOP (NÃƒO CONTA COMO PERDA)
// ======================================================================
void UpdateQ_NOP(int state)
{
   if(state < 0) return;
  
   Print("ğŸ“Š NOP registrado para estado ", state, " (nÃ£o conta como visita/perda real)");
   
   if(ExcludeNOPFromVisits)
   {
      // NOP nÃ£o incrementa contadores de visita/perda
      Print("âœ… NOP excluÃ­do de contagens (configuraÃ§Ã£o ativa)");
   }
   
   if(ArraySize(g_Q) > state * NUM_ACTIONS)
   {
      int idx = state * NUM_ACTIONS;
      double oldQ = g_Q[idx];
      double newQ = oldQ - 0.001;
      g_Q[idx] = CompressQValue(newQ);
      
      g_memoryDirty = true;
   }
}

// ======================================================================
// âœ…âœ…âœ… ChooseAction - COM SISTEMA CORRIGIDO (VERSÃƒO MODIFICADA)
// ======================================================================
int ChooseAction(int state)
{
   if(state < 0 || state >= NUM_STATES)
   {
      Print("âŒ Estado invÃ¡lido: ", state);
      return 0;
   }
   
   if(IsStateBlocked(state))
   {
      Print("â›” Estado ", state, " bloqueado pelo sistema corrigido");
      g_statusMessage = StringFormat("â›” Estado %d bloqueado (sistema corrigido)", state);
      return 0;
   }
   
   if(ArraySize(g_Q) <= state * NUM_ACTIONS + 2)
   {
      Print("âŒ Array Q nÃ£o inicializado");
      return 0;
   }
   
   static int noTradeCounter = 0;
   noTradeCounter++;
   
   if (noTradeCounter > 10)
   {
      noTradeCounter = 0;
      int forcedAction = 1 + (MathRand() % 2);
      Print("ğŸ¯ ANTI-TRAVAMENTO: ForÃ§ando aÃ§Ã£o aleatÃ³ria ", forcedAction, " apÃ³s muitas decisÃµes NOP");
      g_statusMessage = "ğŸ¯ Anti-travamento: aÃ§Ã£o forÃ§ada";
      return forcedAction;
   }
   
   if(g_consecutiveLosses >= 12)
   {
      g_currentExplorationRate = MathMax(InitialExplorationRate * 1.3, 0.2);
      Print("â™»ï¸ Reset de exploraÃ§Ã£o apÃ³s ", g_consecutiveLosses, " perdas consecutivas");
   }
   
   // âš ï¸ CORREÃ‡ÃƒO: REDUZIR EXPLORAÃ‡ÃƒO DRAMATICAMENTE
   if(g_stateVisits[state] < MinStateVisitsToTrade)
   {
      double eps = 0.8; // 80% de exploraÃ§Ã£o para estados novos
      
      if(((double)MathRand() / 32767.0) < eps) 
      {
         int randomAction = 1 + (MathRand() % 2);
         Print("ğŸ” EXPLORAÃ‡ÃƒO (estado novo): AÃ§Ã£o aleatÃ³ria ", randomAction, " | Estado: ", state);
         g_statusMessage = "ğŸ” ExploraÃ§Ã£o (estado novo)";
         noTradeCounter = 0;
         return randomAction;
      }
      else
      {
         Print("ğŸ¤” Estado novo, mas escolhendo NOP (20% chance)");
         return 0;
      }
   }
   
   // Para estados conhecidos, usar taxa de exploraÃ§Ã£o normal
   double eps = g_currentExplorationRate;
   
   // âš ï¸ CAP REMOVIDO - Permitir exploraÃ§Ã£o natural sem limite artificial
   // (Cap de 70% apÃ³s 100 trades removido para permitir descoberta adequada de estados)

   if(((double)MathRand() / 32767.0) < eps) 
   {
      int randomAction = 1 + (MathRand() % 2);
      Print("ğŸ” EXPLORAÃ‡ÃƒO: AÃ§Ã£o aleatÃ³ria ", randomAction, " | Estado: ", state);
      g_statusMessage = "ğŸ” ExploraÃ§Ã£o (aÃ§Ã£o aleatÃ³ria)";
      noTradeCounter = 0;
      return randomAction;
   }

   double best = -DBL_MAX;
   int bestA = 0;

   for(int a = 1; a < NUM_ACTIONS; a++)
   {
      int idx = state * NUM_ACTIONS + a;
      if(idx < ArraySize(g_Q) && g_Q[idx] > best)
      {
         best = g_Q[idx];
         bestA = a;
      }
   }
   
   double nopQ = g_Q[state * NUM_ACTIONS + 0];
   
   // âš ï¸ CORREÃ‡ÃƒO: Tornar NOP mais atrativo para estados ruins - usar MinVisitsForBlockDecision
   double winRate = CalculateWinRate(state);
   if(g_stateVisits[state] >= MinVisitsForBlockDecision && winRate < 0.3)
   {
      bestA = 0;
      Print("ğŸ¤” NOP escolhido (estado ruim, win rate: ", DoubleToString(winRate*100,1), "%)");
      g_statusMessage = "NOP (estado ruim)";
   }
   else if(nopQ > best * 1.5 && bestA > 0)
   {
      bestA = 0;
      Print("ğŸ¤” NOP escolhido (superioridade: ", nopQ, " vs ", best, ")");
      g_statusMessage = "NOP (melhor opÃ§Ã£o)";
   }
   else if(best <= -20.0)
   {
      bestA = 0;
      Print("ğŸ¤” NOP escolhido (aÃ§Ãµes de trade muito ruins: ", best, ")");
      g_statusMessage = "NOP (aÃ§Ãµes ruins)";
   }
   else if(bestA == 1 || bestA == 2)
   {
      if(bestA == 1) g_statusMessage = "BUY recomendado";
      else g_statusMessage = "SELL recomendado";
   }
   else
   {
      g_statusMessage = "NOP (indecisÃ£o)";
   }
   
   Print("ğŸ’¡ DECISÃƒO: Estado ", state, " | AÃ§Ã£o ", 
         (bestA==0?"NOP":(bestA==1?"BUY":"SELL")), 
         " | Q = ", bestA==0 ? nopQ : best,
         " | Visitas: ", g_stateVisits[state],
         " | Win Rate: ", DoubleToString(winRate*100,1), "%");
   
   return bestA;
}

// ======================================================================
// âœ…âœ…âœ… ExecuteAction - COM SISTEMA CORRIGIDO
// ======================================================================
void ExecuteAction(int action, int state)
{
   g_lastTradeExecuted = false;
   g_lastTradeStateExecuted = -1;
   
   bool isBuy = (action == 1);
   
   Print("=== TENTATIVA DE EXECUÃ‡ÃƒO: ", isBuy ? "BUY" : "SELL", " ===");
   Print("Estado: ", state, " | Visitas REAIS: ", g_stateVisits[state], 
         " | Perdas REAIS: ", g_stateLosses[state],
         " | VitÃ³rias REAIS: ", g_stateWins[state]);
   
   if(IsStateBlocked(state))
   {
      Print("â›”â›”â›” BLOQUEIO CONFIRMADO - Estado ", state, " bloqueado pelo sistema corrigido - trade CANCELADO");
      g_statusMessage = StringFormat("â›” Estado %d bloqueado (sistema corrigido)", state);
      UpdateQ_NOP(state);
      return;
   }
   
   if(UseRealVolumeFilter)
   {
      bool volumeOk = CheckRealVolume();
      if(!volumeOk && g_volumeMultiplier < 0.6)
      {
         Print("âš ï¸ Volume moderado, mantendo lote mÃ­nimo");
      }
   }
   
   if(!CanOpenNewPosition(isBuy))
   {
      g_statusMessage = "â›” NÃ£o pode abrir nova posiÃ§Ã£o na direÃ§Ã£o";
      UpdateQ_NOP(state);
      return;
   }
   
   if(!CanTradeBasedOnTime())
   {
      g_statusMessage = "â³ Aguardando tempo entre trades";
      UpdateQ_NOP(state);
      return;
   }
   
   if(!CheckVolatility())
   {
      g_statusMessage = "â›” Volatilidade alta";
      UpdateQ_NOP(state);
      return;
   }
   
   if(!ValidateAllIndicators(isBuy))
   {
      g_statusMessage = "â›” Indicadores nÃ£o confirmam";
      UpdateQ_NOP(state);
      return;
   }
   
   int sameDirCount = CountSameDirectionPositions(isBuy);
   double desiredLot = LotSize;
   
   if(sameDirCount == 0 && EnableSmartLot)
   {
      double quality = GetStateQuality(state);
      
      if(quality >= UltraQualityThreshold)
      {
         desiredLot = LotSize * UltraLotMultiplier;
         Print("ğŸ’ğŸ’ğŸ’ SETUP ULTRA DETECTADO!");
         g_statusMessage = "ğŸ’ ULTRA SETUP - Aposta MÃ¡xima!";
      }
      else if(quality >= HighQualityThreshold)
      {
         desiredLot = LotSize * SmartLotMultiplier;
         Print("ğŸš€ğŸš€ SETUP FORTE DETECTADO!");
         g_statusMessage = "ğŸš€ SETUP FORTE - Aposta Elevada!";
      }
      else if(quality > 0.1)
      {
         Print("ğŸ“Š SETUP NORMAL POSITIVO");
         g_statusMessage = "ğŸ“Š Setup Normal - Qualidade Positiva";
      }
      else if(quality < -0.3)
      {
         Print("âš ï¸âš ï¸ SETUP NEGATIVO DETECTADO - Considerando cancelar trade");
         if(quality < -0.5)
         {
            Print("â›” TRADE CANCELADO - Qualidade muito baixa: ", quality);
            g_statusMessage = "â›” Setup Negativo - Trade Cancelado";
            UpdateQ_NOP(state);
            return;
         }
      }
      else
      {
         Print("ğŸ“ˆ SETUP NEUTRO");
      }
   }
   else if(sameDirCount > 0)
   {
      desiredLot = CalculatePyramidLot(isBuy);
      Print("ğŸ—ï¸ Entrada de piramidaÃ§Ã£o #", sameDirCount + 1, " - Lote: ", desiredLot);
   }
   
   if(desiredLot > MaxAllowedLot) 
   {
      desiredLot = MaxAllowedLot;
      Print("âš ï¸ Lote limitado ao mÃ¡ximo permitido: ", MaxAllowedLot);
   }
   
   double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
   if(desiredLot < minLot) 
   {
      desiredLot = minLot;
      Print("âš ï¸ Lote ajustado ao mÃ­nimo permitido: ", minLot);
   }
   
   Print("ğŸ’° LOTE FINAL DEFINIDO: ", desiredLot);
   
   double price = isBuy ? SymbolInfoDouble(_Symbol, SYMBOL_ASK)
                        : SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);

   double sl_price = 0.0;
   double tp_price = 0.0;
   
   if(UseFixedSL) sl_price = CalculateSLByPoints(isBuy, price);
   if(UseFixedTP) tp_price = CalculateTPByPoints(isBuy, price);

   if(!AreStopsValid(isBuy, price, sl_price, tp_price))
   {
      g_statusMessage = "â›” Stops invÃ¡lidos";
      UpdateQ_NOP(state);
      return;
   }

   MqlTradeRequest req;
   MqlTradeResult  res;
   ZeroMemory(req); ZeroMemory(res);

   req.action    = TRADE_ACTION_DEAL;
   req.symbol    = _Symbol;
   req.volume    = desiredLot;
   req.type      = isBuy ? ORDER_TYPE_BUY : ORDER_TYPE_SELL;
   req.price     = price;
   req.sl        = sl_price;
   req.tp        = tp_price;
   req.magic     = (ulong)MagicNumber;
   req.deviation = 30;
   req.type_filling = ORDER_FILLING_FOK;
   
   int pyramidLevel = sameDirCount + 1;
   string commentType = "NORMAL";
   
   double quality = GetStateQuality(state);
   
   if(sameDirCount == 0 && EnableSmartLot)
   {
      if(quality >= UltraQualityThreshold) commentType = "ULTRA";
      else if(quality >= HighQualityThreshold) commentType = "FORCE";
      else if(quality > 0.1) commentType = "POS";
      else if(quality < -0.2) commentType = "NEG";
      else commentType = "NEUTRO";
   }
   
   string comment = StringFormat("PHX307F_CORRIGIDO_%s_%s_P%d_SL%d_TP%d_VOL%.1fx_Q%.2f_DECAY%d", 
                   isBuy ? "BUY" : "SELL",
                   commentType,
                   pyramidLevel,
                   FixedSL_Points, FixedTP_Points,
                   g_volumeMultiplier,
                   quality,
                   g_totalDecayCycles);
   
   // âœ… CORREÃ‡ÃƒO: Atribuir string diretamente ao campo comment
   req.comment = comment;

   if(!OrderSend(req,res))
   {
      Print("âŒ Falha na ordem: Erro ", GetLastError());
      g_statusMessage = "â›” Falha na ordem";
      UpdateQ_NOP(state);
      return;
   }

   g_lastTradeExecuted = true;
   g_lastTradeStateExecuted = state;
   
   g_lastTradeTime = TimeCurrent();
   
   if(isBuy)
      g_lastBuyTime = TimeCurrent();
   else
      g_lastSellTime = TimeCurrent();
   
   g_lastTradeState  = state;
   g_lastTradeAction = action;
   g_lastLotUsed     = desiredLot;
   g_tradesToday++;
   
   g_currentDirection = isBuy ? 1 : 2;
   g_positionsCount = GetTotalPositions();
   cachedPositions = -1;
   cachedDirection = -1;
   cachedTradesToday = -1;
   
   AddPositionToTrailingSystem((ulong)res.order);
   
   double slPoints = 0, tpPoints = 0;
   if(sl_price > 0) slPoints = MathAbs(price - sl_price) / point;
   if(tp_price > 0) tpPoints = MathAbs(tp_price - price) / point;
   
   string lotTypeMsg = "";
   if(sameDirCount == 0 && EnableSmartLot)
   {
      if(quality >= UltraQualityThreshold) lotTypeMsg = "ğŸ’ ULTRA ";
      else if(quality >= HighQualityThreshold) lotTypeMsg = "ğŸš€ FORCE ";
      else if(quality > 0.1) lotTypeMsg = "ğŸ“ˆ POS ";
      else if(quality < -0.2) lotTypeMsg = "âš ï¸ NEG ";
      else lotTypeMsg = "ğŸ“Š NEUTRO ";
   }
   
   g_statusMessage = StringFormat("âœ… %s%s #%d executado (VOL: %.1fx, Q: %.2f, Decay: %d)", 
                                  lotTypeMsg, 
                                  isBuy ? "BUY" : "SELL", 
                                  pyramidLevel, 
                                  g_volumeMultiplier, 
                                  quality,
                                  g_totalDecayCycles);
   
   Print("ğŸ¯ TRADE EXECUTADO COM SUCESSO - SISTEMA CORRIGIDO COM DECAY: ",
         lotTypeMsg,
         isBuy ? "BUY" : "SELL", " #", pyramidLevel,
         " | Estado: ", state,
         " | Volume: ", g_currentVolume, " (", DoubleToString(g_volumeMultiplier, 1), "x)",
         " | Qualidade: ", DoubleToString(quality, 2),
         " | Lote: ", desiredLot, " (", DoubleToString(desiredLot/LotSize, 1), "x)",
         " | SL: ", DoubleToString(slPoints, 0), " pts",
         " | TP: ", DoubleToString(tpPoints, 0), " pts",
         " | PreÃ§o: ", DoubleToString(price, 5),
         " | Ciclos Decay: ", g_totalDecayCycles);
   
   Print("ğŸ“Š AGUARDANDO FECHAMENTO: Trade executado, visitas/perdas serÃ£o atualizadas apenas apÃ³s fechamento...");
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO ComputeRewardFromTrade (ATUALIZADA)
// ======================================================================
double ComputeRewardFromTrade(double profit)
{
   if(UseSimpleRewardSystem)
   {
      if(profit > 0) return RewardWin;
      else return RewardLoss;
   }
   
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double profit_points = profit / (LotSize * point * 100);
   
   if(profit > 0)
   {
      return 1.0 + profit_points / 100.0;
   }
   else
   {
      return -1.0 - MathAbs(profit_points) / 200.0;
   }
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO GetStateQuality - VERSÃƒO MELHORADA
// ======================================================================
double GetStateQuality(int state)
{
   if(state < 0 || state >= NUM_STATES) return 0.0;
   if(ArraySize(g_stateVisits) <= state) return 0.0;
   if(ArraySize(g_Q) <= state * NUM_ACTIONS + 2) return 0.0;
   
   if(g_stateVisits[state] < 2) return 0.0;
   
   double buyQ  = g_Q[state * NUM_ACTIONS + 1];
   double sellQ = g_Q[state * NUM_ACTIONS + 2];
   double nopQ  = g_Q[state * NUM_ACTIONS + 0];
   
   double bestTradeQ = MathMax(buyQ, sellQ);
   
   if(nopQ > bestTradeQ * 3.0)
   {
      double penalizedQuality = (bestTradeQ - nopQ) / 5.0;
      return MathMax(penalizedQuality, -2.0);
   }
   
   double quality = bestTradeQ / 10.0;
   
   if(g_stateVisits[state] >= MinVisitsForBlockDecision)
   {
      double winRate = CalculateWinRate(state);
      double lossRate = 1.0 - winRate;
      
      if(lossRate > 0.6)
      {
         quality -= (lossRate - 0.6) * 3.0;
      }
      
      if(winRate > 0.7 && g_stateVisits[state] >= MinVisitsForBlockDecision)
      {
         quality += (winRate - 0.7) * 2.0;
      }
   }
   
   if(quality > 2.0) quality = 2.0;
   if(quality < -2.0) quality = -2.0;
   
   return quality;
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡Ã•ES PARA CALCULAR ESTADO
// ======================================================================

// âœ… FunÃ§Ã£o para calcular bucket RSI
int GetRSIBucket(double rsiValue)
{
   if(rsiValue < 25) return 0;          // Muito sobrevendido
   else if(rsiValue < 40) return 1;     // Sobrevedido
   else if(rsiValue < 50) return 2;     // TendÃªncia de baixa
   else return 3;                       // TendÃªncia de alta
}

// âœ… FunÃ§Ã£o para calcular bucket MA Distance
int GetMADistanceBucket(double maDistance)
{
   if(maDistance < -1.5) return 0;       // Muito abaixo da MA
   else if(maDistance < 0) return 1;     // Abaixo da MA
   else return 2;                        // Acima da MA
}

// âœ… FunÃ§Ã£o para calcular bucket ADX
int GetADXBucket(double adxValue)
{
   if(adxValue < 20) return 0;           // TendÃªncia fraca
   else return 1;                        // TendÃªncia forte
}

// âœ… FunÃ§Ã£o para calcular bucket Bollinger Bands
int GetBBBucket(double bbPosition)
{
   if(bbPosition < 0.3) return 0;        // PrÃ³ximo da banda inferior
   else if(bbPosition < 0.7) return 1;   // No meio
   else return 2;                        // PrÃ³ximo da banda superior
}

// âœ… FunÃ§Ã£o para calcular bucket volatilidade
int GetVolatilityBucket(double atrCurrent, double atrPrevious)
{
   double ratio = (atrPrevious > 0) ? atrCurrent / atrPrevious : 1.0;
   
   if(ratio < 0.8) return 0;             // Volatilidade diminuindo
   else return 1;                        // Volatilidade estÃ¡vel/aumentando
}

// âœ… FunÃ§Ã£o para calcular bucket volume
int GetVolumeBucket()
{
   if(!UseRealVolumeFilter) return 1;    // Volume normal (default)
   
   if(g_volumeMultiplier < 0.7) return 0;  // Volume baixo
   else return 1;                         // Volume normal/alto
}

// âœ… FunÃ§Ã£o para calcular bucket de tempo
int GetTimeBucket()
{
   MqlDateTime timeStruct;
   TimeCurrent(timeStruct);
   
   int hour = timeStruct.hour;
   
   if(hour >= 0 && hour < 12) return 0;      // ManhÃ£/Madrugada
   else return 1;                            // Tarde/Noite
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO GetCurrentState (OTIMIZADA E CORRIGIDA)
// ======================================================================
int GetCurrentState()
{
   double ma[], rsi[], adx[], bb_upper[], bb_lower[], atr[];
   ArraySetAsSeries(ma, true);
   ArraySetAsSeries(rsi, true);
   ArraySetAsSeries(adx, true);
   ArraySetAsSeries(bb_upper, true);
   ArraySetAsSeries(bb_lower, true);
   ArraySetAsSeries(atr, true);
   
   if(CopyBuffer(g_maHandle, 0, 0, 1, ma) < 1) 
   {
      Print("âŒ Erro ao copiar MA");
      return -1;
   }
   if(CopyBuffer(g_rsiHandle, 0, 0, 1, rsi) < 1) 
   {
      Print("âŒ Erro ao copiar RSI");
      return -1;
   }
   if(CopyBuffer(g_adxHandle, 0, 0, 1, adx) < 1) 
   {
      Print("âŒ Erro ao copiar ADX");
      return -1;
   }
   if(CopyBuffer(g_bbHandle, 0, 0, 1, bb_upper) < 1) 
   {
      Print("âŒ Erro ao copiar BB Upper");
      return -1;
   }
   if(CopyBuffer(g_bbHandle, 2, 0, 1, bb_lower) < 1) 
   {
      Print("âŒ Erro ao copiar BB Lower");
      return -1;
   }
   if(CopyBuffer(g_atrHandle, 0, 0, 2, atr) < 2) 
   {
      Print("âŒ Erro ao copiar ATR");
      return -1;
   }
   
   double price = SymbolInfoDouble(_Symbol, SYMBOL_LAST);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   // âœ… CÃ¡lculo da distÃ¢ncia da MA
   double maDistance = 0;
   double atrValue = atr[0];
   if(atrValue > 0)
      maDistance = SafeDivide(price - ma[0], atrValue, 0.0);
   else
      maDistance = SafeDivide(price - ma[0], point * 10, 0.0);
   
   // âœ… CÃ¡lculo da posiÃ§Ã£o nas Bollinger Bands
   double bbPosition = 0;
   double bbRange = bb_upper[0] - bb_lower[0];
   if(bbRange > 0)
      bbPosition = SafeDivide(price - bb_lower[0], bbRange, BB_NEUTRAL_POSITION);
   else
      bbPosition = BB_NEUTRAL_POSITION;  // Usar posiÃ§Ã£o neutra se range invÃ¡lido
   
   // âœ… Calcular buckets otimizados
   int maBucket = GetMADistanceBucket(maDistance);
   int rsiBucket = GetRSIBucket(rsi[0]);
   int adxBucket = GetADXBucket(adx[0]);
   int bbBucket = GetBBBucket(bbPosition);
   int volBucket = GetVolatilityBucket(atr[0], atr[1]);
   int volumeBucket = GetVolumeBucket();
   int timeBucket = GetTimeBucket();
   
   // âœ… ProteÃ§Ã£o contra overflow
   maBucket = (int)MathMod(maBucket, BINS_MA_DIST);
   rsiBucket = (int)MathMod(rsiBucket, BINS_RSI);
   adxBucket = (int)MathMod(adxBucket, BINS_ADX);
   bbBucket = (int)MathMod(bbBucket, BINS_BBPOS);
   volBucket = (int)MathMod(volBucket, BINS_VOLATILITY);
   volumeBucket = (int)MathMod(volumeBucket, BINS_VOLUME);
   timeBucket = (int)MathMod(timeBucket, BINS_TIME);
   
   // âœ… CORREÃ‡ÃƒO: MÃ©todo correto - multiplicar na ordem inversa
   int state_idx = 0;
   
   // MÃ©todo correto - multiplicar na ordem inversa
   state_idx = (((((timeBucket * BINS_VOLUME + volumeBucket) * BINS_VOLATILITY + volBucket) * 
                  BINS_BBPOS + bbBucket) * BINS_ADX + adxBucket) * 
                  BINS_RSI + rsiBucket) * BINS_MA_DIST + maBucket;
   
   // âœ… VERIFICAÃ‡ÃƒO DE SEGURANÃ‡A
   if(state_idx < 0) state_idx = 0;
   if(state_idx >= NUM_STATES) 
   {
      Print("âŒ ERRO CRÃTICO: Estado calculado ", state_idx, " excede NUM_STATES ", NUM_STATES);
      state_idx = state_idx % NUM_STATES; // ForÃ§ar dentro dos limites
   }
   
   // âœ… DEBUG para verificar cÃ¡lculo
   static int debugCounter = 0;
   if(debugCounter++ % 100 == 0)
   {
      Print("DEBUG Estado: idx=", state_idx, 
            " | ma=", maBucket, " rsi=", rsiBucket, " adx=", adxBucket,
            " bb=", bbBucket, " vol=", volBucket, " volM=", volumeBucket, " time=", timeBucket);
   }
   
   // âœ… PROTEÃ‡ÃƒO CONTRA ESTADO CONGELADO
   static int lastState = -1;
   static int sameStateCount = 0;
   static datetime lastStateChange = 0;
   
   if(state_idx == lastState)
   {
      sameStateCount++;
      datetime now = TimeCurrent();
      
      // Se ficou no mesmo estado por muito tempo, forÃ§ar variaÃ§Ã£o
      if(sameStateCount > 20 && (now - lastStateChange) > 3600)
      {
         Print("âš ï¸ Estado congelado detectado! ForÃ§ando variaÃ§Ã£o...");
         state_idx = (state_idx + 1 + MathRand() % 5) % NUM_STATES;
         sameStateCount = 0;
         lastStateChange = now;
      }
   }
   else
   {
      sameStateCount = 0;
      lastState = state_idx;
      lastStateChange = TimeCurrent();
   }
   
   // âœ… Log de diagnÃ³stico (apenas ocasionalmente)
   static int lastLoggedState = -1;
   static datetime lastLogTime = 0;
   datetime currentTime = TimeCurrent();
   
   if((state_idx != lastLoggedState && (currentTime - lastLogTime) > 300) || 
      g_totalTrades % 50 == 0)
   {
      PrintFormat("ğŸ“Š Estado calculado: %d | RSI=%.1f(%d) | MA_dist=%.2f(%d) | ADX=%.1f(%d) | BB=%.2f(%d) | Vol=%d | Time=%d",
                  state_idx, rsi[0], rsiBucket, maDistance, maBucket, adx[0], adxBucket, 
                  bbPosition, bbBucket, volBucket, timeBucket);
      lastLoggedState = state_idx;
      lastLogTime = currentTime;
   }
   
   return state_idx;
}

// ======================================================================
// âœ… FUNÃ‡Ã•ES DE CONTROLE DE DIREÃ‡ÃƒO
// ======================================================================
int GetCurrentPositionsDirection()
{
   int buyCount = 0;
   int sellCount = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      long type = PositionGetInteger(POSITION_TYPE);
      if(type == POSITION_TYPE_BUY) buyCount++;
      else if(type == POSITION_TYPE_SELL) sellCount++;
   }
   
   if(buyCount > 0 && sellCount == 0) return 1;
   if(sellCount > 0 && buyCount == 0) return 2;
   if(buyCount > 0 && sellCount > 0) return 3;
   return 0;
}

int GetTotalPositions()
{
   int count = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      count++;
   }
   
   return count;
}

bool CanOpenNewPosition(bool isBuy)
{
   if(AllowOnlyOneDirection)
   {
      int currentDir = GetCurrentPositionsDirection();
      
      if(currentDir == 3)
      {
         Print("âŒ ERRO: Encontradas posiÃ§Ãµes em ambas as direÃ§Ãµes!");
         return false;
      }
      
      if((currentDir == 1 && !isBuy) || (currentDir == 2 && isBuy))
      {
         if(CloseOppositeOnNewSignal)
         {
            Print("âš ï¸ Fechando posiÃ§Ãµes na direÃ§Ã£o oposta para nova entrada...");
            CloseAllPositions();
            return true;
         }
         else if(WaitForAllCloseBeforeNew)
         {
            Print("â³ Aguardando posiÃ§Ãµes opostas fecharem...");
            return false;
         }
         else
         {
            Print("âŒ JÃ¡ existe posiÃ§Ã£o na direÃ§Ã£o oposta");
            return false;
         }
      }
      
      if((currentDir == 1 && isBuy) || (currentDir == 2 && !isBuy))
      {
         if(!EnablePyramiding)
         {
            Print("âŒ PiramidaÃ§Ã£o desativada. JÃ¡ existe posiÃ§Ã£o na mesma direÃ§Ã£o.");
            return false;
         }
         return CanPyramid(isBuy);
      }
   }
   else
   {
      if(GetTotalPositions() > 0)
      {
         return CanPyramid(isBuy);
      }
   }
   
   int sameDirCount = CountSameDirectionPositions(isBuy);
   if(sameDirCount >= MaxTradesPerDirection)
   {
      Print("âŒ Limite mÃ¡ximo de posiÃ§Ãµes por direÃ§Ã£o atingido: ", sameDirCount, "/", MaxTradesPerDirection);
      return false;
   }
   
   if(sameDirCount > 0)
   {
      datetime lastTradeTime = isBuy ? g_lastBuyTime : g_lastSellTime;
      if(lastTradeTime > 0)
      {
         datetime currentTime = TimeCurrent();
         int secondsSinceLast = (int)(currentTime - lastTradeTime);
         int requiredSeconds = MinMinutesBetweenTrades * 60;
         
         if(secondsSinceLast < requiredSeconds)
         {
            Print("â³ Aguardando tempo entre entradas na mesma direÃ§Ã£o: ", 
                  secondsSinceLast, "s/", requiredSeconds, "s");
            return false;
         }
      }
   }
   
   if(sameDirCount > 0 && MinBarsBetweenSameDirection > 0)
   {
      int barsSinceLast = BarsSinceLastEntry(isBuy);
      if(barsSinceLast >= 0 && barsSinceLast < MinBarsBetweenSameDirection)
      {
         Print("â³ Aguardando mais barras para nova entrada na mesma direÃ§Ã£o: ",
               barsSinceLast, "/", MinBarsBetweenSameDirection, " barras");
         return false;
      }
   }
   
   Print("âœ… Pode abrir nova posiÃ§Ã£o na direÃ§Ã£o: ", isBuy ? "BUY" : "SELL");
   return true;
}

int BarsSinceLastEntry(bool isBuy)
{
   datetime lastEntryTime = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      long type = PositionGetInteger(POSITION_TYPE);
      if((isBuy && type == POSITION_TYPE_BUY) || (!isBuy && type == POSITION_TYPE_SELL))
      {
         datetime entryTime = (datetime)PositionGetInteger(POSITION_TIME);
         if(entryTime > lastEntryTime) lastEntryTime = entryTime;
      }
   }
   
   if(lastEntryTime == 0) return -1;
   
   return Bars(_Symbol, _Period, lastEntryTime, TimeCurrent());
}

bool CloseAllPositions()
{
   bool allClosed = true;
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      double currentPrice = PositionGetInteger(POSITION_TYPE) == POSITION_TYPE_BUY ? 
                           SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
                           SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      if(!trade.PositionClose(ticket, (ulong)30))
      {
         Print("âŒ Falha ao fechar posiÃ§Ã£o #", ticket);
         allClosed = false;
      }
      else
      {
         Print("âœ… PosiÃ§Ã£o #", ticket, " fechada");
      }
   }
   cachedPositions = -1;
   cachedDirection = -1;
   return allClosed;
}

// ======================================================================
// âœ… FUNÃ‡Ã•ES PARA STOPS
// ======================================================================
double CalculateSLByPoints(bool isBuy, double entryPrice)
{
   if(!UseFixedSL) return 0.0;
   
   int slPoints = FixedSL_Points;
   if(slPoints <= 0) return 0.0;
   
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double slDistance = slPoints * point;
   
   if(isBuy)
   {
      double slPrice = entryPrice - slDistance;
      Print("âœ… SL BUY calculado: Entry=", DoubleToString(entryPrice, 5), " - SL=", DoubleToString(slPrice, 5), 
            " (", slPoints, " pontos = ", DoubleToString(slDistance, 5), ")");
      return slPrice;
   }
   else
   {
      double slPrice = entryPrice + slDistance;
      Print("âœ… SL SELL calculado: Entry=", DoubleToString(entryPrice, 5), " + SL=", DoubleToString(slPrice, 5), 
            " (", slPoints, " pontos = ", DoubleToString(slDistance, 5), ")");
      return slPrice;
   }
}

double CalculateTPByPoints(bool isBuy, double entryPrice)
{
   if(!UseFixedTP) return 0.0;
   
   int tpPoints = FixedTP_Points;
   if(tpPoints <= 0) return 0.0;
   
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   double tpDistance = tpPoints * point;
   
   if(isBuy)
   {
      double tpPrice = entryPrice + tpDistance;
      Print("âœ… TP BUY calculado: Entry=", DoubleToString(entryPrice, 5), " + TP=", DoubleToString(tpPrice, 5), 
            " (", tpPoints, " pontos = ", DoubleToString(tpDistance, 5), ")");
      return tpPrice;
   }
   else
   {
      double tpPrice = entryPrice - tpDistance;
      Print("âœ… TP SELL calculado: Entry=", DoubleToString(entryPrice, 5), " - TP=", DoubleToString(tpPrice, 5), 
            " (", tpPoints, " pontos = ", DoubleToString(tpDistance, 5), ")");
      return tpPrice;
   }
}

bool AreStopsValid(bool isBuy, double entryPrice, double slPrice, double tpPrice)
{
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   Print("=== VERIFICAÃ‡ÃƒO DE STOPS ===");
   Print("DireÃ§Ã£o: ", isBuy ? "BUY" : "SELL");
   Print("Entry: ", DoubleToString(entryPrice, 5));
   Print("SL: ", DoubleToString(slPrice, 5));
   Print("TP: ", DoubleToString(tpPrice, 5));
   
   if(UseFixedSL && slPrice > 0)
   {
      double slDistance = MathAbs(entryPrice - slPrice);
      double slPoints = SafeDivide(slDistance, point, 0.0);
      
      long minStopsLevel = (long)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
      double minSL = minStopsLevel * point;
      double minSLPoints = SafeDivide(minSL, point, 0.0);
      
      Print("SL Distance: ", DoubleToString(slDistance, 5), " (", DoubleToString(slPoints, 0), " pontos)");
      Print("Min SL required: ", DoubleToString(minSL, 5), " (", DoubleToString(minSLPoints, 0), " pontos)");
      
      if(slDistance < minSL && minSL > 0)
      {
         Print("âŒ ERRO: SL muito pequeno!");
         return false;
      }
      
      if(isBuy)
      {
         if(slPrice >= entryPrice)
         {
            Print("âŒ ERRO: SL invÃ¡lido para BUY! SL (", DoubleToString(slPrice, 5), ") >= Entry (", DoubleToString(entryPrice, 5), ")");
            return false;
         }
      }
      else
      {
         if(slPrice <= entryPrice)
         {
            Print("âŒ ERRO: SL invÃ¡lido para SELL! SL (", DoubleToString(slPrice, 5), ") <= Entry (", DoubleToString(entryPrice, 5), ")");
            return false;
         }
      }
      
      Print("âœ… SL vÃ¡lido: ", DoubleToString(slPoints, 0), " pontos");
   }
   
   if(UseFixedTP && tpPrice > 0)
   {
      double tpDistance = MathAbs(entryPrice - tpPrice);
      double tpPoints = SafeDivide(tpDistance, point, 0.0);
      
      long minStopsLevel = (long)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);
      double minTP = minStopsLevel * point;
      double minTPPoints = SafeDivide(minTP, point, 0.0);
      
      Print("TP Distance: ", DoubleToString(tpDistance, 5), " (", DoubleToString(tpPoints, 0), " pontos)");
      Print("Min TP required: ", DoubleToString(minTP, 5), " (", DoubleToString(minTPPoints, 0), " pontos)");
      
      if(tpDistance < minTP && minTP > 0)
      {
         Print("âŒ ERRO: TP muito pequeno!");
         return false;
      }
      
      if(isBuy)
      {
         if(tpPrice <= entryPrice)
         {
            Print("âŒ ERRO: TP invÃ¡lido para BUY! TP (", DoubleToString(tpPrice, 5), ") <= Entry (", DoubleToString(entryPrice, 5), ")");
            return false;
         }
      }
      else
      {
         if(tpPrice >= entryPrice)
         {
            Print("âŒ ERRO: TP invÃ¡lido para SELL! TP (", DoubleToString(tpPrice, 5), ") >= Entry (", DoubleToString(entryPrice, 5), ")");
            return false;
         }
      }
      
      Print("âœ… TP vÃ¡lido: ", DoubleToString(tpPoints, 0), " pontos");
   }
   
   Print("=== STOPS VALIDADOS COM SUCESSO ===");
   return true;
}

// ======================================================================
// âœ… FUNÃ‡Ã•ES DE VALIDAÃ‡ÃƒO COM INDICADORES
// ======================================================================
bool ValidateWithRSI(bool isBuy)
{
   if(!UseRSIValidation) return true;
   
   double rsi[];
   ArraySetAsSeries(rsi, true);
   if(CopyBuffer(g_rsiHandle, 0, 0, 2, rsi) < 2) return false;
   
   double currentRSI = rsi[0];
   double previousRSI = rsi[1];
   
   if(isBuy)
   {
      if(currentRSI < RSI_Oversold) 
      {
         Print("âœ… RSI EXCELENTE para BUY: ", DoubleToString(currentRSI, 2), " (oversold)");
         return true;
      }
      
      if(currentRSI < 40 && currentRSI > previousRSI)
      {
         Print("âœ… RSI BOM para BUY: ", DoubleToString(currentRSI, 2), " (subindo de regiÃ£o baixa)");
         return true;
      }
      
      if(currentRSI < 50)
      {
         Print("âœ… RSI ACEITÃVEL para BUY: ", DoubleToString(currentRSI, 2), " (abaixo de 50)");
         return true;
      }
      
      if(currentRSI > 85)
      {
         Print("âŒ RSI invÃ¡lido para BUY: ", DoubleToString(currentRSI, 2), " (sobrecomprado extremo)");
         return false;
      }
      
      Print("âš ï¸ RSI neutro para BUY: ", DoubleToString(currentRSI, 2));
      return true;
   }
   else
   {
      if(currentRSI > RSI_Overbought)
      {
         Print("âœ… RSI EXCELENTE para SELL: ", DoubleToString(currentRSI, 2), " (sobrecomprado)");
         return true;
      }
      
      if(currentRSI > 60 && currentRSI < previousRSI)
      {
         Print("âœ… RSI BOM para SELL: ", DoubleToString(currentRSI, 2), " (caindo de regiÃ£o alta)");
         return true;
      }
      
      if(currentRSI > 50)
      {
         Print("âœ… RSI ACEITÃVEL para SELL: ", DoubleToString(currentRSI, 2), " (acima de 50)");
         return true;
      }
      
      if(currentRSI < 15)
      {
         Print("âŒ RSI invÃ¡lido para SELL: ", DoubleToString(currentRSI, 2), " (sobrevendido extremo)");
         return false;
      }
      
      Print("âš ï¸ RSI neutro para SELL: ", DoubleToString(currentRSI, 2));
      return true;
   }
}

bool ValidateWithBollingerBands(bool isBuy)
{
   if(!UseBBValidation) return true;
   
   double bb_upper[], bb_lower[];
   ArraySetAsSeries(bb_upper, true);
   ArraySetAsSeries(bb_lower, true);
   if(CopyBuffer(g_bbHandle, 0, 0, 1, bb_upper) < 1) return false;
   if(CopyBuffer(g_bbHandle, 2, 0, 1, bb_lower) < 1) return false;
   
   double price = SymbolInfoDouble(_Symbol, SYMBOL_LAST);
   double bb_range = bb_upper[0] - bb_lower[0];
   
   if(bb_range <= 0) return false;
   
   double bb_position = SafeDivide(price - bb_lower[0], bb_range, BB_NEUTRAL_POSITION);
   
   if(isBuy)
   {
      if(bb_position <= 0.7)
      {
         if(bb_position <= BB_LowerThreshold)
         {
            Print("âœ… BB EXCELENTE para BUY: posiÃ§Ã£o ", DoubleToString(bb_position*100, 1), "% (prÃ³ximo da banda inferior)");
         }
         else if(bb_position <= 0.5)
         {
            Print("âœ… BB BOM para BUY: posiÃ§Ã£o ", DoubleToString(bb_position*100, 1), "% (faixa inferior)");
         }
         else
         {
            Print("âœ… BB ACEITÃVEL para BUY: posiÃ§Ã£o ", DoubleToString(bb_position*100, 1), "% (metade inferior)");
         }
         return true;
      }
      else if(bb_position <= 0.9)
      {
         Print("âš ï¸ BB NEUTRO para BUY: posiÃ§Ã£o ", DoubleToString(bb_position*100, 1), "% (cuidado)");
         return true;
      }
      else
      {
         Print("âŒ BB muito alto para BUY: posiÃ§Ã£o ", DoubleToString(bb_position*100, 1), "% (acima de 90%)");
         return false;
      }
   }
   else
   {
      if(bb_position >= 0.3)
      {
         if(bb_position >= BB_UpperThreshold)
         {
            Print("âœ… BB EXCELENTE para SELL: posiÃ§Ã£o ", DoubleToString(bb_position*100, 1), "% (prÃ³ximo da banda superior)");
         }
         else if(bb_position >= 0.5)
         {
            Print("âœ… BB BOM para SELL: posiÃ§Ã£o ", DoubleToString(bb_position*100, 1), "% (faixa superior)");
         }
         else
         {
            Print("âœ… BB ACEITÃVEL para SELL: posiÃ§Ã£o ", DoubleToString(bb_position*100, 1), "% (metade superior)");
         }
         return true;
      }
      else if(bb_position >= 0.1)
      {
         Print("âš ï¸ BB NEUTRO para SELL: posiÃ§Ã£o ", DoubleToString(bb_position*100, 1), "% (cuidado)");
         return true;
      }
      else
      {
         Print("âŒ BB muito baixo para SELL: posiÃ§Ã£o ", DoubleToString(bb_position*100, 1), "% (abaixo de 10%)");
         return false;
      }
   }
}

bool ValidateWithADX()
{
   if(!UseADXValidation) return true;
   
   double adx[];
   ArraySetAsSeries(adx, true);
   if(CopyBuffer(g_adxHandle, 0, 0, 1, adx) < 1) return false;
   
   if(adx[0] >= MinADXStrength)
   {
      Print("âœ… ADX vÃ¡lido: ", DoubleToString(adx[0], 1), " (forÃ§a suficiente)");
      return true;
   }
   else if(adx[0] >= 15)
   {
      Print("âš ï¸ ADX moderado aceito: ", DoubleToString(adx[0], 1), " (abaixo do ideal, mas aceitÃ¡vel)");
      return true;
   }
   else
   {
      Print("âŒ ADX muito fraco: ", DoubleToString(adx[0], 1), " (mÃ­nimo aceitÃ¡vel: 15)");
      return false;
   }
}

bool ValidateWithTrend(bool isBuy)
{
   if(!UseTrendValidation) return true;
   
   double ma[], atr[];
   ArraySetAsSeries(ma, true);
   ArraySetAsSeries(atr, true);
   if(CopyBuffer(g_maHandle, 0, 0, 1, ma) < 1) return false;
   if(CopyBuffer(g_atrHandle, 0, 0, 1, atr) < 1) return false;
   
   double price = SymbolInfoDouble(_Symbol, SYMBOL_LAST);
   double point = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   
   double atr_value = atr[0];
   if(atr_value < point * 10)
   {
      atr_value = price * 0.005;
   }
   
   double distance_from_ma = SafeDivide(price - ma[0], atr_value, 0.0);
   
   if(isBuy)
   {
      if(distance_from_ma > -1.5 || distance_from_ma < -4.0) 
      {
         return true; 
      }
      else
      {
         Print("âŒ TendÃªncia invÃ¡lida para BUY: preÃ§o em zona morta (distÃ¢ncia: ", DoubleToString(distance_from_ma, 2), " ATRs)");
         return false;
      }
   }
   else
   {
      if(distance_from_ma < 1.5 || distance_from_ma > 4.0) 
      {
         return true;
      }
      else
      {
         Print("âŒ TendÃªncia invÃ¡lida para SELL: preÃ§o em zona morta (distÃ¢ncia: ", DoubleToString(distance_from_ma, 2), " ATRs)");
         return false;
      }
   }
}

bool CanTradeBasedOnTime()
{
   if(g_lastTradeTime == 0) return true;
   
   datetime currentTime = TimeCurrent();
   int secondsSinceLastTrade = (int)(currentTime - g_lastTradeTime);
   int requiredSeconds = MinMinutesBetweenTrades * 60;
   
   if(secondsSinceLastTrade < requiredSeconds)
   {
      Print("â³ Aguardando tempo. Segundos desde Ãºltimo trade: ", secondsSinceLastTrade,
            " | NecessÃ¡rios: ", requiredSeconds);
      return false;
   }
   
   return true;
}

bool CheckVolatility()
{
   if(!UseVolatilityFilter) return true;
   
   double atr[];
   ArraySetAsSeries(atr, true);
   if(CopyBuffer(g_atrHandle, 0, 0, 2, atr) < 2) return true;
   
   double currentATR = atr[0];
   double previousATR = atr[1];
   
   if(currentATR > (previousATR * MaxATRMultiplier))
   {
      Print("â›” Volatilidade alta. ATR atual: ", DoubleToString(currentATR, 5),
            " | Anterior: ", DoubleToString(previousATR, 5));
      return false;
   }
   
   return true;
}

bool ValidateAllIndicators(bool isBuy)
{
   Print("=== VALIDAÃ‡ÃƒO DE INDICADORES PARA ", isBuy ? "BUY" : "SELL", " ===");
   
   if(!ValidateWithRSI(isBuy))
   {
      Print("âŒ VALIDAÃ‡ÃƒO FALHOU: RSI");
      return false;
   }
   
   if(!ValidateWithBollingerBands(isBuy))
   {
      Print("âŒ VALIDAÃ‡ÃƒO FALHOU: Bollinger Bands");
      return false;
   }
   
   if(!ValidateWithADX())
   {
      Print("âŒ VALIDAÃ‡ÃƒO FALHOU: ADX");
      return false;
   }
   
   if(!ValidateWithTrend(isBuy))
   {
      Print("âŒ VALIDAÃ‡ÃƒO FALHOU: TendÃªncia MA");
      return false;
   }
   
   Print("âœ… TODOS OS INDICADORES VALIDADOS COM SUCESSO!");
   return true;
}

// ======================================================================
// âœ… FUNÃ‡Ã•ES DE PIRAMIDAÃ‡ÃƒO
// ======================================================================
int CountSameDirectionPositions(bool isBuy)
{
   int count = 0;
   
   for(int i = 0; i < PositionsTotal(); i++)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket == 0) continue;
      if(!PositionSelectByTicket(ticket)) continue;
      if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
      if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
      
      long type = PositionGetInteger(POSITION_TYPE);
      if(isBuy && type == POSITION_TYPE_BUY) count++;
      if(!isBuy && type == POSITION_TYPE_SELL) count++;
   }
   
   return count;
}

bool CanPyramid(bool isBuy)
{
   if(!EnablePyramiding) 
   {
      Print("âŒ PiramidaÃ§Ã£o desativada nas configuraÃ§Ãµes");
      return false;
   }
   
   int sameDirCount = CountSameDirectionPositions(isBuy);
   
   Print("ğŸ“Š PiramidaÃ§Ã£o: Contagem na direÃ§Ã£o ", isBuy ? "BUY" : "SELL", ": ", sameDirCount);
   
   if(sameDirCount >= MaxPyramidPositions)
   {
      Print("âŒ PIRAMIDAÃ‡ÃƒO: Limite de ", MaxPyramidPositions, " posiÃ§Ãµes por direÃ§Ã£o atingido");
      return false;
   }
   
   if(sameDirCount > 0)
   {
      double atr[];
      ArraySetAsSeries(atr, true);
      if(CopyBuffer(g_atrHandle, 0, 0, 1, atr) < 1) 
      {
         Print("âŒ PIRAMIDAÃ‡ÃƒO: NÃ£o foi possÃ­vel obter o valor do ATR");
         return false;
      }
      
      double currentPrice = isBuy ? 
         SymbolInfoDouble(_Symbol, SYMBOL_BID) : 
         SymbolInfoDouble(_Symbol, SYMBOL_ASK);
      
      double minDistance = PyramidingDistanceATR * atr[0];
      
      Print("ğŸ“ PiramidaÃ§Ã£o: DistÃ¢ncia mÃ­nima necessÃ¡ria: ", DoubleToString(minDistance, 5), " (", PyramidingDistanceATR, " ATRs)");
      
      for(int i = 0; i < PositionsTotal(); i++)
      {
         ulong ticket = PositionGetTicket(i);
         if(!PositionSelectByTicket(ticket)) continue;
         
         if(PositionGetString(POSITION_SYMBOL) != _Symbol) continue;
         if(PositionGetInteger(POSITION_MAGIC) != MagicNumber) continue;
         
         long type = PositionGetInteger(POSITION_TYPE);
         if((isBuy && type == POSITION_TYPE_BUY) || (!isBuy && type == POSITION_TYPE_SELL))
         {
            double entryPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double distance = MathAbs(currentPrice - entryPrice);
            
            Print("ğŸ“ PiramidaÃ§Ã£o: Ticket #", ticket, " | Entry: ", DoubleToString(entryPrice, 5), 
                  " | Current: ", DoubleToString(currentPrice, 5), " | Distance: ", DoubleToString(distance, 5));
            
            if(distance < minDistance)
            {
               Print("âŒ PIRAMIDAÃ‡ÃƒO: PosiÃ§Ã£o muito prÃ³xima (", DoubleToString(distance, 5), " < ", DoubleToString(minDistance, 5), ")");
               return false;
            }
         }
      }
      
      Print("âœ… PIRAMIDAÃ‡ÃƒO: CondiÃ§Ãµes atendidas para entrada #", sameDirCount + 1,
            " | PreÃ§o atual: ", DoubleToString(currentPrice, 5));
   }
   else
   {
      Print("âœ… PIRAMIDAÃ‡ÃƒO: Primeira entrada na direÃ§Ã£o ", isBuy ? "BUY" : "SELL");
   }
   
   return true;
}

double CalculatePyramidLot(bool isBuy)
{
   double baseLot = LotSize;
   int sameDirCount = CountSameDirectionPositions(isBuy);
   
   if(sameDirCount == 0) 
   {
      Print("ğŸ’° PiramidaÃ§Ã£o: Primeira entrada - Lote base: ", DoubleToString(baseLot, 2));
      return baseLot;
   }
   
   if(ReduceLotOnPyramiding)
   {
      double multiplier = MathPow(PyramidingLotMultiplier, sameDirCount);
      double pyramidLot = baseLot * multiplier;
      
      double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
      if(pyramidLot < minLot) pyramidLot = minLot;
      
      Print("ğŸ’° PIRAMIDAÃ‡ÃƒO: Lote calculado: ", DoubleToString(baseLot, 2), " * ", DoubleToString(multiplier, 2), " = ", DoubleToString(pyramidLot, 2),
            " (entrada #", sameDirCount + 1, ")");
      
      return pyramidLot;
   }
   else
   {
      Print("ğŸ’° PIRAMIDAÃ‡ÃƒO: Lote fixo: ", DoubleToString(baseLot, 2),
            " (entrada #", sameDirCount + 1, ")");
      
      return baseLot;
   }
}

// ======================================================================
// âœ…âœ…âœ… NOVO SISTEMA DE APRENDIZADO INTELIGENTE
// ======================================================================

void InitializeLearningSystem()
{
   ArrayResize(g_stateWinRate, NUM_STATES);
   ArrayInitialize(g_stateWinRate, 0.0);
   
   ArrayResize(g_stateAvgProfit, NUM_STATES);
   ArrayInitialize(g_stateAvgProfit, 0.0);
   
   g_stateResets = 0;
   g_stateDecays = 0;
   g_lastDecayTradeCount = 0;
   g_totalDecayCycles = 0;
   g_totalBadStateResets = 0;
   
   Print("ğŸ§  Sistema de aprendizado inteligente inicializado (memÃ³ria otimizada com decay)");
}

double CalculateStateAverageProfit(int state)
{
   if(state < 0 || state >= NUM_STATES) return 0.0;
   if(g_stateVisits[state] < 5) return 0.0;
   
   double quality = GetStateQuality(state);
   
   double estimatedProfit = quality * 100.0;
   
   if(ArraySize(g_stateAvgProfit) > state)
   {
      g_stateAvgProfit[state] = estimatedProfit;
   }
   
   return estimatedProfit;
}

void UpdateStateStats(int state, double profit, int action)
{
   if(state < 0 || state >= NUM_STATES) return;
   if(ArraySize(g_stateWinRate) <= state) return;
   if(ArraySize(g_stateAvgProfit) <= state) return;
   
   double winRate = CalculateWinRate(state);
   g_stateWinRate[state] = winRate;
   
   double currentAvg = g_stateAvgProfit[state];
   int visits = g_stateVisits[state];
   
   if(visits > 0)
   {
      double alpha = 0.1;
      double newAvg = currentAvg * (1 - alpha) + profit * alpha;
      g_stateAvgProfit[state] = newAvg;
   }
   else
   {
      g_stateAvgProfit[state] = profit;
   }
}

// ======================================================================
// âœ…âœ…âœ… âœ…âœ…âœ… OnTradeTransaction - CORRIGIDA COMPLETAMENTE (PONTO CRÃTICO)
// ======================================================================
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &request,
                        const MqlTradeResult &result)
{
   if(trans.type != TRADE_TRANSACTION_DEAL_ADD) return;
   if(trans.symbol != _Symbol) return;

   ulong deal_ticket = trans.deal;
   
   if(!HistoryDealSelect(deal_ticket)) return;

   long dmagic = HistoryDealGetInteger(deal_ticket, DEAL_MAGIC);
   if(dmagic != MagicNumber) return;

   long entry_type = HistoryDealGetInteger(deal_ticket, DEAL_ENTRY);
   if(entry_type != DEAL_ENTRY_OUT) return;

   // DEBUG: Logar todos os detalhes
   Print("=== ONTRADETRANSACTION CHAMADO ===");
   Print("Deal Ticket: ", deal_ticket);
   Print("g_lastTradeState: ", g_lastTradeState);
   Print("g_lastTradeAction: ", g_lastTradeAction);
   Print("g_lastTradeExecuted: ", g_lastTradeExecuted);

   double profit = HistoryDealGetDouble(deal_ticket, DEAL_PROFIT);
   double commission = HistoryDealGetDouble(deal_ticket, DEAL_COMMISSION);
   double swap = HistoryDealGetDouble(deal_ticket, DEAL_SWAP);
   double net_profit = profit + commission + swap;

   double reward = ComputeRewardFromTrade(net_profit);
   
   g_totalTrades++;
   g_sumProfit += net_profit;
   
   // âš ï¸ DIAGNÃ“STICO DETALHADO
   Print("DIAGNÃ“STICO DETALHADO:");
   Print("net_profit: ", DoubleToString(net_profit, 2));
   Print("g_lastTradeAction: ", g_lastTradeAction, " (0=NOP, 1=BUY, 2=SELL)");
   Print("g_lastTradeState: ", g_lastTradeState);
   Print("g_lastTradeExecuted: ", g_lastTradeExecuted);
   
   if(g_lastTradeState >= 0 && g_lastTradeState < NUM_STATES)
   {
      Print("Estado vÃ¡lido detectado: ", g_lastTradeState);
      Print("Visitas atuais: ", g_stateVisits[g_lastTradeState]);
      Print("VitÃ³rias atuais: ", g_stateWins[g_lastTradeState]);
      Print("Perdas atuais: ", g_stateLosses[g_lastTradeState]);
      
      // âš ï¸ CORREÃ‡ÃƒO DEFINITIVA: Contar APENAS se foi trade real (BUY/SELL)
      if(g_lastTradeAction == 1 || g_lastTradeAction == 2) // BUY ou SELL
      {
         g_stateVisits[g_lastTradeState]++;
         g_stateLastUpdate[g_lastTradeState] = g_totalTrades;
         
         if(net_profit > 0) 
         {
            g_totalWins++;
            g_stateWins[g_lastTradeState]++;
            Print("âœ…âœ…âœ… VITÃ“RIA REGISTRADA para estado ", g_lastTradeState);
         }
         else 
         {
            g_totalLosses++;
            g_stateLosses[g_lastTradeState]++;
            Print("âŒâŒâŒ PERDA REGISTRADA para estado ", g_lastTradeState);
            
            if(EnableUnifiedBlockingSystem && g_stateVisits[g_lastTradeState] >= MinVisitsForBlockDecision)
            {
               EvaluateAndUpdateBlockState(g_lastTradeState);
            }
         }
         
         Print("PÃ“S-ATUALIZAÃ‡ÃƒO Estado ", g_lastTradeState, ":");
         Print("  Visitas: ", g_stateVisits[g_lastTradeState]);
         Print("  VitÃ³rias: ", g_stateWins[g_lastTradeState]);
         Print("  Perdas: ", g_stateLosses[g_lastTradeState]);
      }
      else
      {
         Print("âš ï¸ NOP detectado - NÃƒO contando visita/perda");
      }
   }
   else
   {
      Print("âš ï¸ Estado invÃ¡lido ou nÃ£o definido");
   }
   
   g_lastTradeProfit = net_profit;
   g_lastTradeDate   = TimeCurrent();
   
   if(g_firstTradeDate == 0) g_firstTradeDate = TimeCurrent();
   
   UpdateProfitHistory(net_profit);
   
   if(g_lastTradeAction == 1 || g_lastTradeAction == 2)
   {
      UpdateDirectionStats(g_lastTradeAction == 1, net_profit);
   }
   
   UpdateStreaks(net_profit);
   
   if((g_lastTradeAction == 1 || g_lastTradeAction == 2) && g_lastTradeState >= 0)
   {
      UpdateStateStats(g_lastTradeState, net_profit, g_lastTradeAction);
      UpdateQ(g_lastTradeState, g_lastTradeAction, reward);
   }
   
   if(net_profit < 0) 
   {
      g_consecutiveLosses++;
      Print("ğŸ“‰ Perda consecutiva #", g_consecutiveLosses);
   }
   else 
   {
      g_consecutiveLosses = 0;
      Print("ğŸ“ˆ VitÃ³ria - resetando perdas consecutivas");
   }

   // Reset flags
   g_lastTradeState  = -1;
   g_lastTradeAction = 0;
   g_lastTradeExecuted = false;
   g_lastTradeStateExecuted = -1;
   
   if(GetTotalPositions() == 0)
   {
      g_currentDirection = 0;
      g_positionsCount = 0;
      cachedPositions = -1;
      cachedDirection = -1;
   }
   
   // Chamar diagnÃ³stico a cada 10 trades
   if(g_totalTrades % 10 == 0)
   {
      DebugTradeCounting();
      MonitorBadStates();
   }
   
   // Chamar debug de bloqueio a cada 25 trades
   if(g_totalTrades % 25 == 0)
   {
      DebugBlockedStates();
   }
   
   // ForÃ§ar save a cada trade crÃ­tico
   if(g_lastTradeAction == 1 || g_lastTradeAction == 2)
   {
      SaveState();
      SaveBrain();
   }
   
   Print("=== FIM ONTRADETRANSACTION ===");
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡Ã•ES PARA APRENDIZADO EVOLUTIVO
// ======================================================================

void UpdateLearningStats()
{
   g_totalStatesDiscovered = g_activeStatesCount;
   
   double sumQ = 0.0;
   int qCount = 0;
   g_maxQValue = -DBL_MAX;
   g_minQValue = DBL_MAX;
   
   for(int i = 0; i < NUM_STATES * NUM_ACTIONS; i++)
   {
      if(g_Q[i] != 0.0)
      {
         sumQ += g_Q[i];
         qCount++;
         if(g_Q[i] > g_maxQValue) g_maxQValue = g_Q[i];
         if(g_Q[i] < g_minQValue) g_minQValue = g_Q[i];
      }
   }
   
   if(qCount > 0)
   {
      g_averageQValue = sumQ / qCount;
   }
   else
   {
      g_averageQValue = 0.0;
   }
}

void UpdateProfitHistory(double profit)
{
   if(ArraySize(g_recentProfits) < 100)
   {
      ArrayResize(g_recentProfits, 100);
      ArrayInitialize(g_recentProfits, 0.0);
   }
   
   g_recentProfits[g_recentProfitsIndex] = profit;
   g_recentProfitsIndex = (g_recentProfitsIndex + 1) % 100;
   
   if(profit > g_highestProfit) g_highestProfit = profit;
   if(profit < g_lowestProfit) g_lowestProfit = profit;
}

void UpdateDirectionStats(bool isBuy, double profit)
{
   if(isBuy)
   {
      g_totalBuys++;
      if(profit > 0) g_buyWins++;
      g_buyProfit += profit;
   }
   else
   {
      g_totalSells++;
      if(profit > 0) g_sellWins++;
      g_sellProfit += profit;
   }
}

void UpdateStreaks(double profit)
{
   if(profit > 0)
   {
      g_currentWinStreak++;
      g_currentLossStreak = 0;
      
      if(g_currentWinStreak > g_bestWinStreak)
      {
         g_bestWinStreak = g_currentWinStreak;
      }
   }
   else if(profit < 0)
   {
      g_currentLossStreak++;
      g_currentWinStreak = 0;
      
      if(g_currentLossStreak > g_worstLossStreak)
      {
         g_worstLossStreak = g_currentLossStreak;
      }
   }
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO: EXPORTAÃ‡ÃƒO FORÃ‡ADA (para chamar manualmente)
// ======================================================================
void ForceTextExport()
{
   if(ExportMemoryToTextFileFunc(true))
   {
      Print("âœ… ExportaÃ§Ã£o forÃ§ada para texto realizada com sucesso!");
   }
   else
   {
      Print("âŒ Falha na exportaÃ§Ã£o forÃ§ada para texto");
   }
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO: CRIAR RELATÃ“RIO RESUMIDO DIÃRIO
// ======================================================================
void CreateDailySummaryReport()
{
   // âœ… OTIMIZAÃ‡ÃƒO: Usar arquivo consolidado de logs ao invÃ©s de criar mÃºltiplos arquivos diÃ¡rios
   string filename = "Phoenix_Files/Text_Logs/Phoenix_Daily_Log_" + _Symbol + "_" + 
                     EnumToString((ENUM_TIMEFRAMES)_Period) + ".txt";
   
   if(!CreateDirectoryForFile(filename)) return;
   
   int file_handle = FileOpen(filename, FILE_WRITE|FILE_READ|FILE_TXT|FILE_ANSI|FILE_COMMON);
   if(file_handle == INVALID_HANDLE) return;
   
   // Posicionar no final para append
   FileSeek(file_handle, 0, SEEK_END);
   
   FileWrite(file_handle, "");
   FileWrite(file_handle, "================================================================");
   FileWrite(file_handle, "RELATÃ“RIO DIÃRIO - PHOENIX TRADER v307F");
   FileWrite(file_handle, "Data: " + TimeToString(TimeCurrent(), TIME_DATE));
   FileWrite(file_handle, "================================================================");
   FileWrite(file_handle, "");
   FileWrite(file_handle, "ğŸ“ˆ RESUMO DO DIA (SISTEMA SUPER CORRIGIDO)");
   FileWrite(file_handle, "----------------------------------------");
   FileWrite(file_handle, "Trades REAIS Realizados: " + IntegerToString(g_tradesToday));
   FileWrite(file_handle, "Estados Ativos: " + IntegerToString(g_activeStatesCount));
   FileWrite(file_handle, "Estados Bloqueados: " + IntegerToString(CountBlockedStates()));
   FileWrite(file_handle, "Volume MÃ©dio Multiplicador: " + DoubleToString(g_volumeMultiplier, 2) + "x");
   FileWrite(file_handle, "Ciclos de Decay: " + IntegerToString(g_totalDecayCycles));
   FileWrite(file_handle, "Estados Resetados: " + IntegerToString(g_totalBadStateResets));
   FileWrite(file_handle, "");
   FileWrite(file_handle, "ğŸ§  PROGRESSO DO APRENDIZADO (SISTEMA SUPER CORRIGIDO)");
   FileWrite(file_handle, "----------------------------------------");
   double discoveryPercent = (double)g_activeStatesCount/NUM_STATES*100;
   FileWrite(file_handle, "Estados Descobertos: " + IntegerToString(g_activeStatesCount) + "/" + 
            IntegerToString(NUM_STATES) + " (" + DoubleToString(discoveryPercent, 1) + "%)");
   FileWrite(file_handle, "Taxa de ExploraÃ§Ã£o: " + DoubleToString(g_currentExplorationRate * 100, 1) + "%");
   FileWrite(file_handle, "Contagem Corrigida: " + IntegerToString(g_totalTrades) + " trades REAIS");
   FileWrite(file_handle, "");
   FileWrite(file_handle, "ğŸ›¡ï¸ CORREÃ‡Ã•ES IMPLEMENTADAS:");
   FileWrite(file_handle, "1. âœ… CÃ¡lculo de estados corrigido (576 estados)");
   FileWrite(file_handle, "2. âœ… Reset automÃ¡tico funcionando");
   FileWrite(file_handle, "3. âœ… Estados nÃ£o travam mais em 10 visitas");
   FileWrite(file_handle, "4. âœ… Regras de bloqueio mais agressivas");
   FileWrite(file_handle, "5. âœ… Debug de estados travados implementado");
   FileWrite(file_handle, "");
   FileWrite(file_handle, "================================================================");
   FileWrite(file_handle, "FIM DO RELATÃ“RIO - SISTEMA SUPER CORRIGIDO v307F");
   FileWrite(file_handle, "================================================================");
   
   FileClose(file_handle);
   
   Print("ğŸ“‹ RelatÃ³rio diÃ¡rio criado: ", filename);
}

// ======================================================================
// âœ… FUNÃ‡Ã•ES ADICIONAIS QUE ESTAVAM FALTANDO
// ======================================================================

bool ShouldAutoExport()
{
   if(!EnableMemoryExport) return false;
   if(AutoExportMinutes <= 0) return false;
   
   datetime currentTime = TimeCurrent();
   if(g_lastExportTime == 0) 
   {
      g_lastExportTime = currentTime;
      return true;
   }
   
   int minutesPassed = (int)((currentTime - g_lastExportTime) / 60);
   return minutesPassed >= AutoExportMinutes;
}

bool ExportAllMemoryFiles()
{
   if(!EnableMemoryExport) return false;
   
   Print("ğŸ“¤ Exportando arquivos de memÃ³ria...");
   
   if(!SaveBrain()) return false;
   
   g_lastExportTime = TimeCurrent();
   g_exportCount++;
   
   Print("âœ… Arquivos de memÃ³ria exportados com sucesso!");
   return true;
}

// ======================================================================
// âœ…âœ…âœ… âœ…âœ…âœ… FUNÃ‡ÃƒO PRINCIPAL OnTick (COM SISTEMA SUPER CORRIGIDO E NOVAS FUNÃ‡Ã•ES)
// ======================================================================
void OnTick()
{
   static datetime last_bar_time = 0;
   datetime current_bar_time = iTime(_Symbol,_Period,0);

   // âœ… MONITORAMENTO DE PERFORMANCE A CADA 100 TICKS
   static int tickCounter = 0;
   tickCounter++;
   
   if(tickCounter % 100 == 0)
   {
      double currentWinRate = SafeDivide((double)g_totalWins, (double)g_totalTrades, 0.0);
      
      if(currentWinRate < 0.20)
      {
         Print("âš ï¸âš ï¸âš ï¸ ALERTA: Win rate crÃ­tica (", DoubleToString(currentWinRate*100,1), "%)");
         
         // Se performance muito ruim por muito tempo
         static int badPerformanceCounter = 0;
         badPerformanceCounter++;
         
         if(badPerformanceCounter >= 5)
         {
            Print("ğŸ”¥ ATIVAÃ‡ÃƒO DE CORREÃ‡ÃƒO DE EMERGÃŠNCIA");
            EmergencyCounterFix();
            OverhaulBlockingSystem();
            badPerformanceCounter = 0;
         }
      }
      
      // Verificar bloqueios excessivos
      double blockedRatio = SafeDivide((double)CountBlockedStates(), (double)g_activeStatesCount, 0.0);
      if(blockedRatio > 0.7 && g_activeStatesCount > 50)
      {
         Print("âš ï¸ Muitos estados bloqueados (", DoubleToString(blockedRatio*100,1), "%)");
         IntelligentPartialReset();
      }
   }

   // âœ… CHAMAR CORREÃ‡Ã•ES A CADA HORA
   static datetime lastMaintenanceCall = 0;
   if(TimeCurrent() - lastMaintenanceCall >= 3600)
   {
      PerformMemoryMaintenance();
      
      // âœ… OTIMIZAÃ‡ÃƒO DINÃ‚MICA
      OptimizeParametersDynamically();
      
      lastMaintenanceCall = TimeCurrent();
   }

   if(UseDynamicTrailingStop)
   {
      ManageAllDynamicStops();
   }

   if(current_bar_time != last_bar_time)
   {
      last_bar_time = current_bar_time;
      
      // âœ… DEBUG PERIÃ“DICO MELHORADO
      static int debugCounter = 0;
      debugCounter++;
      
      if(debugCounter % 50 == 0)
      {
         DebugStuckStatesEnhanced();
      }
      
      if(debugCounter % 100 == 0)
      {
         ResetBadStatesEnhanced();
      }

      MqlDateTime today,last;
      TimeToStruct(TimeCurrent(),today);
      TimeToStruct(g_lastResetDate,last);

      bool new_day = (g_lastResetDate==0) ||
                     (today.day != last.day ||
                      today.mon != last.mon ||
                      today.year != last.year);

      if(new_day)
      {
         g_tradesToday=0;
         g_consecutiveLosses=0;
         g_lastResetDate=TimeCurrent();
         cachedTradesToday = -1;
         
         // âœ… RESET PARCIAL DO SISTEMA DE BLOQUEIO A CADA DIA
         ResetBadStatesEnhanced();
         
         if(EnableTextExport)
         {
            CreateDailySummaryReport();
         }
      }

      if(g_tradesToday >= MaxTradesPerDay)
      {
         g_statusMessage = StringFormat("â›” Limite diÃ¡rio (%d) atingido", MaxTradesPerDay);
      }
      else if(g_consecutiveLosses >= ConsecutiveLossLimit)
      {
         g_statusMessage = StringFormat("â›” %d perdas consecutivas", ConsecutiveLossLimit);
      }
      else
      {
         g_statusMessage = "Analisando (Sistema Corrigido v2)";
            
         int s = GetCurrentState();
         if(s < 0)
         {
            g_statusMessage = "Aguardando dados dos indicadores";
         }
         else
         {
            // âœ… VERIFICAÃ‡ÃƒO DE BLOQUEIO MAIS INTELIGENTE
            if(IsStateBlocked(s))
            {
               double winRate = CalculateWinRate(s);
               
               // Auto-desbloqueio se performance melhorou
               if(winRate >= 0.35 && g_stateVisits[s] >= 5)
               {
                  g_stateBlocked[s] = false;
                  Print("ğŸ”„ AUTO-DESBLOQUEIO Estado ", s, 
                        " | Win Rate: ", DoubleToString(winRate*100,1), "%");
               }
               else
               {
                  g_statusMessage = StringFormat("â›” Estado %d bloqueado", s);
                  UpdateQ_NOP(s);
                  return;
               }
            }
            
            int a = ChooseAction(s);
            
            if(a == 0)
            {
               g_statusMessage = "NOP (AnÃ¡lise)";
               UpdateQ_NOP(s);
            }
            else
            {
               ExecuteAction(a,s);
            }
         }
      }
   }

   UpdateHUDLight();
   
   static datetime lastTextExportCheck = 0;
   datetime currentTime = TimeCurrent();
   if(currentTime - lastTextExportCheck >= 60)
   {
      lastTextExportCheck = currentTime;
      ExportMemoryToTextFileFunc(false);
   }
}

// ======================================================================
// âœ…âœ…âœ… FUNÃ‡ÃƒO ExportMemoryToTextFileFunc (OTIMIZADA - ARQUIVO ÃšNICO)
// ======================================================================
bool ExportMemoryToTextFileFunc(bool forceExport = false)
{
   if(!EnableTextExport && !forceExport) return false;
   
   datetime currentTime = TimeCurrent();
   if(!forceExport && g_lastTextExportTime > 0)
   {
      int minutesPassed = (int)((currentTime - g_lastTextExportTime) / 60);
      if(minutesPassed < TextExportMinInterval) return false;
   }
   
   // âœ… OTIMIZAÃ‡ÃƒO: Usar arquivo Ãºnico ao invÃ©s de criar mÃºltiplos arquivos
   string filename = "Phoenix_Files/Text_Logs/Phoenix_Memory_" + _Symbol + "_" + 
                     EnumToString((ENUM_TIMEFRAMES)_Period) + ".txt";
   
   if(!CreateDirectoryForFile(filename))
   {
      Print("âŒ Erro ao criar diretÃ³rio para arquivo texto: ", filename);
      return false;
   }
   
   // Abrir em modo APPEND para adicionar ao arquivo existente
   int file_handle = FileOpen(filename, FILE_WRITE|FILE_READ|FILE_TXT|FILE_ANSI|FILE_COMMON);
   if(file_handle == INVALID_HANDLE)
   {
      Print("âŒ Erro ao abrir arquivo texto: ", filename, " | Erro: ", GetLastError());
      return false;
   }
   
   // âœ… Posicionar no final do arquivo para append
   FileSeek(file_handle, 0, SEEK_END);
   
   // âœ… Separador de entrada
   FileWrite(file_handle, "");
   FileWrite(file_handle, "=================================================================");
   FileWrite(file_handle, "PHOENIX TRADER v307F - SNAPSHOT " + TimeToString(currentTime));
   FileWrite(file_handle, "Symbol: " + _Symbol + " | Timeframe: " + EnumToString((ENUM_TIMEFRAMES)_Period));
   FileWrite(file_handle, "=================================================================");
   
   string systemInfo = "Estados totais possÃ­veis: " + IntegerToString(NUM_STATES) + " (3Ã—4Ã—2Ã—3Ã—2Ã—2Ã—2 = 576)";
   FileWrite(file_handle, systemInfo);
   
   string activeInfo = "Estados ativos na memÃ³ria: " + IntegerToString(g_activeStatesCount);
   FileWrite(file_handle, activeInfo);
   
   string blockedInfo = "Estados bloqueados: " + IntegerToString(CountBlockedStates());
   FileWrite(file_handle, blockedInfo);
   
   double discoveryRate = SafeDivide((double)g_activeStatesCount, (double)NUM_STATES, 0.0) * 100;
   string discoveryInfo = "Taxa de descoberta: " + DoubleToString(discoveryRate, 1) + "%";
   FileWrite(file_handle, discoveryInfo);
   
   string decayInfo = "Ciclos de decay: " + IntegerToString(g_totalDecayCycles);
   FileWrite(file_handle, decayInfo);
   
   string resetInfo = "Estados resetados: " + IntegerToString(g_totalBadStateResets);
   FileWrite(file_handle, resetInfo);
   
   if(IncludeStatistics)
   {
      FileWrite(file_handle, "");
      FileWrite(file_handle, "ğŸ“Š ESTATÃSTICAS GERAIS (SISTEMA SUPER CORRIGIDO)");
      FileWrite(file_handle, "----------------------------------------");
      
      string totalTrades = "Total de Trades REAIS: " + IntegerToString(g_totalTrades);
      FileWrite(file_handle, totalTrades);
      
      if(g_totalTrades > 0)
      {
         double winRate = SafeDivide((double)g_totalWins, (double)g_totalTrades, 0.0) * 100;
         double lossRate = SafeDivide((double)g_totalLosses, (double)g_totalTrades, 0.0) * 100;
         
         string winsInfo = "  VitÃ³rias REAIS: " + IntegerToString(g_totalWins) + 
                          " (" + DoubleToString(winRate, 1) + "%)";
         FileWrite(file_handle, winsInfo);
         
         string lossesInfo = "  Derrotas REAIS: " + IntegerToString(g_totalLosses) + 
                           " (" + DoubleToString(lossRate, 1) + "%)";
         FileWrite(file_handle, lossesInfo);
         
         // VerificaÃ§Ã£o de integridade
         int soma = g_totalWins + g_totalLosses;
         int diferenca = g_totalTrades - soma;
         FileWrite(file_handle, "  Soma Wins+Losses: " + IntegerToString(soma));
         FileWrite(file_handle, "  DiferenÃ§a (NOPs): " + IntegerToString(diferenca));
      }
      else
      {
         FileWrite(file_handle, "  VitÃ³rias: 0 (0.0%)");
         FileWrite(file_handle, "  Derrotas: 0 (0.0%)");
      }
      
      string totalProfit = "Lucro Total: " + DoubleToString(g_sumProfit, 2);
      FileWrite(file_handle, totalProfit);
      
      string tradesToday = "Trades Hoje: " + IntegerToString(g_tradesToday) + "/" + IntegerToString(MaxTradesPerDay);
      FileWrite(file_handle, tradesToday);
      
      string consecutiveLosses = "Perdas Consecutivas: " + IntegerToString(g_consecutiveLosses) + 
                               "/" + IntegerToString(ConsecutiveLossLimit);
      FileWrite(file_handle, consecutiveLosses);
      
      // âš ï¸ GARANTIR QUE EXPLORAÃ‡ÃƒO NÃƒO PASSE DE 100%
      double exploration = MathMin(g_currentExplorationRate * 100, 100.0);
      string explorationStr = "Taxa ExploraÃ§Ã£o: " + DoubleToString(exploration, 1) + "%";
      FileWrite(file_handle, explorationStr);
   }
   
   FileWrite(file_handle, "");
   FileWrite(file_handle, "ğŸ“ˆ TOP 20 ESTADOS MAIS VISITADOS (SISTEMA SUPER CORRIGIDO)");
   FileWrite(file_handle, "----------------------------------------");
   
   int sortedStates[][2];
   ArrayResize(sortedStates, g_activeStatesCount);
   
   for(int i = 0; i < g_activeStatesCount; i++)
   {
      int state = g_activeStates[i];
      sortedStates[i][0] = state;
      sortedStates[i][1] = g_stateVisits[state];
   }
   
   for(int i = 0; i < g_activeStatesCount - 1; i++)
   {
      for(int j = i + 1; j < g_activeStatesCount; j++)
      {
         if(sortedStates[j][1] > sortedStates[i][1])
         {
            int tempState = sortedStates[i][0];
            int tempVisits = sortedStates[i][1];
            
            sortedStates[i][0] = sortedStates[j][0];
            sortedStates[i][1] = sortedStates[j][1];
            
            sortedStates[j][0] = tempState;
            sortedStates[j][1] = tempVisits;
         }
      }
   }
   
   int limit = MathMin(20, g_activeStatesCount);
   for(int i = 0; i < limit; i++)
   {
      int state = sortedStates[i][0];
      int visits = sortedStates[i][1];
      int losses = g_stateLosses[state];
      int wins = g_stateWins[state];
      double winRate = SafeDivide((double)wins, (double)visits, 0.0) * 100;
      bool isBlocked = g_stateBlocked[state];
      
      string stateLine = IntegerToString(i+1) + ". Estado " + IntegerToString(state) + 
                        ": " + IntegerToString(visits) + " visitas REAIS | " + 
                        IntegerToString(wins) + " vitÃ³rias REAIS (" + 
                        DoubleToString(winRate, 1) + "%) | " + 
                        IntegerToString(losses) + " perdas REAIS" + 
                        (isBlocked ? " [BLOQUEADO]" : "");
      FileWrite(file_handle, stateLine);
   }
   
   FileWrite(file_handle, "");
   FileWrite(file_handle, "=================================================================");
   FileWrite(file_handle, "FIM DA EXPORTAÃ‡ÃƒO - SISTEMA SUPER CORRIGIDO v307F");
   FileWrite(file_handle, "=================================================================");
   
   FileClose(file_handle);
   
   g_lastTextExportTime = currentTime;
   g_textExportCount++;
   
   Print("ğŸ“„ MemÃ³ria exportada para texto: ", filename, 
         " | Estados: ", g_activeStatesCount,
         " | Bloqueados: ", CountBlockedStates(),
         " | Trades reais: ", g_totalTrades,
         " | Ciclos decay: ", g_totalDecayCycles,
         " | Resets: ", g_totalBadStateResets);
   
   return true;
}

// ======================================================================
// âœ…âœ…âœ… âœ…âœ…âœ… OnInit (COM SISTEMA SUPER CORRIGIDO)
// ======================================================================
int OnInit()
{
   trade.SetExpertMagicNumber(MagicNumber);
   trade.SetTypeFillingBySymbol(_Symbol);
   trade.SetDeviationInPoints(30);

   MathSrand((int)GetTickCount64());

   g_maHandle      = iMA(_Symbol, _Period, MAPeriod, 0, MAMethod, PRICE_CLOSE);
   g_adxHandle     = iADX(_Symbol, _Period, 20);
   g_rsiHandle     = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE);
   g_bbHandle      = iBands(_Symbol, _Period, BBPeriod, 0, BBDeviation, PRICE_CLOSE);
   g_atrHandle     = iATR(_Symbol, _Period, ATRPeriod);

   if(g_maHandle == INVALID_HANDLE || g_adxHandle == INVALID_HANDLE ||
      g_rsiHandle == INVALID_HANDLE || g_bbHandle == INVALID_HANDLE ||
      g_atrHandle == INVALID_HANDLE)
   {
      Print("âŒ Falha ao criar indicadores");
      return INIT_FAILED;
   }

   int sz = NUM_STATES * NUM_ACTIONS;
   ArrayResize(g_Q, sz);
   ArrayInitialize(g_Q, 0.0);
   
   ArrayResize(g_stateVisits, NUM_STATES);
   ArrayInitialize(g_stateVisits, 0);
   
   ArrayResize(g_stateLosses, NUM_STATES);
   ArrayInitialize(g_stateLosses, 0);
   
   ArrayResize(g_stateWins, NUM_STATES);
   ArrayInitialize(g_stateWins, 0);
   
   ArrayResize(g_stateLastUpdate, NUM_STATES);
   ArrayInitialize(g_stateLastUpdate, 0);
   
   ArrayResize(g_stateBlocked, NUM_STATES);
   ArrayInitialize(g_stateBlocked, false);
   
   ArrayResize(g_stateLastBlockTime, NUM_STATES);
   ArrayInitialize(g_stateLastBlockTime, 0);
   
   ArrayResize(g_stateLastUnblockTime, NUM_STATES);
   ArrayInitialize(g_stateLastUnblockTime, 0);
   
   ArrayResize(g_activeStates, MaxMemoryStates);
   g_activeStatesCount = 0;

   LoadState();

   if(!LoadBrain())
   {
      g_currentExplorationRate = MathMax(InitialExplorationRate, 0.40);
      g_memoryInitialized = true;
      SaveBrain();
      Print("âœ… Novo cÃ©rebro criado (Sistema Super Corrigido v307F)");
   }
   else
   {
      g_memoryInitialized = true;
      Print("âœ… CÃ©rebro existente carregado (Sistema Super Corrigido v307F)");
   }
   
   ArrayResize(g_recentProfits, 100);
   ArrayInitialize(g_recentProfits, 0.0);
   g_recentProfitsIndex = 0;
   
   g_currentVolume = 0;
   g_volumeAverage = 0;
   g_volumeMultiplier = 1.0;
   g_volumeStrength = 0.0;
   
   UpdateLearningStats();
   
   g_statusMessage = "Inicializando Sistema Super Corrigido v307F...";
   
   g_lastSaveTime  = TimeCurrent();
   g_lastEntryTime = 0;
   g_lastTradeTime = 0;
   g_lastBuyTime = 0;
   g_lastSellTime = 0;
   g_lastBarProcessed = 0;
   g_lastExportTime = 0;
   g_exportCount = 0;
   g_currentDirection = 0;
   g_positionsCount = 0;

   g_currentDirection = GetCurrentPositionsDirection();
   g_positionsCount = GetTotalPositions();
   
   if(g_currentDirection == 3)
   {
      Print("âš ï¸ ATENÃ‡ÃƒO: Encontradas posiÃ§Ãµes em ambas as direÃ§Ãµes!");
      if(CloseOppositeOnNewSignal) CloseAllPositions();
   }

   Print("ğŸ”¥ğŸ”¥ğŸ”¥ INICIALIZANDO SISTEMA SUPER CORRIGIDO...");
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ CONFIGURAÃ‡ÃƒO DE ESTADOS:");
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ Bins por indicador:");
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ MA Distance: ", BINS_MA_DIST);
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ RSI: ", BINS_RSI);
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ ADX: ", BINS_ADX);
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ BB Position: ", BINS_BBPOS);
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ Volatilidade: ", BINS_VOLATILITY);
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ Volume: ", BINS_VOLUME);
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ Tempo: ", BINS_TIME);
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ TOTAL DE ESTADOS: ", NUM_STATES, " (3Ã—4Ã—2Ã—3Ã—2Ã—2Ã—2 = 576)");
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ MEMÃ“RIA MÃXIMA: ", MaxMemoryStates, " estados ativos");
   Print("ğŸ”¥ğŸ”¥ğŸ”¥ SISTEMA SUPER CORRIGIDO: ATIVADO");
   
   // âœ… CONFIGURAÃ‡Ã•ES OTIMIZADAS FORÃ‡ADAS:
   g_currentExplorationRate = 0.40; // ForÃ§ar 40% em vez de 70%
   Print("âš™ï¸ ConfiguraÃ§Ãµes otimizadas forÃ§adas:");
   Print("   â€¢ Exploration Rate: 40%");
   Print("   â€¢ MinVisitsToTrade: 2");
   Print("   â€¢ BadStateMinVisits: 20");
   Print("   â€¢ BadStateLossThreshold: 60%");
   Print("   â€¢ MinStatesBeforeReset: 100 (previne resets prematuros)");
   
   if(EnableUnifiedBlockingSystem)
   {
      AutoUnblockGoodStates();
   }

   if(EnableMemoryExport) ExportAllMemoryFiles();

   Print("===============================================================");
   Print("âœ… PHOENIX TRADER V307F - SISTEMA SUPER CORRIGIDO V2");
   Print("===============================================================");
   Print("ğŸ”´ CORREÃ‡Ã•ES EXTREMAS IMPLEMENTADAS:");
   Print("   1. âœ… REMOÃ‡ÃƒO COMPLETA do limite de 10 visitas");
   Print("   2. âœ… Auto-desbloqueio de estados com win rate > 35%");
   Print("   3. âœ… Reset parcial em vez de completo");
   Print("   4. âœ… CorreÃ§Ã£o automÃ¡tica de estados travados");
   Print("   5. âœ… Sistema anti-bloqueio-erroneo ativado");
   Print("ğŸ”¥ NOVAS FUNÃ‡Ã•ES ADICIONADAS:");
   Print("   â€¢ EmergencyCounterFix() - CorreÃ§Ã£o emergencial de contadores");
   Print("   â€¢ OverhaulBlockingSystem() - RevisÃ£o completa do bloqueio");
   Print("   â€¢ IntelligentPartialReset() - Reset parcial inteligente");
   Print("   â€¢ OptimizeParametersDynamically() - OtimizaÃ§Ã£o dinÃ¢mica");
   Print("===============================================================");
   
   // âœ… FunÃ§Ãµes de correÃ§Ã£o inicial removidas (nÃ£o mais necessÃ¡rias)
   
   if(ShowHUD)
   {
      CreateHUDObjects();
      ChartRedraw(0);
      Print("ğŸ–¥ï¸ HUD inicializado com ", hudObjectCount, " objetos");
   }
   
   g_statusMessage = "Pronto para operar (Sistema Super Corrigido v307F)";
   
   return INIT_SUCCEEDED;
}

// ======================================================================
// âœ…âœ…âœ… OnDeinit (COM SISTEMA SUPER CORRIGIDO)
// ======================================================================
void OnDeinit(const int reason)
{
   Print("ğŸ’¾ Salvando memÃ³ria antes de fechar...");
   
   if(g_memoryInitialized)
   {
      SaveBrain();
   }
   
   SaveState();
   
   if(CreateBackupFiles)
   {
      string finalBackup = "Phoenix_Files/Backups/final_backup_" + 
                          TimeToString(TimeCurrent(), TIME_DATE) + "_SUPER_CORRIGIDO.bin";
      SaveBrainToFile(finalBackup);
   }
   
   if(EnableTextExport)
   {
      ExportMemoryToTextFileFunc(true);
   }
   
   IndicatorRelease(g_maHandle);
   IndicatorRelease(g_adxHandle);
   IndicatorRelease(g_rsiHandle);
   IndicatorRelease(g_bbHandle);
   IndicatorRelease(g_atrHandle);

   RemoveHUD();
}
